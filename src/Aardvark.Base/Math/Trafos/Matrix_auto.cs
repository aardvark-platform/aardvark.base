using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Diagnostics;

namespace Aardvark.Base
{
    // AUTOGENERATED CODE - DO NOT CHANGE!

    #region M22i

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M22i : IValidity, IMatrix<double>
    {
        [DataMember]
        public int M00, M01;
        [DataMember]
        public int M10, M11;

        #region Constructors

        public M22i(int value)
        {
            M00 = value; M01 = value; 
            M10 = value; M11 = value; 
        }

        public M22i(
                int m00, int m01, 
                int m10, int m11)
        {
            M00 = m00; M01 = m01; 
            M10 = m10; M11 = m11; 
        }

        public M22i(int[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M10 = a[2];
            M11 = a[3];
        }

        public M22i(int[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M10 = a[start + 2];
            M11 = a[start + 3];
        }

        public M22i(M23i m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        public M22i(M33i m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        public M22i(M34i m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        public M22i(M44i m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        public M22i(M22l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        public M22i(M23l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        public M22i(M33l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        public M22i(M34l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        public M22i(M44l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        public M22i(M22f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        public M22i(M23f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        public M22i(M33f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        public M22i(M34f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        public M22i(M44f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        public M22i(M22d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        public M22i(M23d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        public M22i(M33d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        public M22i(M34d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        public M22i(M44d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        #endregion

        #region Conversions

        public static explicit operator M22i(M23i m)
        {
            return new M22i {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22i(M33i m)
        {
            return new M22i {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22i(M34i m)
        {
            return new M22i {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22i(M44i m)
        {
            return new M22i {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22i(M22l m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M23l m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M33l m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M34l m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M44l m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M22f m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M23f m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M33f m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M34f m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M44f m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M22d m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M23d m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M33d m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M34d m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M44d m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(int[] a)
        {
            return new M22i(
                a[0], a[1], 
                a[2], a[3]);
        }

        public static explicit operator M22i(int[,] a)
        {
            return new M22i(
                a[0, 0], a[0, 1], 
                a[1, 0], a[1, 1]);
        }

        public static explicit operator int[](M22i m)
        {
            return new int[] {
                m.M00, m.M01, 
                m.M10, m.M11
            };
        }

        public static explicit operator int[,](M22i m)
        {
            return new int[,] {
                { m.M00, m.M01 }, 
                { m.M10, m.M11 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M10;
            array[index + 3] = M11;
        }

        public static explicit operator M22i(long[] a)
        {
            return new M22i(
                (int)a[0], (int)a[1], 
                (int)a[2], (int)a[3]);
        }

        public static explicit operator M22i(long[,] a)
        {
            return new M22i(
                (int)a[0, 0], (int)a[0, 1], 
                (int)a[1, 0], (int)a[1, 1]);
        }

        public static explicit operator long[](M22i m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, 
                (long)m.M10, (long)m.M11
            };
        }

        public static explicit operator long[,](M22i m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01 }, 
                { (long)m.M10, (long)m.M11 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M10;
            array[index + 3] = (long)M11;
        }

        public static explicit operator M22i(float[] a)
        {
            return new M22i(
                (int)a[0], (int)a[1], 
                (int)a[2], (int)a[3]);
        }

        public static explicit operator M22i(float[,] a)
        {
            return new M22i(
                (int)a[0, 0], (int)a[0, 1], 
                (int)a[1, 0], (int)a[1, 1]);
        }

        public static explicit operator float[](M22i m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, 
                (float)m.M10, (float)m.M11
            };
        }

        public static explicit operator float[,](M22i m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01 }, 
                { (float)m.M10, (float)m.M11 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M10;
            array[index + 3] = (float)M11;
        }

        public static explicit operator M22i(double[] a)
        {
            return new M22i(
                (int)a[0], (int)a[1], 
                (int)a[2], (int)a[3]);
        }

        public static explicit operator M22i(double[,] a)
        {
            return new M22i(
                (int)a[0, 0], (int)a[0, 1], 
                (int)a[1, 0], (int)a[1, 1]);
        }

        public static explicit operator double[](M22i m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, 
                (double)m.M10, (double)m.M11
            };
        }

        public static explicit operator double[,](M22i m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01 }, 
                { (double)m.M10, (double)m.M11 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M10;
            array[index + 3] = (double)M11;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<int, int> element_fun)
        {
            return new M22i(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<int, int, int, int> element_index0_index1_fun)
        {
            return new M22i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<int, long> element_fun)
        {
            return new M22l(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<int, int, int, long> element_index0_index1_fun)
        {
            return new M22l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<int, float> element_fun)
        {
            return new M22f(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<int, int, int, float> element_index0_index1_fun)
        {
            return new M22f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<int, double> element_fun)
        {
            return new M22d(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<int, int, int, double> element_index0_index1_fun)
        {
            return new M22d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        public int[] ToArray()
        {
            var array = new int[4];
            array[0] = M00;
            array[1] = M01;
            array[2] = M10;
            array[3] = M11;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i FromCols(V2i col0, V2i col1)
        {
            return new M22i(
                col0.X, col1.X, 
                col0.Y, col1.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i FromRows(V2i row0, V2i row1)
        {
            return new M22i(
                row0.X, row0.Y, 
                row1.X, row1.Y);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M22i"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i Scale(int tX, int tY)
        {
            return new M22i(
                tX, 0, 
                0, tY);
        }

        /// <summary>
        /// Creates a transformation <see cref="M22i"/> using a <see cref="V2i"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i Scale(V2i s)
        {
            return new M22i(
                s.X, 0, 
                0, s.Y);
        }

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<int> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M10;
                yield return M11;
            }
        }

        public IEnumerable<V2i> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2i> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
            }
        }

        public V2i R0
        {
            get { return new V2i( M00,  M01); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
            }
        }

        public V2i R1
        {
            get { return new V2i( M10,  M11); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
            }
        }

        public V2i C0
        {
            get { return new V2i( M00,  M10); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        public V2i C1
        {
            get { return new V2i( M01,  M11); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public int this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M10;
                    case 3: return M11;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M10 = value; return;
                    case 3: M11 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public int this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 2;
        public const int ElementCount = 2 * 2;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(2, 2);
        }

        public static M22i Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M22i(0);
        }

        public static M22i Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M22i(1, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public int Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + 
                    Fun.Abs(M10) + Fun.Abs(M11);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + 
                    M10 * M10 + M11 * M11);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public int NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public int NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M22i operator -(M22i m)
        {
            return new M22i(
                -m.M00, -m.M01, 
                -m.M10, -m.M11);
        }

        public static M22i operator  + (M22i a, M22i b)
        {
            return new M22i(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22i operator  + (M22i m, int s)
        {
            return new M22i(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        public static M22i operator  + (int s, M22i m)
        {
            return new M22i(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22l operator  + (M22i a, M22l b)
        {
            return new M22l(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22l operator  + (M22i m, long s)
        {
            return new M22l(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        public static M22l operator  + (long s, M22i m)
        {
            return new M22l(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22f operator  + (M22i a, M22f b)
        {
            return new M22f(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22f operator  + (M22i m, float s)
        {
            return new M22f(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        public static M22f operator  + (float s, M22i m)
        {
            return new M22f(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22d operator  + (M22i a, M22d b)
        {
            return new M22d(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22d operator  + (M22i m, double s)
        {
            return new M22d(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        public static M22d operator  + (double s, M22i m)
        {
            return new M22d(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22i operator  - (M22i a, M22i b)
        {
            return new M22i(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22i operator  - (M22i m, int s)
        {
            return new M22i(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        public static M22i operator  - (int s, M22i m)
        {
            return new M22i(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22l operator  - (M22i a, M22l b)
        {
            return new M22l(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22l operator  - (M22i m, long s)
        {
            return new M22l(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        public static M22l operator  - (long s, M22i m)
        {
            return new M22l(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22f operator  - (M22i a, M22f b)
        {
            return new M22f(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22f operator  - (M22i m, float s)
        {
            return new M22f(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        public static M22f operator  - (float s, M22i m)
        {
            return new M22f(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22d operator  - (M22i a, M22d b)
        {
            return new M22d(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22d operator  - (M22i m, double s)
        {
            return new M22d(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        public static M22d operator  - (double s, M22i m)
        {
            return new M22d(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22i operator  % (M22i a, M22i b)
        {
            return new M22i(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22i operator  % (M22i m, int s)
        {
            return new M22i(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        public static M22i operator  % (int s, M22i m)
        {
            return new M22i(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22l operator  % (M22i a, M22l b)
        {
            return new M22l(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22l operator  % (M22i m, long s)
        {
            return new M22l(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        public static M22l operator  % (long s, M22i m)
        {
            return new M22l(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22f operator  % (M22i a, M22f b)
        {
            return new M22f(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22f operator  % (M22i m, float s)
        {
            return new M22f(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        public static M22f operator  % (float s, M22i m)
        {
            return new M22f(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22d operator  % (M22i a, M22d b)
        {
            return new M22d(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22d operator  % (M22i m, double s)
        {
            return new M22d(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        public static M22d operator  % (double s, M22i m)
        {
            return new M22d(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22i operator  / (M22i a, M22i b)
        {
            return new M22i(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22i operator  / (M22i m, int s)
        {
            return new M22i(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        public static M22i operator  / (int s, M22i m)
        {
            return new M22i(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22l operator  / (M22i a, M22l b)
        {
            return new M22l(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22l operator  / (M22i m, long s)
        {
            return new M22l(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        public static M22l operator  / (long s, M22i m)
        {
            return new M22l(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22f operator  / (M22i a, M22f b)
        {
            return new M22f(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22f operator  / (M22i m, float s)
        {
            return new M22f(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        public static M22f operator  / (float s, M22i m)
        {
            return new M22f(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22d operator  / (M22i a, M22d b)
        {
            return new M22d(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22d operator  / (M22i m, double s)
        {
            return new M22d(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        public static M22d operator  / (double s, M22i m)
        {
            return new M22d(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22i operator  * (M22i m, int s)
        {
            return new M22i(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        public static M22i operator  * (int s, M22i m)
        {
            return new M22i(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22l operator  * (M22i m, long s)
        {
            return new M22l(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        public static M22l operator  * (long s, M22i m)
        {
            return new M22l(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22f operator  * (M22i m, float s)
        {
            return new M22f(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        public static M22f operator  * (float s, M22i m)
        {
            return new M22f(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22d operator  * (M22i m, double s)
        {
            return new M22d(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        public static M22d operator  * (double s, M22i m)
        {
            return new M22d(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M22i matrix with a V2i column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2i operator *(M22i m, V2i v)
        {
            return new V2i(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y);
        }

        /// <summary>
        /// Multiplies a V2i row vector with a M22i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2i operator *(V2i v, M22i m)
        {
            return new V2i(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M22i a, M22i b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11;
        }

        public static bool operator <(M22i a, int s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M10 < s && 
                a.M11 < s;
        }

        public static bool operator <(int s, M22i a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M10  && 
                s < a.M11 ;
        }

        public static bool operator >(M22i a, M22i b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11;
        }

        public static bool operator >(M22i a, int s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M10 > s && 
                a.M11 > s;
        }

        public static bool operator >(int s, M22i a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M10  && 
                s > a.M11 ;
        }

        public static bool operator ==(M22i a, M22i b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11;
        }

        public static bool operator ==(M22i a, int s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M10 == s && 
                a.M11 == s;
        }

        public static bool operator ==(int s, M22i a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M10  && 
                s == a.M11 ;
        }

        public static bool operator <=(M22i a, M22i b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11;
        }

        public static bool operator <=(M22i a, int s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M10 <= s && 
                a.M11 <= s;
        }

        public static bool operator <=(int s, M22i a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M10  && 
                s <= a.M11 ;
        }

        public static bool operator >=(M22i a, M22i b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11;
        }

        public static bool operator >=(M22i a, int s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M10 >= s && 
                a.M11 >= s;
        }

        public static bool operator >=(int s, M22i a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M10  && 
                s >= a.M11 ;
        }

        public static bool operator !=(M22i a, M22i b)
        {
            return !(a == b);
        }

        public static bool operator !=(M22i m, int s)
        {
            return !(m == s);
        }

        public static bool operator !=(int s, M22i m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M22i) ? (this == (M22i)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M22i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M22i.FromRows(
                V2i.Parse(x[0]), 
                V2i.Parse(x[1])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M22i Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return new M22i(M11, -M10, -M01, M00);
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public int Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public int Determinant
        {
            get
            {
                return M00 * M11 - M10 * M01;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M22i Transposed
        {
            get
            {
                return new M22i {
                    
                    M00 = M00, 
                    M01 = M10, 
                    
                    M10 = M01, 
                    M11 = M11
                };
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M22i operator *(M22i a, M22i b)
        {
            return new M22i(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (int)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (int)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (int)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (int)value;
        }

        #endregion
    }

    public class M22iEqualityComparer : IEqualityComparer<M22i>
    {
        public static readonly M22iEqualityComparer Default
            = new M22iEqualityComparer();

        #region IEqualityComparer<M22i> Members

        public bool Equals(M22i v0, M22i v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M22i v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Norm1(M22i m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M22i m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMax(M22i m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMin(M22i m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M22i m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static int Distance1(this M22i a, M22i b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M22i a, M22i b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M22i a, M22i b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMax(this M22i a, M22i b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMin(this M22i a, M22i b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2i Transform(this M22i m, V2i v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i Transform(this M22i m, V3i v)
        {
            return new V3i(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y,
                v.Z);
        }

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i Transform(this M22i m, V4i v)
        {
            return new V4i(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y,
                v.Z, v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2i TransposedTransform(this M22i m, V2i v)
            => v * m;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i TransposedTransform(this M22i m, V3i v)
        {
            return new V3i(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11,
                v.Z);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i TransposedTransform(this M22i m, V4i v)
        {
            return new V4i(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11,
                v.Z, v.W);
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M22i"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static int Minor(this M22i m, int row, int column)
        {
            return m[1 - row, 1 - column];
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2i Row(this M22i m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2i Column(this M22i m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Determinant(M22i m)
            => m.Determinant;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        public static void Transpose(this ref M22i m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M22i a, M22i b, int epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M22l

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M22l : IValidity, IMatrix<double>
    {
        [DataMember]
        public long M00, M01;
        [DataMember]
        public long M10, M11;

        #region Constructors

        public M22l(long value)
        {
            M00 = value; M01 = value; 
            M10 = value; M11 = value; 
        }

        public M22l(
                long m00, long m01, 
                long m10, long m11)
        {
            M00 = m00; M01 = m01; 
            M10 = m10; M11 = m11; 
        }

        public M22l(long[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M10 = a[2];
            M11 = a[3];
        }

        public M22l(long[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M10 = a[start + 2];
            M11 = a[start + 3];
        }

        public M22l(M22i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        public M22l(M23i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        public M22l(M33i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        public M22l(M34i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        public M22l(M44i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        public M22l(M23l m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        public M22l(M33l m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        public M22l(M34l m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        public M22l(M44l m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        public M22l(M22f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        public M22l(M23f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        public M22l(M33f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        public M22l(M34f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        public M22l(M44f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        public M22l(M22d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        public M22l(M23d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        public M22l(M33d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        public M22l(M34d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        public M22l(M44d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        #endregion

        #region Conversions

        public static explicit operator M22l(M22i m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M23i m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M33i m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M34i m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M44i m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M23l m)
        {
            return new M22l {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22l(M33l m)
        {
            return new M22l {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22l(M34l m)
        {
            return new M22l {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22l(M44l m)
        {
            return new M22l {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22l(M22f m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M23f m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M33f m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M34f m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M44f m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M22d m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M23d m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M33d m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M34d m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M44d m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(int[] a)
        {
            return new M22l(
                (long)a[0], (long)a[1], 
                (long)a[2], (long)a[3]);
        }

        public static explicit operator M22l(int[,] a)
        {
            return new M22l(
                (long)a[0, 0], (long)a[0, 1], 
                (long)a[1, 0], (long)a[1, 1]);
        }

        public static explicit operator int[](M22l m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, 
                (int)m.M10, (int)m.M11
            };
        }

        public static explicit operator int[,](M22l m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01 }, 
                { (int)m.M10, (int)m.M11 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M10;
            array[index + 3] = (int)M11;
        }

        public static explicit operator M22l(long[] a)
        {
            return new M22l(
                a[0], a[1], 
                a[2], a[3]);
        }

        public static explicit operator M22l(long[,] a)
        {
            return new M22l(
                a[0, 0], a[0, 1], 
                a[1, 0], a[1, 1]);
        }

        public static explicit operator long[](M22l m)
        {
            return new long[] {
                m.M00, m.M01, 
                m.M10, m.M11
            };
        }

        public static explicit operator long[,](M22l m)
        {
            return new long[,] {
                { m.M00, m.M01 }, 
                { m.M10, m.M11 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M10;
            array[index + 3] = M11;
        }

        public static explicit operator M22l(float[] a)
        {
            return new M22l(
                (long)a[0], (long)a[1], 
                (long)a[2], (long)a[3]);
        }

        public static explicit operator M22l(float[,] a)
        {
            return new M22l(
                (long)a[0, 0], (long)a[0, 1], 
                (long)a[1, 0], (long)a[1, 1]);
        }

        public static explicit operator float[](M22l m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, 
                (float)m.M10, (float)m.M11
            };
        }

        public static explicit operator float[,](M22l m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01 }, 
                { (float)m.M10, (float)m.M11 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M10;
            array[index + 3] = (float)M11;
        }

        public static explicit operator M22l(double[] a)
        {
            return new M22l(
                (long)a[0], (long)a[1], 
                (long)a[2], (long)a[3]);
        }

        public static explicit operator M22l(double[,] a)
        {
            return new M22l(
                (long)a[0, 0], (long)a[0, 1], 
                (long)a[1, 0], (long)a[1, 1]);
        }

        public static explicit operator double[](M22l m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, 
                (double)m.M10, (double)m.M11
            };
        }

        public static explicit operator double[,](M22l m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01 }, 
                { (double)m.M10, (double)m.M11 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M10;
            array[index + 3] = (double)M11;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<long, int> element_fun)
        {
            return new M22i(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<long, int, int, int> element_index0_index1_fun)
        {
            return new M22i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<long, long> element_fun)
        {
            return new M22l(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<long, int, int, long> element_index0_index1_fun)
        {
            return new M22l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<long, float> element_fun)
        {
            return new M22f(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<long, int, int, float> element_index0_index1_fun)
        {
            return new M22f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<long, double> element_fun)
        {
            return new M22d(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<long, int, int, double> element_index0_index1_fun)
        {
            return new M22d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        public long[] ToArray()
        {
            var array = new long[4];
            array[0] = M00;
            array[1] = M01;
            array[2] = M10;
            array[3] = M11;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l FromCols(V2l col0, V2l col1)
        {
            return new M22l(
                col0.X, col1.X, 
                col0.Y, col1.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l FromRows(V2l row0, V2l row1)
        {
            return new M22l(
                row0.X, row0.Y, 
                row1.X, row1.Y);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M22l"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l Scale(long tX, long tY)
        {
            return new M22l(
                tX, 0, 
                0, tY);
        }

        /// <summary>
        /// Creates a transformation <see cref="M22l"/> using a <see cref="V2l"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l Scale(V2l s)
        {
            return new M22l(
                s.X, 0, 
                0, s.Y);
        }

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<long> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M10;
                yield return M11;
            }
        }

        public IEnumerable<V2l> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2l> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
            }
        }

        public V2l R0
        {
            get { return new V2l( M00,  M01); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
            }
        }

        public V2l R1
        {
            get { return new V2l( M10,  M11); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
            }
        }

        public V2l C0
        {
            get { return new V2l( M00,  M10); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        public V2l C1
        {
            get { return new V2l( M01,  M11); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public long this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M10;
                    case 3: return M11;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M10 = value; return;
                    case 3: M11 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public long this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 2;
        public const int ElementCount = 2 * 2;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(2, 2);
        }

        public static M22l Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M22l(0);
        }

        public static M22l Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M22l(1, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public long Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + 
                    Fun.Abs(M10) + Fun.Abs(M11);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + 
                    M10 * M10 + M11 * M11);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public long NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public long NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M22l operator -(M22l m)
        {
            return new M22l(
                -m.M00, -m.M01, 
                -m.M10, -m.M11);
        }

        public static M22l operator  + (M22l a, M22l b)
        {
            return new M22l(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22l operator  + (M22l m, long s)
        {
            return new M22l(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        public static M22l operator  + (long s, M22l m)
        {
            return new M22l(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22f operator  + (M22l a, M22f b)
        {
            return new M22f(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22f operator  + (M22l m, float s)
        {
            return new M22f(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        public static M22f operator  + (float s, M22l m)
        {
            return new M22f(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22d operator  + (M22l a, M22d b)
        {
            return new M22d(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22d operator  + (M22l m, double s)
        {
            return new M22d(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        public static M22d operator  + (double s, M22l m)
        {
            return new M22d(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22l operator  - (M22l a, M22l b)
        {
            return new M22l(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22l operator  - (M22l m, long s)
        {
            return new M22l(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        public static M22l operator  - (long s, M22l m)
        {
            return new M22l(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22f operator  - (M22l a, M22f b)
        {
            return new M22f(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22f operator  - (M22l m, float s)
        {
            return new M22f(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        public static M22f operator  - (float s, M22l m)
        {
            return new M22f(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22d operator  - (M22l a, M22d b)
        {
            return new M22d(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22d operator  - (M22l m, double s)
        {
            return new M22d(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        public static M22d operator  - (double s, M22l m)
        {
            return new M22d(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22l operator  % (M22l a, M22l b)
        {
            return new M22l(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22l operator  % (M22l m, long s)
        {
            return new M22l(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        public static M22l operator  % (long s, M22l m)
        {
            return new M22l(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22f operator  % (M22l a, M22f b)
        {
            return new M22f(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22f operator  % (M22l m, float s)
        {
            return new M22f(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        public static M22f operator  % (float s, M22l m)
        {
            return new M22f(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22d operator  % (M22l a, M22d b)
        {
            return new M22d(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22d operator  % (M22l m, double s)
        {
            return new M22d(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        public static M22d operator  % (double s, M22l m)
        {
            return new M22d(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22l operator  / (M22l a, M22l b)
        {
            return new M22l(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22l operator  / (M22l m, long s)
        {
            return new M22l(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        public static M22l operator  / (long s, M22l m)
        {
            return new M22l(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22f operator  / (M22l a, M22f b)
        {
            return new M22f(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22f operator  / (M22l m, float s)
        {
            return new M22f(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        public static M22f operator  / (float s, M22l m)
        {
            return new M22f(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22d operator  / (M22l a, M22d b)
        {
            return new M22d(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22d operator  / (M22l m, double s)
        {
            return new M22d(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        public static M22d operator  / (double s, M22l m)
        {
            return new M22d(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22l operator  * (M22l m, long s)
        {
            return new M22l(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        public static M22l operator  * (long s, M22l m)
        {
            return new M22l(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22f operator  * (M22l m, float s)
        {
            return new M22f(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        public static M22f operator  * (float s, M22l m)
        {
            return new M22f(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22d operator  * (M22l m, double s)
        {
            return new M22d(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        public static M22d operator  * (double s, M22l m)
        {
            return new M22d(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M22l matrix with a V2l column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2l operator *(M22l m, V2l v)
        {
            return new V2l(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y);
        }

        /// <summary>
        /// Multiplies a V2l row vector with a M22l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2l operator *(V2l v, M22l m)
        {
            return new V2l(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M22l a, M22l b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11;
        }

        public static bool operator <(M22l a, long s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M10 < s && 
                a.M11 < s;
        }

        public static bool operator <(long s, M22l a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M10  && 
                s < a.M11 ;
        }

        public static bool operator >(M22l a, M22l b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11;
        }

        public static bool operator >(M22l a, long s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M10 > s && 
                a.M11 > s;
        }

        public static bool operator >(long s, M22l a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M10  && 
                s > a.M11 ;
        }

        public static bool operator ==(M22l a, M22l b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11;
        }

        public static bool operator ==(M22l a, long s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M10 == s && 
                a.M11 == s;
        }

        public static bool operator ==(long s, M22l a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M10  && 
                s == a.M11 ;
        }

        public static bool operator <=(M22l a, M22l b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11;
        }

        public static bool operator <=(M22l a, long s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M10 <= s && 
                a.M11 <= s;
        }

        public static bool operator <=(long s, M22l a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M10  && 
                s <= a.M11 ;
        }

        public static bool operator >=(M22l a, M22l b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11;
        }

        public static bool operator >=(M22l a, long s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M10 >= s && 
                a.M11 >= s;
        }

        public static bool operator >=(long s, M22l a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M10  && 
                s >= a.M11 ;
        }

        public static bool operator !=(M22l a, M22l b)
        {
            return !(a == b);
        }

        public static bool operator !=(M22l m, long s)
        {
            return !(m == s);
        }

        public static bool operator !=(long s, M22l m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M22l) ? (this == (M22l)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M22l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M22l.FromRows(
                V2l.Parse(x[0]), 
                V2l.Parse(x[1])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M22l Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return new M22l(M11, -M10, -M01, M00);
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public long Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public long Determinant
        {
            get
            {
                return M00 * M11 - M10 * M01;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M22l Transposed
        {
            get
            {
                return new M22l {
                    
                    M00 = M00, 
                    M01 = M10, 
                    
                    M10 = M01, 
                    M11 = M11
                };
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M22l operator *(M22l a, M22l b)
        {
            return new M22l(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (long)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (long)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (long)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (long)value;
        }

        #endregion
    }

    public class M22lEqualityComparer : IEqualityComparer<M22l>
    {
        public static readonly M22lEqualityComparer Default
            = new M22lEqualityComparer();

        #region IEqualityComparer<M22l> Members

        public bool Equals(M22l v0, M22l v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M22l v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Norm1(M22l m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M22l m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMax(M22l m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMin(M22l m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M22l m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static long Distance1(this M22l a, M22l b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M22l a, M22l b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M22l a, M22l b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMax(this M22l a, M22l b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMin(this M22l a, M22l b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2l Transform(this M22l m, V2l v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l Transform(this M22l m, V3l v)
        {
            return new V3l(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y,
                v.Z);
        }

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l Transform(this M22l m, V4l v)
        {
            return new V4l(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y,
                v.Z, v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2l TransposedTransform(this M22l m, V2l v)
            => v * m;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l TransposedTransform(this M22l m, V3l v)
        {
            return new V3l(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11,
                v.Z);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l TransposedTransform(this M22l m, V4l v)
        {
            return new V4l(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11,
                v.Z, v.W);
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M22l"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static long Minor(this M22l m, int row, int column)
        {
            return m[1 - row, 1 - column];
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2l Row(this M22l m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2l Column(this M22l m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Determinant(M22l m)
            => m.Determinant;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        public static void Transpose(this ref M22l m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M22l a, M22l b, long epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M22f

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M22f : IValidity, IMatrix<double>
    {
        [DataMember]
        public float M00, M01;
        [DataMember]
        public float M10, M11;

        #region Constructors

        public M22f(float value)
        {
            M00 = value; M01 = value; 
            M10 = value; M11 = value; 
        }

        public M22f(
                float m00, float m01, 
                float m10, float m11)
        {
            M00 = m00; M01 = m01; 
            M10 = m10; M11 = m11; 
        }

        public M22f(float[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M10 = a[2];
            M11 = a[3];
        }

        public M22f(float[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M10 = a[start + 2];
            M11 = a[start + 3];
        }

        public M22f(M22i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        public M22f(M23i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        public M22f(M33i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        public M22f(M34i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        public M22f(M44i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        public M22f(M22l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        public M22f(M23l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        public M22f(M33l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        public M22f(M34l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        public M22f(M44l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        public M22f(M23f m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        public M22f(M33f m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        public M22f(M34f m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        public M22f(M44f m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        public M22f(M22d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        public M22f(M23d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        public M22f(M33d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        public M22f(M34d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        public M22f(M44d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        #endregion

        #region Conversions

        public static explicit operator M22f(M22i m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M23i m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M33i m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M34i m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M44i m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M22l m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M23l m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M33l m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M34l m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M44l m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M23f m)
        {
            return new M22f {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22f(M33f m)
        {
            return new M22f {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22f(M34f m)
        {
            return new M22f {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22f(M44f m)
        {
            return new M22f {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22f(M22d m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M23d m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M33d m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M34d m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M44d m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(int[] a)
        {
            return new M22f(
                (float)a[0], (float)a[1], 
                (float)a[2], (float)a[3]);
        }

        public static explicit operator M22f(int[,] a)
        {
            return new M22f(
                (float)a[0, 0], (float)a[0, 1], 
                (float)a[1, 0], (float)a[1, 1]);
        }

        public static explicit operator int[](M22f m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, 
                (int)m.M10, (int)m.M11
            };
        }

        public static explicit operator int[,](M22f m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01 }, 
                { (int)m.M10, (int)m.M11 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M10;
            array[index + 3] = (int)M11;
        }

        public static explicit operator M22f(long[] a)
        {
            return new M22f(
                (float)a[0], (float)a[1], 
                (float)a[2], (float)a[3]);
        }

        public static explicit operator M22f(long[,] a)
        {
            return new M22f(
                (float)a[0, 0], (float)a[0, 1], 
                (float)a[1, 0], (float)a[1, 1]);
        }

        public static explicit operator long[](M22f m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, 
                (long)m.M10, (long)m.M11
            };
        }

        public static explicit operator long[,](M22f m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01 }, 
                { (long)m.M10, (long)m.M11 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M10;
            array[index + 3] = (long)M11;
        }

        public static explicit operator M22f(float[] a)
        {
            return new M22f(
                a[0], a[1], 
                a[2], a[3]);
        }

        public static explicit operator M22f(float[,] a)
        {
            return new M22f(
                a[0, 0], a[0, 1], 
                a[1, 0], a[1, 1]);
        }

        public static explicit operator float[](M22f m)
        {
            return new float[] {
                m.M00, m.M01, 
                m.M10, m.M11
            };
        }

        public static explicit operator float[,](M22f m)
        {
            return new float[,] {
                { m.M00, m.M01 }, 
                { m.M10, m.M11 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M10;
            array[index + 3] = M11;
        }

        public static explicit operator M22f(double[] a)
        {
            return new M22f(
                (float)a[0], (float)a[1], 
                (float)a[2], (float)a[3]);
        }

        public static explicit operator M22f(double[,] a)
        {
            return new M22f(
                (float)a[0, 0], (float)a[0, 1], 
                (float)a[1, 0], (float)a[1, 1]);
        }

        public static explicit operator double[](M22f m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, 
                (double)m.M10, (double)m.M11
            };
        }

        public static explicit operator double[,](M22f m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01 }, 
                { (double)m.M10, (double)m.M11 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M10;
            array[index + 3] = (double)M11;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<float, int> element_fun)
        {
            return new M22i(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<float, int, int, int> element_index0_index1_fun)
        {
            return new M22i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<float, long> element_fun)
        {
            return new M22l(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<float, int, int, long> element_index0_index1_fun)
        {
            return new M22l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<float, float> element_fun)
        {
            return new M22f(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<float, int, int, float> element_index0_index1_fun)
        {
            return new M22f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<float, double> element_fun)
        {
            return new M22d(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<float, int, int, double> element_index0_index1_fun)
        {
            return new M22d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        public float[] ToArray()
        {
            var array = new float[4];
            array[0] = M00;
            array[1] = M01;
            array[2] = M10;
            array[3] = M11;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f FromCols(V2f col0, V2f col1)
        {
            return new M22f(
                col0.X, col1.X, 
                col0.Y, col1.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f FromRows(V2f row0, V2f row1)
        {
            return new M22f(
                row0.X, row0.Y, 
                row1.X, row1.Y);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M22f"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f Scale(float tX, float tY)
        {
            return new M22f(
                tX, 0, 
                0, tY);
        }

        /// <summary>
        /// Creates a transformation <see cref="M22f"/> using a <see cref="V2f"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f Scale(V2f s)
        {
            return new M22f(
                s.X, 0, 
                0, s.Y);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 2D rotation matrix with the specified angle in radians.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f Rotation(float angleInRadians)
        {
            var a = Fun.Cos(angleInRadians);
            var b = Fun.Sin(angleInRadians);

            return new M22f(
                 a, -b, 
                 b,  a);
        }

        /// <summary>
        /// Creates a 2D rotation matrix from a <see cref="Rot2f"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f Rotation(Rot2f r)
            => (M22f)r;

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<float> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M10;
                yield return M11;
            }
        }

        public IEnumerable<V2f> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2f> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
            }
        }

        public V2f R0
        {
            get { return new V2f( M00,  M01); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
            }
        }

        public V2f R1
        {
            get { return new V2f( M10,  M11); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
            }
        }

        public V2f C0
        {
            get { return new V2f( M00,  M10); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        public V2f C1
        {
            get { return new V2f( M01,  M11); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M10;
                    case 3: return M11;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M10 = value; return;
                    case 3: M11 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public float this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 2;
        public const int ElementCount = 2 * 2;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(2, 2);
        }

        public static M22f Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M22f(0);
        }

        public static M22f Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M22f(1, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public float Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + 
                    Fun.Abs(M10) + Fun.Abs(M11);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public float Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + 
                    M10 * M10 + M11 * M11);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public float NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public float NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M22f operator -(M22f m)
        {
            return new M22f(
                -m.M00, -m.M01, 
                -m.M10, -m.M11);
        }

        public static M22f operator  + (M22f a, M22f b)
        {
            return new M22f(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22f operator  + (M22f m, float s)
        {
            return new M22f(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        public static M22f operator  + (float s, M22f m)
        {
            return new M22f(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22d operator  + (M22f a, M22d b)
        {
            return new M22d(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22d operator  + (M22f m, double s)
        {
            return new M22d(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        public static M22d operator  + (double s, M22f m)
        {
            return new M22d(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22f operator  - (M22f a, M22f b)
        {
            return new M22f(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22f operator  - (M22f m, float s)
        {
            return new M22f(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        public static M22f operator  - (float s, M22f m)
        {
            return new M22f(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22d operator  - (M22f a, M22d b)
        {
            return new M22d(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22d operator  - (M22f m, double s)
        {
            return new M22d(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        public static M22d operator  - (double s, M22f m)
        {
            return new M22d(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22f operator  % (M22f a, M22f b)
        {
            return new M22f(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22f operator  % (M22f m, float s)
        {
            return new M22f(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        public static M22f operator  % (float s, M22f m)
        {
            return new M22f(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22d operator  % (M22f a, M22d b)
        {
            return new M22d(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22d operator  % (M22f m, double s)
        {
            return new M22d(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        public static M22d operator  % (double s, M22f m)
        {
            return new M22d(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22f operator  / (M22f a, M22f b)
        {
            return new M22f(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22f operator  / (M22f m, float s)
        {
            return new M22f(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        public static M22f operator  / (float s, M22f m)
        {
            return new M22f(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22d operator  / (M22f a, M22d b)
        {
            return new M22d(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22d operator  / (M22f m, double s)
        {
            return new M22d(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        public static M22d operator  / (double s, M22f m)
        {
            return new M22d(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22f operator  * (M22f m, float s)
        {
            return new M22f(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        public static M22f operator  * (float s, M22f m)
        {
            return new M22f(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22d operator  * (M22f m, double s)
        {
            return new M22d(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        public static M22d operator  * (double s, M22f m)
        {
            return new M22d(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M22f matrix with a V2f column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f operator *(M22f m, V2f v)
        {
            return new V2f(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y);
        }

        /// <summary>
        /// Multiplies a V2f row vector with a M22f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f operator *(V2f v, M22f m)
        {
            return new V2f(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M22f a, M22f b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11;
        }

        public static bool operator <(M22f a, float s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M10 < s && 
                a.M11 < s;
        }

        public static bool operator <(float s, M22f a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M10  && 
                s < a.M11 ;
        }

        public static bool operator >(M22f a, M22f b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11;
        }

        public static bool operator >(M22f a, float s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M10 > s && 
                a.M11 > s;
        }

        public static bool operator >(float s, M22f a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M10  && 
                s > a.M11 ;
        }

        public static bool operator ==(M22f a, M22f b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11;
        }

        public static bool operator ==(M22f a, float s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M10 == s && 
                a.M11 == s;
        }

        public static bool operator ==(float s, M22f a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M10  && 
                s == a.M11 ;
        }

        public static bool operator <=(M22f a, M22f b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11;
        }

        public static bool operator <=(M22f a, float s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M10 <= s && 
                a.M11 <= s;
        }

        public static bool operator <=(float s, M22f a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M10  && 
                s <= a.M11 ;
        }

        public static bool operator >=(M22f a, M22f b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11;
        }

        public static bool operator >=(M22f a, float s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M10 >= s && 
                a.M11 >= s;
        }

        public static bool operator >=(float s, M22f a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M10  && 
                s >= a.M11 ;
        }

        public static bool operator !=(M22f a, M22f b)
        {
            return !(a == b);
        }

        public static bool operator !=(M22f m, float s)
        {
            return !(m == s);
        }

        public static bool operator !=(float s, M22f m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M22f) ? (this == (M22f)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M22f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M22f.FromRows(
                V2f.Parse(x[0]), 
                V2f.Parse(x[1])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M22f Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return new M22f(M11, -M10, -M01, M00);
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public float Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public float Determinant
        {
            get
            {
                return M00 * M11 - M10 * M01;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M22f Transposed
        {
            get
            {
                return new M22f {
                    
                    M00 = M00, 
                    M01 = M10, 
                    
                    M10 = M01, 
                    M11 = M11
                };
            }
        }

        private static V2l s_luSize = new V2l(2, 2);
        private static V2l s_luDelta = new V2l(1, 2);

        /// <summary>
        /// Inverts the given matrix using lu factorization in place. Returns true
        /// if the matrix was invertible, otherwise the matrix remains unchanged.
        /// </summary>
        public bool LuInvert()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return false;
            this = (M22f)(lu.LuInverse(p).Data);
            return true;
        }

        /// <summary>
        /// Returns the inverse of the matrix using lu factorization.
        /// If the matrix is not invertible, M22f.Zero is returned.
        /// </summary>
        public M22f LuInverse()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return M22f.Zero;
            return (M22f)(lu.LuInverse(p).Data);
        }

        /// <summary>
        /// Returns the inverse of this matrix. If the matrix is not invertible
        /// M22f.Zero is returned.
        /// </summary>
        public M22f Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => LuInverse();
        }

        #endregion

        #region Matrix Multiplication

        public static M22f operator *(M22f a, M22f b)
        {
            return new M22f(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (float)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (float)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (float)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (float)value;
        }

        #endregion
    }

    public class M22fEqualityComparer : IEqualityComparer<M22f>
    {
        public static readonly M22fEqualityComparer Default
            = new M22fEqualityComparer();

        #region IEqualityComparer<M22f> Members

        public bool Equals(M22f v0, M22f v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M22f v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Rotation Angle

        /// <summary>
        /// Computes the (signed) angle in radians of a <see cref="M22f"/> rotation matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float RotationAngle(this M22f m)
            => Fun.Atan2(m.M10, m.M00);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm1(M22f m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm2(M22f m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMax(M22f m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMin(M22f m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm(this M22f m, float p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static float Distance1(this M22f a, M22f b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static float Distance2(this M22f a, M22f b)
        {
            return (float)Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static float Distance(this M22f a, M22f b, float p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMax(this M22f a, M22f b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMin(this M22f a, M22f b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f Transform(this M22f m, V2f v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Transform(this M22f m, V3f v)
        {
            return new V3f(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y,
                v.Z);
        }

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f Transform(this M22f m, V4f v)
        {
            return new V4f(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y,
                v.Z, v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f TransposedTransform(this M22f m, V2f v)
            => v * m;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f TransposedTransform(this M22f m, V3f v)
        {
            return new V3f(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11,
                v.Z);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f TransposedTransform(this M22f m, V4f v)
        {
            return new V4f(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11,
                v.Z, v.W);
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M22f"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static float Minor(this M22f m, int row, int column)
        {
            return m[1 - row, 1 - column];
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f Row(this M22f m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f Column(this M22f m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Determinant(M22f m)
            => m.Determinant;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        public static void Transpose(this ref M22f m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
        }

        /// <summary>
        /// Inverts the given matrix in place. Returns true if the matrix was invertible,
        /// otherwise the matrix remains unchanged.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Invert(this ref M22f m) { return m.LuInvert(); }

        /// <summary>
        /// Returns if the given matrix is the identity matrix I.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsIdentity(this M22f m, float epsilon)
        {
            return Fun.ApproximateEquals(m, M22f.Identity, epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthonormal(this M22f m, float epsilon)
        {
            var i = m * m.Transposed;
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthogonal(this M22f m, float epsilon)
        {
            var i = m * m.Transposed;
            for (int j = 0; j < 2; j++)
                i[j, j] = 1; //inefficient implementation: just leave out the comparisons at the diagonal entries.
            return i.IsIdentity(epsilon);
        }
        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M22f a, M22f b, float epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M22d

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M22d : IValidity, IMatrix<double>
    {
        [DataMember]
        public double M00, M01;
        [DataMember]
        public double M10, M11;

        #region Constructors

        public M22d(double value)
        {
            M00 = value; M01 = value; 
            M10 = value; M11 = value; 
        }

        public M22d(
                double m00, double m01, 
                double m10, double m11)
        {
            M00 = m00; M01 = m01; 
            M10 = m10; M11 = m11; 
        }

        public M22d(double[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M10 = a[2];
            M11 = a[3];
        }

        public M22d(double[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M10 = a[start + 2];
            M11 = a[start + 3];
        }

        public M22d(M22i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        public M22d(M23i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        public M22d(M33i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        public M22d(M34i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        public M22d(M44i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        public M22d(M22l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        public M22d(M23l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        public M22d(M33l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        public M22d(M34l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        public M22d(M44l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        public M22d(M22f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        public M22d(M23f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        public M22d(M33f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        public M22d(M34f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        public M22d(M44f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        public M22d(M23d m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        public M22d(M33d m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        public M22d(M34d m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        public M22d(M44d m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        #endregion

        #region Conversions

        public static explicit operator M22d(M22i m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M23i m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M33i m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M34i m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M44i m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M22l m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M23l m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M33l m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M34l m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M44l m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M22f m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M23f m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M33f m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M34f m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M44f m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M23d m)
        {
            return new M22d {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22d(M33d m)
        {
            return new M22d {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22d(M34d m)
        {
            return new M22d {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22d(M44d m)
        {
            return new M22d {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22d(int[] a)
        {
            return new M22d(
                (double)a[0], (double)a[1], 
                (double)a[2], (double)a[3]);
        }

        public static explicit operator M22d(int[,] a)
        {
            return new M22d(
                (double)a[0, 0], (double)a[0, 1], 
                (double)a[1, 0], (double)a[1, 1]);
        }

        public static explicit operator int[](M22d m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, 
                (int)m.M10, (int)m.M11
            };
        }

        public static explicit operator int[,](M22d m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01 }, 
                { (int)m.M10, (int)m.M11 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M10;
            array[index + 3] = (int)M11;
        }

        public static explicit operator M22d(long[] a)
        {
            return new M22d(
                (double)a[0], (double)a[1], 
                (double)a[2], (double)a[3]);
        }

        public static explicit operator M22d(long[,] a)
        {
            return new M22d(
                (double)a[0, 0], (double)a[0, 1], 
                (double)a[1, 0], (double)a[1, 1]);
        }

        public static explicit operator long[](M22d m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, 
                (long)m.M10, (long)m.M11
            };
        }

        public static explicit operator long[,](M22d m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01 }, 
                { (long)m.M10, (long)m.M11 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M10;
            array[index + 3] = (long)M11;
        }

        public static explicit operator M22d(float[] a)
        {
            return new M22d(
                (double)a[0], (double)a[1], 
                (double)a[2], (double)a[3]);
        }

        public static explicit operator M22d(float[,] a)
        {
            return new M22d(
                (double)a[0, 0], (double)a[0, 1], 
                (double)a[1, 0], (double)a[1, 1]);
        }

        public static explicit operator float[](M22d m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, 
                (float)m.M10, (float)m.M11
            };
        }

        public static explicit operator float[,](M22d m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01 }, 
                { (float)m.M10, (float)m.M11 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M10;
            array[index + 3] = (float)M11;
        }

        public static explicit operator M22d(double[] a)
        {
            return new M22d(
                a[0], a[1], 
                a[2], a[3]);
        }

        public static explicit operator M22d(double[,] a)
        {
            return new M22d(
                a[0, 0], a[0, 1], 
                a[1, 0], a[1, 1]);
        }

        public static explicit operator double[](M22d m)
        {
            return new double[] {
                m.M00, m.M01, 
                m.M10, m.M11
            };
        }

        public static explicit operator double[,](M22d m)
        {
            return new double[,] {
                { m.M00, m.M01 }, 
                { m.M10, m.M11 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M10;
            array[index + 3] = M11;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<double, int> element_fun)
        {
            return new M22i(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<double, int, int, int> element_index0_index1_fun)
        {
            return new M22i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<double, long> element_fun)
        {
            return new M22l(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<double, int, int, long> element_index0_index1_fun)
        {
            return new M22l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<double, float> element_fun)
        {
            return new M22f(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<double, int, int, float> element_index0_index1_fun)
        {
            return new M22f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<double, double> element_fun)
        {
            return new M22d(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<double, int, int, double> element_index0_index1_fun)
        {
            return new M22d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        public double[] ToArray()
        {
            var array = new double[4];
            array[0] = M00;
            array[1] = M01;
            array[2] = M10;
            array[3] = M11;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d FromCols(V2d col0, V2d col1)
        {
            return new M22d(
                col0.X, col1.X, 
                col0.Y, col1.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d FromRows(V2d row0, V2d row1)
        {
            return new M22d(
                row0.X, row0.Y, 
                row1.X, row1.Y);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M22d"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d Scale(double tX, double tY)
        {
            return new M22d(
                tX, 0, 
                0, tY);
        }

        /// <summary>
        /// Creates a transformation <see cref="M22d"/> using a <see cref="V2d"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d Scale(V2d s)
        {
            return new M22d(
                s.X, 0, 
                0, s.Y);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 2D rotation matrix with the specified angle in radians.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d Rotation(double angleInRadians)
        {
            var a = Fun.Cos(angleInRadians);
            var b = Fun.Sin(angleInRadians);

            return new M22d(
                 a, -b, 
                 b,  a);
        }

        /// <summary>
        /// Creates a 2D rotation matrix from a <see cref="Rot2d"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d Rotation(Rot2d r)
            => (M22d)r;

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<double> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M10;
                yield return M11;
            }
        }

        public IEnumerable<V2d> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2d> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
            }
        }

        public V2d R0
        {
            get { return new V2d( M00,  M01); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
            }
        }

        public V2d R1
        {
            get { return new V2d( M10,  M11); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
            }
        }

        public V2d C0
        {
            get { return new V2d( M00,  M10); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        public V2d C1
        {
            get { return new V2d( M01,  M11); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public double this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M10;
                    case 3: return M11;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M10 = value; return;
                    case 3: M11 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public double this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 2;
        public const int ElementCount = 2 * 2;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(2, 2);
        }

        public static M22d Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M22d(0);
        }

        public static M22d Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M22d(1, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public double Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + 
                    Fun.Abs(M10) + Fun.Abs(M11);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + 
                    M10 * M10 + M11 * M11);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public double NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public double NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M22d operator -(M22d m)
        {
            return new M22d(
                -m.M00, -m.M01, 
                -m.M10, -m.M11);
        }

        public static M22d operator  + (M22d a, M22d b)
        {
            return new M22d(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22d operator  + (M22d m, double s)
        {
            return new M22d(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        public static M22d operator  + (double s, M22d m)
        {
            return new M22d(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22d operator  - (M22d a, M22d b)
        {
            return new M22d(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22d operator  - (M22d m, double s)
        {
            return new M22d(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        public static M22d operator  - (double s, M22d m)
        {
            return new M22d(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22d operator  % (M22d a, M22d b)
        {
            return new M22d(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22d operator  % (M22d m, double s)
        {
            return new M22d(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        public static M22d operator  % (double s, M22d m)
        {
            return new M22d(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22d operator  / (M22d a, M22d b)
        {
            return new M22d(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22d operator  / (M22d m, double s)
        {
            return new M22d(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        public static M22d operator  / (double s, M22d m)
        {
            return new M22d(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22d operator  * (M22d m, double s)
        {
            return new M22d(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        public static M22d operator  * (double s, M22d m)
        {
            return new M22d(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M22d matrix with a V2d column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d operator *(M22d m, V2d v)
        {
            return new V2d(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y);
        }

        /// <summary>
        /// Multiplies a V2d row vector with a M22d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d operator *(V2d v, M22d m)
        {
            return new V2d(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M22d a, M22d b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11;
        }

        public static bool operator <(M22d a, double s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M10 < s && 
                a.M11 < s;
        }

        public static bool operator <(double s, M22d a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M10  && 
                s < a.M11 ;
        }

        public static bool operator >(M22d a, M22d b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11;
        }

        public static bool operator >(M22d a, double s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M10 > s && 
                a.M11 > s;
        }

        public static bool operator >(double s, M22d a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M10  && 
                s > a.M11 ;
        }

        public static bool operator ==(M22d a, M22d b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11;
        }

        public static bool operator ==(M22d a, double s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M10 == s && 
                a.M11 == s;
        }

        public static bool operator ==(double s, M22d a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M10  && 
                s == a.M11 ;
        }

        public static bool operator <=(M22d a, M22d b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11;
        }

        public static bool operator <=(M22d a, double s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M10 <= s && 
                a.M11 <= s;
        }

        public static bool operator <=(double s, M22d a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M10  && 
                s <= a.M11 ;
        }

        public static bool operator >=(M22d a, M22d b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11;
        }

        public static bool operator >=(M22d a, double s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M10 >= s && 
                a.M11 >= s;
        }

        public static bool operator >=(double s, M22d a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M10  && 
                s >= a.M11 ;
        }

        public static bool operator !=(M22d a, M22d b)
        {
            return !(a == b);
        }

        public static bool operator !=(M22d m, double s)
        {
            return !(m == s);
        }

        public static bool operator !=(double s, M22d m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M22d) ? (this == (M22d)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M22d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M22d.FromRows(
                V2d.Parse(x[0]), 
                V2d.Parse(x[1])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M22d Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return new M22d(M11, -M10, -M01, M00);
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public double Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public double Determinant
        {
            get
            {
                return M00 * M11 - M10 * M01;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M22d Transposed
        {
            get
            {
                return new M22d {
                    
                    M00 = M00, 
                    M01 = M10, 
                    
                    M10 = M01, 
                    M11 = M11
                };
            }
        }

        private static V2l s_luSize = new V2l(2, 2);
        private static V2l s_luDelta = new V2l(1, 2);

        /// <summary>
        /// Inverts the given matrix using lu factorization in place. Returns true
        /// if the matrix was invertible, otherwise the matrix remains unchanged.
        /// </summary>
        public bool LuInvert()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return false;
            this = (M22d)(lu.LuInverse(p).Data);
            return true;
        }

        /// <summary>
        /// Returns the inverse of the matrix using lu factorization.
        /// If the matrix is not invertible, M22d.Zero is returned.
        /// </summary>
        public M22d LuInverse()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return M22d.Zero;
            return (M22d)(lu.LuInverse(p).Data);
        }

        /// <summary>
        /// Returns the inverse of this matrix. If the matrix is not invertible
        /// M22d.Zero is returned.
        /// </summary>
        public M22d Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => LuInverse();
        }

        #endregion

        #region Matrix Multiplication

        public static M22d operator *(M22d a, M22d b)
        {
            return new M22d(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (double)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (double)value;
        }

        #endregion
    }

    public class M22dEqualityComparer : IEqualityComparer<M22d>
    {
        public static readonly M22dEqualityComparer Default
            = new M22dEqualityComparer();

        #region IEqualityComparer<M22d> Members

        public bool Equals(M22d v0, M22d v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M22d v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Rotation Angle

        /// <summary>
        /// Computes the (signed) angle in radians of a <see cref="M22d"/> rotation matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double RotationAngle(this M22d m)
            => Fun.Atan2(m.M10, m.M00);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm1(M22d m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M22d m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMax(M22d m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMin(M22d m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M22d m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static double Distance1(this M22d a, M22d b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M22d a, M22d b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M22d a, M22d b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMax(this M22d a, M22d b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMin(this M22d a, M22d b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d Transform(this M22d m, V2d v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Transform(this M22d m, V3d v)
        {
            return new V3d(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y,
                v.Z);
        }

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d Transform(this M22d m, V4d v)
        {
            return new V4d(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y,
                v.Z, v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d TransposedTransform(this M22d m, V2d v)
            => v * m;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d TransposedTransform(this M22d m, V3d v)
        {
            return new V3d(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11,
                v.Z);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d TransposedTransform(this M22d m, V4d v)
        {
            return new V4d(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11,
                v.Z, v.W);
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M22d"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static double Minor(this M22d m, int row, int column)
        {
            return m[1 - row, 1 - column];
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d Row(this M22d m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d Column(this M22d m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Determinant(M22d m)
            => m.Determinant;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        public static void Transpose(this ref M22d m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
        }

        /// <summary>
        /// Inverts the given matrix in place. Returns true if the matrix was invertible,
        /// otherwise the matrix remains unchanged.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Invert(this ref M22d m) { return m.LuInvert(); }

        /// <summary>
        /// Returns if the given matrix is the identity matrix I.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsIdentity(this M22d m, double epsilon)
        {
            return Fun.ApproximateEquals(m, M22d.Identity, epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthonormal(this M22d m, double epsilon)
        {
            var i = m * m.Transposed;
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthogonal(this M22d m, double epsilon)
        {
            var i = m * m.Transposed;
            for (int j = 0; j < 2; j++)
                i[j, j] = 1; //inefficient implementation: just leave out the comparisons at the diagonal entries.
            return i.IsIdentity(epsilon);
        }
        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M22d a, M22d b, double epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M23i

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M23i : IValidity, IMatrix<double>
    {
        [DataMember]
        public int M00, M01, M02;
        [DataMember]
        public int M10, M11, M12;

        #region Constructors

        public M23i(int value)
        {
            M00 = value; M01 = value; M02 = value; 
            M10 = value; M11 = value; M12 = value; 
        }

        public M23i(
                int m00, int m01, int m02, 
                int m10, int m11, int m12)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
        }

        public M23i(int[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
        }

        public M23i(int[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
        }

        public M23i(M22i m, V2i v)
        {
            M00 = m.M00; M01 = m.M01; M02 = v.X; 
            M10 = m.M10; M11 = m.M11; M12 = v.Y; 
        }

        public M23i(M22i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; 
        }

        public M23i(M33i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        public M23i(M34i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        public M23i(M44i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        public M23i(M22l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; 
        }

        public M23i(M23l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        public M23i(M33l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        public M23i(M34l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        public M23i(M44l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        public M23i(M22f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; 
        }

        public M23i(M23f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        public M23i(M33f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        public M23i(M34f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        public M23i(M44f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        public M23i(M22d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; 
        }

        public M23i(M23d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        public M23i(M33d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        public M23i(M34d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        public M23i(M44d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        #endregion

        #region Conversions

        public static explicit operator M23i(M22i m)
        {
            return new M23i {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23i(M33i m)
        {
            return new M23i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23i(M34i m)
        {
            return new M23i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23i(M44i m)
        {
            return new M23i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23i(M22l m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23i(M23l m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M33l m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M34l m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M44l m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M22f m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23i(M23f m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M33f m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M34f m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M44f m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M22d m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23i(M23d m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M33d m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M34d m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M44d m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(int[] a)
        {
            return new M23i(
                a[0], a[1], a[2], 
                a[3], a[4], a[5]);
        }

        public static explicit operator M23i(int[,] a)
        {
            return new M23i(
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2]);
        }

        public static explicit operator int[](M23i m)
        {
            return new int[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12
            };
        }

        public static explicit operator int[,](M23i m)
        {
            return new int[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
        }

        public static explicit operator M23i(long[] a)
        {
            return new M23i(
                (int)a[0], (int)a[1], (int)a[2], 
                (int)a[3], (int)a[4], (int)a[5]);
        }

        public static explicit operator M23i(long[,] a)
        {
            return new M23i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2]);
        }

        public static explicit operator long[](M23i m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, 
                (long)m.M10, (long)m.M11, (long)m.M12
            };
        }

        public static explicit operator long[,](M23i m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M10;
            array[index + 4] = (long)M11;
            array[index + 5] = (long)M12;
        }

        public static explicit operator M23i(float[] a)
        {
            return new M23i(
                (int)a[0], (int)a[1], (int)a[2], 
                (int)a[3], (int)a[4], (int)a[5]);
        }

        public static explicit operator M23i(float[,] a)
        {
            return new M23i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2]);
        }

        public static explicit operator float[](M23i m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, 
                (float)m.M10, (float)m.M11, (float)m.M12
            };
        }

        public static explicit operator float[,](M23i m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M10;
            array[index + 4] = (float)M11;
            array[index + 5] = (float)M12;
        }

        public static explicit operator M23i(double[] a)
        {
            return new M23i(
                (int)a[0], (int)a[1], (int)a[2], 
                (int)a[3], (int)a[4], (int)a[5]);
        }

        public static explicit operator M23i(double[,] a)
        {
            return new M23i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2]);
        }

        public static explicit operator double[](M23i m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, 
                (double)m.M10, (double)m.M11, (double)m.M12
            };
        }

        public static explicit operator double[,](M23i m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M10;
            array[index + 4] = (double)M11;
            array[index + 5] = (double)M12;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<int, int> element_fun)
        {
            return new M23i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<int, int, int, int> element_index0_index1_fun)
        {
            return new M23i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<int, long> element_fun)
        {
            return new M23l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<int, int, int, long> element_index0_index1_fun)
        {
            return new M23l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<int, float> element_fun)
        {
            return new M23f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<int, int, int, float> element_index0_index1_fun)
        {
            return new M23f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<int, double> element_fun)
        {
            return new M23d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<int, int, int, double> element_index0_index1_fun)
        {
            return new M23d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        public int[] ToArray()
        {
            var array = new int[6];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i FromCols(V2i col0, V2i col1, V2i col2)
        {
            return new M23i(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i FromRows(V3i row0, V3i row1)
        {
            return new M23i(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M23i"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i Scale(int tX, int tY)
        {
            return new M23i(
                tX, 0, 0, 
                0, tY, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M23i"/> using a <see cref="V3i"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i Scale(V3i s)
        {
            return new M23i(
                s.X, 0, 0, 
                0, s.Y, 0);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M23i"/> with the translational component given by 2 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i Translation(int tX, int tY)
        {
            return new M23i(
                1, 0, tX, 
                0, 1, tY);
        }

        /// <summary>
        /// Creates a transformation <see cref="M23i"/> with the translational component given by a <see cref="V2i"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i Translation(V2i t)
        {
            return new M23i(
                1, 0, t.X, 
                0, 1, t.Y);
        }

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<int> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M10;
                yield return M11;
                yield return M12;
            }
        }

        public IEnumerable<V3i> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2i> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        public V3i R0
        {
            get { return new V3i( M00,  M01,  M02); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        public V3i R1
        {
            get { return new V3i( M10,  M11,  M12); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        public V2i C0
        {
            get { return new V2i( M00,  M10); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        public V2i C1
        {
            get { return new V2i( M01,  M11); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public V2i C2
        {
            get { return new V2i( M02,  M12); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
            }
        }

        public int this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M10;
                    case 4: return M11;
                    case 5: return M12;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M10 = value; return;
                    case 4: M11 = value; return;
                    case 5: M12 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public int this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            case 2: return M02;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            case 2: return M12;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            case 2: M02 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            case 2: M12 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 3;
        public const int ElementCount = 2 * 3;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(2, 3);
        }

        public static M23i Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M23i(0);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public int Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public int NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public int NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M23i operator -(M23i m)
        {
            return new M23i(
                -m.M00, -m.M01, -m.M02, 
                -m.M10, -m.M11, -m.M12);
        }

        public static M23i operator  + (M23i a, M23i b)
        {
            return new M23i(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23i operator  + (M23i m, int s)
        {
            return new M23i(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        public static M23i operator  + (int s, M23i m)
        {
            return new M23i(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23l operator  + (M23i a, M23l b)
        {
            return new M23l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23l operator  + (M23i m, long s)
        {
            return new M23l(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        public static M23l operator  + (long s, M23i m)
        {
            return new M23l(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23f operator  + (M23i a, M23f b)
        {
            return new M23f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23f operator  + (M23i m, float s)
        {
            return new M23f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        public static M23f operator  + (float s, M23i m)
        {
            return new M23f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23d operator  + (M23i a, M23d b)
        {
            return new M23d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23d operator  + (M23i m, double s)
        {
            return new M23d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        public static M23d operator  + (double s, M23i m)
        {
            return new M23d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23i operator  - (M23i a, M23i b)
        {
            return new M23i(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23i operator  - (M23i m, int s)
        {
            return new M23i(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        public static M23i operator  - (int s, M23i m)
        {
            return new M23i(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23l operator  - (M23i a, M23l b)
        {
            return new M23l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23l operator  - (M23i m, long s)
        {
            return new M23l(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        public static M23l operator  - (long s, M23i m)
        {
            return new M23l(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23f operator  - (M23i a, M23f b)
        {
            return new M23f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23f operator  - (M23i m, float s)
        {
            return new M23f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        public static M23f operator  - (float s, M23i m)
        {
            return new M23f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23d operator  - (M23i a, M23d b)
        {
            return new M23d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23d operator  - (M23i m, double s)
        {
            return new M23d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        public static M23d operator  - (double s, M23i m)
        {
            return new M23d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23i operator  % (M23i a, M23i b)
        {
            return new M23i(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23i operator  % (M23i m, int s)
        {
            return new M23i(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        public static M23i operator  % (int s, M23i m)
        {
            return new M23i(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23l operator  % (M23i a, M23l b)
        {
            return new M23l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23l operator  % (M23i m, long s)
        {
            return new M23l(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        public static M23l operator  % (long s, M23i m)
        {
            return new M23l(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23f operator  % (M23i a, M23f b)
        {
            return new M23f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23f operator  % (M23i m, float s)
        {
            return new M23f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        public static M23f operator  % (float s, M23i m)
        {
            return new M23f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23d operator  % (M23i a, M23d b)
        {
            return new M23d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23d operator  % (M23i m, double s)
        {
            return new M23d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        public static M23d operator  % (double s, M23i m)
        {
            return new M23d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23i operator  / (M23i a, M23i b)
        {
            return new M23i(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23i operator  / (M23i m, int s)
        {
            return new M23i(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        public static M23i operator  / (int s, M23i m)
        {
            return new M23i(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23l operator  / (M23i a, M23l b)
        {
            return new M23l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23l operator  / (M23i m, long s)
        {
            return new M23l(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        public static M23l operator  / (long s, M23i m)
        {
            return new M23l(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23f operator  / (M23i a, M23f b)
        {
            return new M23f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23f operator  / (M23i m, float s)
        {
            return new M23f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        public static M23f operator  / (float s, M23i m)
        {
            return new M23f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23d operator  / (M23i a, M23d b)
        {
            return new M23d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23d operator  / (M23i m, double s)
        {
            return new M23d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        public static M23d operator  / (double s, M23i m)
        {
            return new M23d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23i operator  * (M23i m, int s)
        {
            return new M23i(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        public static M23i operator  * (int s, M23i m)
        {
            return new M23i(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23l operator  * (M23i m, long s)
        {
            return new M23l(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        public static M23l operator  * (long s, M23i m)
        {
            return new M23l(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23f operator  * (M23i m, float s)
        {
            return new M23f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        public static M23f operator  * (float s, M23i m)
        {
            return new M23f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23d operator  * (M23i m, double s)
        {
            return new M23d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        public static M23d operator  * (double s, M23i m)
        {
            return new M23d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M23i matrix with a V3i column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2i operator *(M23i m, V3i v)
        {
            return new V2i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z);
        }

        /// <summary>
        /// Multiplies a V2i row vector with a M23i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i operator *(V2i v, M23i m)
        {
            return new V3i(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11, 
                v.X * m.M02 + v.Y * m.M12);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M23i a, M23i b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12;
        }

        public static bool operator <(M23i a, int s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s;
        }

        public static bool operator <(int s, M23i a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12 ;
        }

        public static bool operator >(M23i a, M23i b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12;
        }

        public static bool operator >(M23i a, int s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s;
        }

        public static bool operator >(int s, M23i a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12 ;
        }

        public static bool operator ==(M23i a, M23i b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12;
        }

        public static bool operator ==(M23i a, int s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s;
        }

        public static bool operator ==(int s, M23i a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12 ;
        }

        public static bool operator <=(M23i a, M23i b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12;
        }

        public static bool operator <=(M23i a, int s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s;
        }

        public static bool operator <=(int s, M23i a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12 ;
        }

        public static bool operator >=(M23i a, M23i b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12;
        }

        public static bool operator >=(M23i a, int s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s;
        }

        public static bool operator >=(int s, M23i a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12 ;
        }

        public static bool operator !=(M23i a, M23i b)
        {
            return !(a == b);
        }

        public static bool operator !=(M23i m, int s)
        {
            return !(m == s);
        }

        public static bool operator !=(int s, M23i m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M23i) ? (this == (M23i)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M23i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M23i.FromRows(
                V3i.Parse(x[0]), 
                V3i.Parse(x[1])
            );
        }

        #endregion

        #region Matrix Operations

        #endregion

        #region Matrix Multiplication

        public static M23i operator *(M22i a, M23i b)
        {
            return new M23i(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12
             );
        }

        public static M23i operator *(M23i a, M33i b)
        {
            return new M23i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (int)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (int)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (int)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (int)value;
        }

        #endregion
    }

    public class M23iEqualityComparer : IEqualityComparer<M23i>
    {
        public static readonly M23iEqualityComparer Default
            = new M23iEqualityComparer();

        #region IEqualityComparer<M23i> Members

        public bool Equals(M23i v0, M23i v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M23i v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Norm1(M23i m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M23i m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMax(M23i m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMin(M23i m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M23i m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static int Distance1(this M23i a, M23i b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M23i a, M23i b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M23i a, M23i b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMax(this M23i a, M23i b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMin(this M23i a, M23i b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2i Transform(this M23i m, V3i v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i Transform(this M23i m, V4i v)
        {
            return new V3i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z,
                v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i TransposedTransform(this M23i m, V2i v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by matrix m.
        /// </summary>
        public static V2i TransformDir(this M23i m, V2i v)
        {
            return new V2i(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by matrix m.
        /// </summary>
        public static V2i TransformPos(this M23i m, V2i p)
        {
            return new V2i(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i Row(this M23i m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2i Column(this M23i m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                case 2: return m.C2;
                default: throw new IndexOutOfRangeException();
            }
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M23i a, M23i b, int epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M23l

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M23l : IValidity, IMatrix<double>
    {
        [DataMember]
        public long M00, M01, M02;
        [DataMember]
        public long M10, M11, M12;

        #region Constructors

        public M23l(long value)
        {
            M00 = value; M01 = value; M02 = value; 
            M10 = value; M11 = value; M12 = value; 
        }

        public M23l(
                long m00, long m01, long m02, 
                long m10, long m11, long m12)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
        }

        public M23l(long[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
        }

        public M23l(long[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
        }

        public M23l(M22l m, V2l v)
        {
            M00 = m.M00; M01 = m.M01; M02 = v.X; 
            M10 = m.M10; M11 = m.M11; M12 = v.Y; 
        }

        public M23l(M22i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; 
        }

        public M23l(M23i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        public M23l(M33i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        public M23l(M34i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        public M23l(M44i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        public M23l(M22l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; 
        }

        public M23l(M33l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        public M23l(M34l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        public M23l(M44l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        public M23l(M22f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; 
        }

        public M23l(M23f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        public M23l(M33f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        public M23l(M34f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        public M23l(M44f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        public M23l(M22d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; 
        }

        public M23l(M23d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        public M23l(M33d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        public M23l(M34d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        public M23l(M44d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        #endregion

        #region Conversions

        public static explicit operator M23l(M22i m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23l(M23i m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M33i m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M34i m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M44i m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M22l m)
        {
            return new M23l {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23l(M33l m)
        {
            return new M23l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23l(M34l m)
        {
            return new M23l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23l(M44l m)
        {
            return new M23l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23l(M22f m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23l(M23f m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M33f m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M34f m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M44f m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M22d m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23l(M23d m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M33d m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M34d m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M44d m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(int[] a)
        {
            return new M23l(
                (long)a[0], (long)a[1], (long)a[2], 
                (long)a[3], (long)a[4], (long)a[5]);
        }

        public static explicit operator M23l(int[,] a)
        {
            return new M23l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2]);
        }

        public static explicit operator int[](M23l m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, 
                (int)m.M10, (int)m.M11, (int)m.M12
            };
        }

        public static explicit operator int[,](M23l m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M10;
            array[index + 4] = (int)M11;
            array[index + 5] = (int)M12;
        }

        public static explicit operator M23l(long[] a)
        {
            return new M23l(
                a[0], a[1], a[2], 
                a[3], a[4], a[5]);
        }

        public static explicit operator M23l(long[,] a)
        {
            return new M23l(
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2]);
        }

        public static explicit operator long[](M23l m)
        {
            return new long[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12
            };
        }

        public static explicit operator long[,](M23l m)
        {
            return new long[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
        }

        public static explicit operator M23l(float[] a)
        {
            return new M23l(
                (long)a[0], (long)a[1], (long)a[2], 
                (long)a[3], (long)a[4], (long)a[5]);
        }

        public static explicit operator M23l(float[,] a)
        {
            return new M23l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2]);
        }

        public static explicit operator float[](M23l m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, 
                (float)m.M10, (float)m.M11, (float)m.M12
            };
        }

        public static explicit operator float[,](M23l m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M10;
            array[index + 4] = (float)M11;
            array[index + 5] = (float)M12;
        }

        public static explicit operator M23l(double[] a)
        {
            return new M23l(
                (long)a[0], (long)a[1], (long)a[2], 
                (long)a[3], (long)a[4], (long)a[5]);
        }

        public static explicit operator M23l(double[,] a)
        {
            return new M23l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2]);
        }

        public static explicit operator double[](M23l m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, 
                (double)m.M10, (double)m.M11, (double)m.M12
            };
        }

        public static explicit operator double[,](M23l m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M10;
            array[index + 4] = (double)M11;
            array[index + 5] = (double)M12;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<long, int> element_fun)
        {
            return new M23i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<long, int, int, int> element_index0_index1_fun)
        {
            return new M23i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<long, long> element_fun)
        {
            return new M23l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<long, int, int, long> element_index0_index1_fun)
        {
            return new M23l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<long, float> element_fun)
        {
            return new M23f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<long, int, int, float> element_index0_index1_fun)
        {
            return new M23f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<long, double> element_fun)
        {
            return new M23d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<long, int, int, double> element_index0_index1_fun)
        {
            return new M23d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        public long[] ToArray()
        {
            var array = new long[6];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l FromCols(V2l col0, V2l col1, V2l col2)
        {
            return new M23l(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l FromRows(V3l row0, V3l row1)
        {
            return new M23l(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M23l"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l Scale(long tX, long tY)
        {
            return new M23l(
                tX, 0, 0, 
                0, tY, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M23l"/> using a <see cref="V3l"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l Scale(V3l s)
        {
            return new M23l(
                s.X, 0, 0, 
                0, s.Y, 0);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M23l"/> with the translational component given by 2 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l Translation(long tX, long tY)
        {
            return new M23l(
                1, 0, tX, 
                0, 1, tY);
        }

        /// <summary>
        /// Creates a transformation <see cref="M23l"/> with the translational component given by a <see cref="V2l"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l Translation(V2l t)
        {
            return new M23l(
                1, 0, t.X, 
                0, 1, t.Y);
        }

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<long> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M10;
                yield return M11;
                yield return M12;
            }
        }

        public IEnumerable<V3l> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2l> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        public V3l R0
        {
            get { return new V3l( M00,  M01,  M02); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        public V3l R1
        {
            get { return new V3l( M10,  M11,  M12); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        public V2l C0
        {
            get { return new V2l( M00,  M10); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        public V2l C1
        {
            get { return new V2l( M01,  M11); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public V2l C2
        {
            get { return new V2l( M02,  M12); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
            }
        }

        public long this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M10;
                    case 4: return M11;
                    case 5: return M12;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M10 = value; return;
                    case 4: M11 = value; return;
                    case 5: M12 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public long this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            case 2: return M02;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            case 2: return M12;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            case 2: M02 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            case 2: M12 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 3;
        public const int ElementCount = 2 * 3;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(2, 3);
        }

        public static M23l Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M23l(0);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public long Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public long NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public long NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M23l operator -(M23l m)
        {
            return new M23l(
                -m.M00, -m.M01, -m.M02, 
                -m.M10, -m.M11, -m.M12);
        }

        public static M23l operator  + (M23l a, M23l b)
        {
            return new M23l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23l operator  + (M23l m, long s)
        {
            return new M23l(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        public static M23l operator  + (long s, M23l m)
        {
            return new M23l(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23f operator  + (M23l a, M23f b)
        {
            return new M23f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23f operator  + (M23l m, float s)
        {
            return new M23f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        public static M23f operator  + (float s, M23l m)
        {
            return new M23f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23d operator  + (M23l a, M23d b)
        {
            return new M23d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23d operator  + (M23l m, double s)
        {
            return new M23d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        public static M23d operator  + (double s, M23l m)
        {
            return new M23d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23l operator  - (M23l a, M23l b)
        {
            return new M23l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23l operator  - (M23l m, long s)
        {
            return new M23l(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        public static M23l operator  - (long s, M23l m)
        {
            return new M23l(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23f operator  - (M23l a, M23f b)
        {
            return new M23f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23f operator  - (M23l m, float s)
        {
            return new M23f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        public static M23f operator  - (float s, M23l m)
        {
            return new M23f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23d operator  - (M23l a, M23d b)
        {
            return new M23d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23d operator  - (M23l m, double s)
        {
            return new M23d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        public static M23d operator  - (double s, M23l m)
        {
            return new M23d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23l operator  % (M23l a, M23l b)
        {
            return new M23l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23l operator  % (M23l m, long s)
        {
            return new M23l(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        public static M23l operator  % (long s, M23l m)
        {
            return new M23l(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23f operator  % (M23l a, M23f b)
        {
            return new M23f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23f operator  % (M23l m, float s)
        {
            return new M23f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        public static M23f operator  % (float s, M23l m)
        {
            return new M23f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23d operator  % (M23l a, M23d b)
        {
            return new M23d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23d operator  % (M23l m, double s)
        {
            return new M23d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        public static M23d operator  % (double s, M23l m)
        {
            return new M23d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23l operator  / (M23l a, M23l b)
        {
            return new M23l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23l operator  / (M23l m, long s)
        {
            return new M23l(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        public static M23l operator  / (long s, M23l m)
        {
            return new M23l(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23f operator  / (M23l a, M23f b)
        {
            return new M23f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23f operator  / (M23l m, float s)
        {
            return new M23f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        public static M23f operator  / (float s, M23l m)
        {
            return new M23f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23d operator  / (M23l a, M23d b)
        {
            return new M23d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23d operator  / (M23l m, double s)
        {
            return new M23d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        public static M23d operator  / (double s, M23l m)
        {
            return new M23d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23l operator  * (M23l m, long s)
        {
            return new M23l(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        public static M23l operator  * (long s, M23l m)
        {
            return new M23l(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23f operator  * (M23l m, float s)
        {
            return new M23f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        public static M23f operator  * (float s, M23l m)
        {
            return new M23f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23d operator  * (M23l m, double s)
        {
            return new M23d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        public static M23d operator  * (double s, M23l m)
        {
            return new M23d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M23l matrix with a V3l column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2l operator *(M23l m, V3l v)
        {
            return new V2l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z);
        }

        /// <summary>
        /// Multiplies a V2l row vector with a M23l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l operator *(V2l v, M23l m)
        {
            return new V3l(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11, 
                v.X * m.M02 + v.Y * m.M12);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M23l a, M23l b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12;
        }

        public static bool operator <(M23l a, long s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s;
        }

        public static bool operator <(long s, M23l a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12 ;
        }

        public static bool operator >(M23l a, M23l b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12;
        }

        public static bool operator >(M23l a, long s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s;
        }

        public static bool operator >(long s, M23l a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12 ;
        }

        public static bool operator ==(M23l a, M23l b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12;
        }

        public static bool operator ==(M23l a, long s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s;
        }

        public static bool operator ==(long s, M23l a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12 ;
        }

        public static bool operator <=(M23l a, M23l b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12;
        }

        public static bool operator <=(M23l a, long s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s;
        }

        public static bool operator <=(long s, M23l a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12 ;
        }

        public static bool operator >=(M23l a, M23l b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12;
        }

        public static bool operator >=(M23l a, long s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s;
        }

        public static bool operator >=(long s, M23l a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12 ;
        }

        public static bool operator !=(M23l a, M23l b)
        {
            return !(a == b);
        }

        public static bool operator !=(M23l m, long s)
        {
            return !(m == s);
        }

        public static bool operator !=(long s, M23l m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M23l) ? (this == (M23l)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M23l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M23l.FromRows(
                V3l.Parse(x[0]), 
                V3l.Parse(x[1])
            );
        }

        #endregion

        #region Matrix Operations

        #endregion

        #region Matrix Multiplication

        public static M23l operator *(M22l a, M23l b)
        {
            return new M23l(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12
             );
        }

        public static M23l operator *(M23l a, M33l b)
        {
            return new M23l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (long)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (long)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (long)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (long)value;
        }

        #endregion
    }

    public class M23lEqualityComparer : IEqualityComparer<M23l>
    {
        public static readonly M23lEqualityComparer Default
            = new M23lEqualityComparer();

        #region IEqualityComparer<M23l> Members

        public bool Equals(M23l v0, M23l v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M23l v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Norm1(M23l m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M23l m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMax(M23l m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMin(M23l m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M23l m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static long Distance1(this M23l a, M23l b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M23l a, M23l b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M23l a, M23l b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMax(this M23l a, M23l b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMin(this M23l a, M23l b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2l Transform(this M23l m, V3l v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l Transform(this M23l m, V4l v)
        {
            return new V3l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z,
                v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l TransposedTransform(this M23l m, V2l v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by matrix m.
        /// </summary>
        public static V2l TransformDir(this M23l m, V2l v)
        {
            return new V2l(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by matrix m.
        /// </summary>
        public static V2l TransformPos(this M23l m, V2l p)
        {
            return new V2l(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l Row(this M23l m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2l Column(this M23l m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                case 2: return m.C2;
                default: throw new IndexOutOfRangeException();
            }
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M23l a, M23l b, long epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M23f

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M23f : IValidity, IMatrix<double>
    {
        [DataMember]
        public float M00, M01, M02;
        [DataMember]
        public float M10, M11, M12;

        #region Constructors

        public M23f(float value)
        {
            M00 = value; M01 = value; M02 = value; 
            M10 = value; M11 = value; M12 = value; 
        }

        public M23f(
                float m00, float m01, float m02, 
                float m10, float m11, float m12)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
        }

        public M23f(float[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
        }

        public M23f(float[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
        }

        public M23f(M22f m, V2f v)
        {
            M00 = m.M00; M01 = m.M01; M02 = v.X; 
            M10 = m.M10; M11 = m.M11; M12 = v.Y; 
        }

        public M23f(M22i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; 
        }

        public M23f(M23i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        public M23f(M33i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        public M23f(M34i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        public M23f(M44i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        public M23f(M22l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; 
        }

        public M23f(M23l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        public M23f(M33l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        public M23f(M34l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        public M23f(M44l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        public M23f(M22f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; 
        }

        public M23f(M33f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        public M23f(M34f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        public M23f(M44f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        public M23f(M22d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; 
        }

        public M23f(M23d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        public M23f(M33d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        public M23f(M34d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        public M23f(M44d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        #endregion

        #region Conversions

        public static explicit operator M23f(M22i m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23f(M23i m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M33i m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M34i m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M44i m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M22l m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23f(M23l m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M33l m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M34l m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M44l m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M22f m)
        {
            return new M23f {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23f(M33f m)
        {
            return new M23f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23f(M34f m)
        {
            return new M23f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23f(M44f m)
        {
            return new M23f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23f(M22d m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23f(M23d m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M33d m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M34d m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M44d m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(int[] a)
        {
            return new M23f(
                (float)a[0], (float)a[1], (float)a[2], 
                (float)a[3], (float)a[4], (float)a[5]);
        }

        public static explicit operator M23f(int[,] a)
        {
            return new M23f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2]);
        }

        public static explicit operator int[](M23f m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, 
                (int)m.M10, (int)m.M11, (int)m.M12
            };
        }

        public static explicit operator int[,](M23f m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M10;
            array[index + 4] = (int)M11;
            array[index + 5] = (int)M12;
        }

        public static explicit operator M23f(long[] a)
        {
            return new M23f(
                (float)a[0], (float)a[1], (float)a[2], 
                (float)a[3], (float)a[4], (float)a[5]);
        }

        public static explicit operator M23f(long[,] a)
        {
            return new M23f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2]);
        }

        public static explicit operator long[](M23f m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, 
                (long)m.M10, (long)m.M11, (long)m.M12
            };
        }

        public static explicit operator long[,](M23f m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M10;
            array[index + 4] = (long)M11;
            array[index + 5] = (long)M12;
        }

        public static explicit operator M23f(float[] a)
        {
            return new M23f(
                a[0], a[1], a[2], 
                a[3], a[4], a[5]);
        }

        public static explicit operator M23f(float[,] a)
        {
            return new M23f(
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2]);
        }

        public static explicit operator float[](M23f m)
        {
            return new float[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12
            };
        }

        public static explicit operator float[,](M23f m)
        {
            return new float[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
        }

        public static explicit operator M23f(double[] a)
        {
            return new M23f(
                (float)a[0], (float)a[1], (float)a[2], 
                (float)a[3], (float)a[4], (float)a[5]);
        }

        public static explicit operator M23f(double[,] a)
        {
            return new M23f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2]);
        }

        public static explicit operator double[](M23f m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, 
                (double)m.M10, (double)m.M11, (double)m.M12
            };
        }

        public static explicit operator double[,](M23f m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M10;
            array[index + 4] = (double)M11;
            array[index + 5] = (double)M12;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<float, int> element_fun)
        {
            return new M23i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<float, int, int, int> element_index0_index1_fun)
        {
            return new M23i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<float, long> element_fun)
        {
            return new M23l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<float, int, int, long> element_index0_index1_fun)
        {
            return new M23l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<float, float> element_fun)
        {
            return new M23f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<float, int, int, float> element_index0_index1_fun)
        {
            return new M23f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<float, double> element_fun)
        {
            return new M23d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<float, int, int, double> element_index0_index1_fun)
        {
            return new M23d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        public float[] ToArray()
        {
            var array = new float[6];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f FromCols(V2f col0, V2f col1, V2f col2)
        {
            return new M23f(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f FromRows(V3f row0, V3f row1)
        {
            return new M23f(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M23f"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f Scale(float tX, float tY)
        {
            return new M23f(
                tX, 0, 0, 
                0, tY, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M23f"/> using a <see cref="V3f"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f Scale(V3f s)
        {
            return new M23f(
                s.X, 0, 0, 
                0, s.Y, 0);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M23f"/> with the translational component given by 2 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f Translation(float tX, float tY)
        {
            return new M23f(
                1, 0, tX, 
                0, 1, tY);
        }

        /// <summary>
        /// Creates a transformation <see cref="M23f"/> with the translational component given by a <see cref="V2f"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f Translation(V2f t)
        {
            return new M23f(
                1, 0, t.X, 
                0, 1, t.Y);
        }

        /// <summary>
        /// Creates a transformation <see cref="M23f"/> from a <see cref="Shift2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f Translation(Shift2f s)
        {
            return new M23f(
                1, 0, s.X, 
                0, 1, s.Y);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 2D rotation matrix with the specified angle in radians.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f Rotation(float angleInRadians)
        {
            var a = Fun.Cos(angleInRadians);
            var b = Fun.Sin(angleInRadians);

            return new M23f(
                 a, -b,  0, 
                 b,  a,  0);
        }

        /// <summary>
        /// Creates a 2D rotation matrix from a <see cref="Rot2f"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f Rotation(Rot2f r)
            => (M23f)r;

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<float> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M10;
                yield return M11;
                yield return M12;
            }
        }

        public IEnumerable<V3f> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2f> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        public V3f R0
        {
            get { return new V3f( M00,  M01,  M02); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        public V3f R1
        {
            get { return new V3f( M10,  M11,  M12); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        public V2f C0
        {
            get { return new V2f( M00,  M10); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        public V2f C1
        {
            get { return new V2f( M01,  M11); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public V2f C2
        {
            get { return new V2f( M02,  M12); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
            }
        }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M10;
                    case 4: return M11;
                    case 5: return M12;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M10 = value; return;
                    case 4: M11 = value; return;
                    case 5: M12 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public float this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            case 2: return M02;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            case 2: return M12;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            case 2: M02 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            case 2: M12 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 3;
        public const int ElementCount = 2 * 3;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(2, 3);
        }

        public static M23f Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M23f(0);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public float Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public float Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public float NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public float NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M23f operator -(M23f m)
        {
            return new M23f(
                -m.M00, -m.M01, -m.M02, 
                -m.M10, -m.M11, -m.M12);
        }

        public static M23f operator  + (M23f a, M23f b)
        {
            return new M23f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23f operator  + (M23f m, float s)
        {
            return new M23f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        public static M23f operator  + (float s, M23f m)
        {
            return new M23f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23d operator  + (M23f a, M23d b)
        {
            return new M23d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23d operator  + (M23f m, double s)
        {
            return new M23d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        public static M23d operator  + (double s, M23f m)
        {
            return new M23d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23f operator  - (M23f a, M23f b)
        {
            return new M23f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23f operator  - (M23f m, float s)
        {
            return new M23f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        public static M23f operator  - (float s, M23f m)
        {
            return new M23f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23d operator  - (M23f a, M23d b)
        {
            return new M23d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23d operator  - (M23f m, double s)
        {
            return new M23d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        public static M23d operator  - (double s, M23f m)
        {
            return new M23d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23f operator  % (M23f a, M23f b)
        {
            return new M23f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23f operator  % (M23f m, float s)
        {
            return new M23f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        public static M23f operator  % (float s, M23f m)
        {
            return new M23f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23d operator  % (M23f a, M23d b)
        {
            return new M23d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23d operator  % (M23f m, double s)
        {
            return new M23d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        public static M23d operator  % (double s, M23f m)
        {
            return new M23d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23f operator  / (M23f a, M23f b)
        {
            return new M23f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23f operator  / (M23f m, float s)
        {
            return new M23f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        public static M23f operator  / (float s, M23f m)
        {
            return new M23f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23d operator  / (M23f a, M23d b)
        {
            return new M23d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23d operator  / (M23f m, double s)
        {
            return new M23d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        public static M23d operator  / (double s, M23f m)
        {
            return new M23d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23f operator  * (M23f m, float s)
        {
            return new M23f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        public static M23f operator  * (float s, M23f m)
        {
            return new M23f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23d operator  * (M23f m, double s)
        {
            return new M23d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        public static M23d operator  * (double s, M23f m)
        {
            return new M23d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M23f matrix with a V3f column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f operator *(M23f m, V3f v)
        {
            return new V2f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z);
        }

        /// <summary>
        /// Multiplies a V2f row vector with a M23f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f operator *(V2f v, M23f m)
        {
            return new V3f(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11, 
                v.X * m.M02 + v.Y * m.M12);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M23f a, M23f b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12;
        }

        public static bool operator <(M23f a, float s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s;
        }

        public static bool operator <(float s, M23f a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12 ;
        }

        public static bool operator >(M23f a, M23f b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12;
        }

        public static bool operator >(M23f a, float s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s;
        }

        public static bool operator >(float s, M23f a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12 ;
        }

        public static bool operator ==(M23f a, M23f b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12;
        }

        public static bool operator ==(M23f a, float s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s;
        }

        public static bool operator ==(float s, M23f a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12 ;
        }

        public static bool operator <=(M23f a, M23f b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12;
        }

        public static bool operator <=(M23f a, float s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s;
        }

        public static bool operator <=(float s, M23f a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12 ;
        }

        public static bool operator >=(M23f a, M23f b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12;
        }

        public static bool operator >=(M23f a, float s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s;
        }

        public static bool operator >=(float s, M23f a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12 ;
        }

        public static bool operator !=(M23f a, M23f b)
        {
            return !(a == b);
        }

        public static bool operator !=(M23f m, float s)
        {
            return !(m == s);
        }

        public static bool operator !=(float s, M23f m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M23f) ? (this == (M23f)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M23f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M23f.FromRows(
                V3f.Parse(x[0]), 
                V3f.Parse(x[1])
            );
        }

        #endregion

        #region Matrix Operations

        #endregion

        #region Matrix Multiplication

        public static M23f operator *(M22f a, M23f b)
        {
            return new M23f(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12
             );
        }

        public static M23f operator *(M23f a, M33f b)
        {
            return new M23f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (float)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (float)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (float)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (float)value;
        }

        #endregion
    }

    public class M23fEqualityComparer : IEqualityComparer<M23f>
    {
        public static readonly M23fEqualityComparer Default
            = new M23fEqualityComparer();

        #region IEqualityComparer<M23f> Members

        public bool Equals(M23f v0, M23f v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M23f v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm1(M23f m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm2(M23f m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMax(M23f m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMin(M23f m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm(this M23f m, float p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static float Distance1(this M23f a, M23f b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static float Distance2(this M23f a, M23f b)
        {
            return (float)Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static float Distance(this M23f a, M23f b, float p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMax(this M23f a, M23f b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMin(this M23f a, M23f b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f Transform(this M23f m, V3f v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Transform(this M23f m, V4f v)
        {
            return new V3f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z,
                v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f TransposedTransform(this M23f m, V2f v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by matrix m.
        /// </summary>
        public static V2f TransformDir(this M23f m, V2f v)
        {
            return new V2f(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by matrix m.
        /// </summary>
        public static V2f TransformPos(this M23f m, V2f p)
        {
            return new V2f(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Row(this M23f m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f Column(this M23f m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                case 2: return m.C2;
                default: throw new IndexOutOfRangeException();
            }
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M23f a, M23f b, float epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M23d

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M23d : IValidity, IMatrix<double>
    {
        [DataMember]
        public double M00, M01, M02;
        [DataMember]
        public double M10, M11, M12;

        #region Constructors

        public M23d(double value)
        {
            M00 = value; M01 = value; M02 = value; 
            M10 = value; M11 = value; M12 = value; 
        }

        public M23d(
                double m00, double m01, double m02, 
                double m10, double m11, double m12)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
        }

        public M23d(double[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
        }

        public M23d(double[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
        }

        public M23d(M22d m, V2d v)
        {
            M00 = m.M00; M01 = m.M01; M02 = v.X; 
            M10 = m.M10; M11 = m.M11; M12 = v.Y; 
        }

        public M23d(M22i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; 
        }

        public M23d(M23i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        public M23d(M33i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        public M23d(M34i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        public M23d(M44i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        public M23d(M22l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; 
        }

        public M23d(M23l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        public M23d(M33l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        public M23d(M34l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        public M23d(M44l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        public M23d(M22f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; 
        }

        public M23d(M23f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        public M23d(M33f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        public M23d(M34f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        public M23d(M44f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        public M23d(M22d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; 
        }

        public M23d(M33d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        public M23d(M34d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        public M23d(M44d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        #endregion

        #region Conversions

        public static explicit operator M23d(M22i m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23d(M23i m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M33i m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M34i m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M44i m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M22l m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23d(M23l m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M33l m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M34l m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M44l m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M22f m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23d(M23f m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M33f m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M34f m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M44f m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M22d m)
        {
            return new M23d {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23d(M33d m)
        {
            return new M23d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23d(M34d m)
        {
            return new M23d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23d(M44d m)
        {
            return new M23d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23d(int[] a)
        {
            return new M23d(
                (double)a[0], (double)a[1], (double)a[2], 
                (double)a[3], (double)a[4], (double)a[5]);
        }

        public static explicit operator M23d(int[,] a)
        {
            return new M23d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2]);
        }

        public static explicit operator int[](M23d m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, 
                (int)m.M10, (int)m.M11, (int)m.M12
            };
        }

        public static explicit operator int[,](M23d m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M10;
            array[index + 4] = (int)M11;
            array[index + 5] = (int)M12;
        }

        public static explicit operator M23d(long[] a)
        {
            return new M23d(
                (double)a[0], (double)a[1], (double)a[2], 
                (double)a[3], (double)a[4], (double)a[5]);
        }

        public static explicit operator M23d(long[,] a)
        {
            return new M23d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2]);
        }

        public static explicit operator long[](M23d m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, 
                (long)m.M10, (long)m.M11, (long)m.M12
            };
        }

        public static explicit operator long[,](M23d m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M10;
            array[index + 4] = (long)M11;
            array[index + 5] = (long)M12;
        }

        public static explicit operator M23d(float[] a)
        {
            return new M23d(
                (double)a[0], (double)a[1], (double)a[2], 
                (double)a[3], (double)a[4], (double)a[5]);
        }

        public static explicit operator M23d(float[,] a)
        {
            return new M23d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2]);
        }

        public static explicit operator float[](M23d m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, 
                (float)m.M10, (float)m.M11, (float)m.M12
            };
        }

        public static explicit operator float[,](M23d m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M10;
            array[index + 4] = (float)M11;
            array[index + 5] = (float)M12;
        }

        public static explicit operator M23d(double[] a)
        {
            return new M23d(
                a[0], a[1], a[2], 
                a[3], a[4], a[5]);
        }

        public static explicit operator M23d(double[,] a)
        {
            return new M23d(
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2]);
        }

        public static explicit operator double[](M23d m)
        {
            return new double[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12
            };
        }

        public static explicit operator double[,](M23d m)
        {
            return new double[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<double, int> element_fun)
        {
            return new M23i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<double, int, int, int> element_index0_index1_fun)
        {
            return new M23i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<double, long> element_fun)
        {
            return new M23l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<double, int, int, long> element_index0_index1_fun)
        {
            return new M23l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<double, float> element_fun)
        {
            return new M23f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<double, int, int, float> element_index0_index1_fun)
        {
            return new M23f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<double, double> element_fun)
        {
            return new M23d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<double, int, int, double> element_index0_index1_fun)
        {
            return new M23d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        public double[] ToArray()
        {
            var array = new double[6];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d FromCols(V2d col0, V2d col1, V2d col2)
        {
            return new M23d(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d FromRows(V3d row0, V3d row1)
        {
            return new M23d(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M23d"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d Scale(double tX, double tY)
        {
            return new M23d(
                tX, 0, 0, 
                0, tY, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M23d"/> using a <see cref="V3d"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d Scale(V3d s)
        {
            return new M23d(
                s.X, 0, 0, 
                0, s.Y, 0);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M23d"/> with the translational component given by 2 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d Translation(double tX, double tY)
        {
            return new M23d(
                1, 0, tX, 
                0, 1, tY);
        }

        /// <summary>
        /// Creates a transformation <see cref="M23d"/> with the translational component given by a <see cref="V2d"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d Translation(V2d t)
        {
            return new M23d(
                1, 0, t.X, 
                0, 1, t.Y);
        }

        /// <summary>
        /// Creates a transformation <see cref="M23d"/> from a <see cref="Shift2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d Translation(Shift2d s)
        {
            return new M23d(
                1, 0, s.X, 
                0, 1, s.Y);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 2D rotation matrix with the specified angle in radians.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d Rotation(double angleInRadians)
        {
            var a = Fun.Cos(angleInRadians);
            var b = Fun.Sin(angleInRadians);

            return new M23d(
                 a, -b,  0, 
                 b,  a,  0);
        }

        /// <summary>
        /// Creates a 2D rotation matrix from a <see cref="Rot2d"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d Rotation(Rot2d r)
            => (M23d)r;

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<double> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M10;
                yield return M11;
                yield return M12;
            }
        }

        public IEnumerable<V3d> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2d> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        public V3d R0
        {
            get { return new V3d( M00,  M01,  M02); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        public V3d R1
        {
            get { return new V3d( M10,  M11,  M12); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        public V2d C0
        {
            get { return new V2d( M00,  M10); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        public V2d C1
        {
            get { return new V2d( M01,  M11); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public V2d C2
        {
            get { return new V2d( M02,  M12); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
            }
        }

        public double this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M10;
                    case 4: return M11;
                    case 5: return M12;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M10 = value; return;
                    case 4: M11 = value; return;
                    case 5: M12 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public double this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            case 2: return M02;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            case 2: return M12;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            case 2: M02 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            case 2: M12 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 3;
        public const int ElementCount = 2 * 3;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(2, 3);
        }

        public static M23d Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M23d(0);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public double Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public double NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public double NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M23d operator -(M23d m)
        {
            return new M23d(
                -m.M00, -m.M01, -m.M02, 
                -m.M10, -m.M11, -m.M12);
        }

        public static M23d operator  + (M23d a, M23d b)
        {
            return new M23d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23d operator  + (M23d m, double s)
        {
            return new M23d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        public static M23d operator  + (double s, M23d m)
        {
            return new M23d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23d operator  - (M23d a, M23d b)
        {
            return new M23d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23d operator  - (M23d m, double s)
        {
            return new M23d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        public static M23d operator  - (double s, M23d m)
        {
            return new M23d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23d operator  % (M23d a, M23d b)
        {
            return new M23d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23d operator  % (M23d m, double s)
        {
            return new M23d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        public static M23d operator  % (double s, M23d m)
        {
            return new M23d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23d operator  / (M23d a, M23d b)
        {
            return new M23d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23d operator  / (M23d m, double s)
        {
            return new M23d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        public static M23d operator  / (double s, M23d m)
        {
            return new M23d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23d operator  * (M23d m, double s)
        {
            return new M23d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        public static M23d operator  * (double s, M23d m)
        {
            return new M23d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M23d matrix with a V3d column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d operator *(M23d m, V3d v)
        {
            return new V2d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z);
        }

        /// <summary>
        /// Multiplies a V2d row vector with a M23d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d operator *(V2d v, M23d m)
        {
            return new V3d(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11, 
                v.X * m.M02 + v.Y * m.M12);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M23d a, M23d b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12;
        }

        public static bool operator <(M23d a, double s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s;
        }

        public static bool operator <(double s, M23d a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12 ;
        }

        public static bool operator >(M23d a, M23d b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12;
        }

        public static bool operator >(M23d a, double s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s;
        }

        public static bool operator >(double s, M23d a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12 ;
        }

        public static bool operator ==(M23d a, M23d b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12;
        }

        public static bool operator ==(M23d a, double s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s;
        }

        public static bool operator ==(double s, M23d a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12 ;
        }

        public static bool operator <=(M23d a, M23d b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12;
        }

        public static bool operator <=(M23d a, double s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s;
        }

        public static bool operator <=(double s, M23d a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12 ;
        }

        public static bool operator >=(M23d a, M23d b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12;
        }

        public static bool operator >=(M23d a, double s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s;
        }

        public static bool operator >=(double s, M23d a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12 ;
        }

        public static bool operator !=(M23d a, M23d b)
        {
            return !(a == b);
        }

        public static bool operator !=(M23d m, double s)
        {
            return !(m == s);
        }

        public static bool operator !=(double s, M23d m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M23d) ? (this == (M23d)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M23d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M23d.FromRows(
                V3d.Parse(x[0]), 
                V3d.Parse(x[1])
            );
        }

        #endregion

        #region Matrix Operations

        #endregion

        #region Matrix Multiplication

        public static M23d operator *(M22d a, M23d b)
        {
            return new M23d(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12
             );
        }

        public static M23d operator *(M23d a, M33d b)
        {
            return new M23d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (double)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (double)value;
        }

        #endregion
    }

    public class M23dEqualityComparer : IEqualityComparer<M23d>
    {
        public static readonly M23dEqualityComparer Default
            = new M23dEqualityComparer();

        #region IEqualityComparer<M23d> Members

        public bool Equals(M23d v0, M23d v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M23d v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm1(M23d m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M23d m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMax(M23d m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMin(M23d m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M23d m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static double Distance1(this M23d a, M23d b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M23d a, M23d b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M23d a, M23d b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMax(this M23d a, M23d b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMin(this M23d a, M23d b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d Transform(this M23d m, V3d v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Transform(this M23d m, V4d v)
        {
            return new V3d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z,
                v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d TransposedTransform(this M23d m, V2d v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by matrix m.
        /// </summary>
        public static V2d TransformDir(this M23d m, V2d v)
        {
            return new V2d(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by matrix m.
        /// </summary>
        public static V2d TransformPos(this M23d m, V2d p)
        {
            return new V2d(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Row(this M23d m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d Column(this M23d m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                case 2: return m.C2;
                default: throw new IndexOutOfRangeException();
            }
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M23d a, M23d b, double epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M33i

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M33i : IValidity, IMatrix<double>
    {
        [DataMember]
        public int M00, M01, M02;
        [DataMember]
        public int M10, M11, M12;
        [DataMember]
        public int M20, M21, M22;

        #region Constructors

        public M33i(int value)
        {
            M00 = value; M01 = value; M02 = value; 
            M10 = value; M11 = value; M12 = value; 
            M20 = value; M21 = value; M22 = value; 
        }

        public M33i(
                int m00, int m01, int m02, 
                int m10, int m11, int m12, 
                int m20, int m21, int m22)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
            M20 = m20; M21 = m21; M22 = m22; 
        }

        public M33i(int[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
            M20 = a[6];
            M21 = a[7];
            M22 = a[8];
        }

        public M33i(int[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
            M20 = a[start + 6];
            M21 = a[start + 7];
            M22 = a[start + 8];
        }

        public M33i(M22i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33i(M23i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33i(M34i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; 
        }

        public M33i(M44i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; 
        }

        public M33i(M22l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33i(M23l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33i(M33l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; 
        }

        public M33i(M34l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; 
        }

        public M33i(M44l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; 
        }

        public M33i(M22f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33i(M23f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33i(M33f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; 
        }

        public M33i(M34f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; 
        }

        public M33i(M44f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; 
        }

        public M33i(M22d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33i(M23d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33i(M33d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; 
        }

        public M33i(M34d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; 
        }

        public M33i(M44d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; 
        }

        #endregion

        #region Conversions

        public static explicit operator M33i(M22i m)
        {
            return new M33i {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M23i m)
        {
            return new M33i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M34i m)
        {
            return new M33i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33i(M44i m)
        {
            return new M33i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33i(M22l m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M23l m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M33l m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M34l m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M44l m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M22f m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M23f m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M33f m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M34f m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M44f m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M22d m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M23d m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M33d m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M34d m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M44d m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(int[] a)
        {
            return new M33i(
                a[0], a[1], a[2], 
                a[3], a[4], a[5], 
                a[6], a[7], a[8]);
        }

        public static explicit operator M33i(int[,] a)
        {
            return new M33i(
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2], 
                a[2, 0], a[2, 1], a[2, 2]);
        }

        public static explicit operator int[](M33i m)
        {
            return new int[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12, 
                m.M20, m.M21, m.M22
            };
        }

        public static explicit operator int[,](M33i m)
        {
            return new int[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }, 
                { m.M20, m.M21, m.M22 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
            array[index + 6] = M20;
            array[index + 7] = M21;
            array[index + 8] = M22;
        }

        public static explicit operator M33i(long[] a)
        {
            return new M33i(
                (int)a[0], (int)a[1], (int)a[2], 
                (int)a[3], (int)a[4], (int)a[5], 
                (int)a[6], (int)a[7], (int)a[8]);
        }

        public static explicit operator M33i(long[,] a)
        {
            return new M33i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2]);
        }

        public static explicit operator long[](M33i m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, 
                (long)m.M10, (long)m.M11, (long)m.M12, 
                (long)m.M20, (long)m.M21, (long)m.M22
            };
        }

        public static explicit operator long[,](M33i m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M10;
            array[index + 4] = (long)M11;
            array[index + 5] = (long)M12;
            array[index + 6] = (long)M20;
            array[index + 7] = (long)M21;
            array[index + 8] = (long)M22;
        }

        public static explicit operator M33i(float[] a)
        {
            return new M33i(
                (int)a[0], (int)a[1], (int)a[2], 
                (int)a[3], (int)a[4], (int)a[5], 
                (int)a[6], (int)a[7], (int)a[8]);
        }

        public static explicit operator M33i(float[,] a)
        {
            return new M33i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2]);
        }

        public static explicit operator float[](M33i m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, 
                (float)m.M10, (float)m.M11, (float)m.M12, 
                (float)m.M20, (float)m.M21, (float)m.M22
            };
        }

        public static explicit operator float[,](M33i m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M10;
            array[index + 4] = (float)M11;
            array[index + 5] = (float)M12;
            array[index + 6] = (float)M20;
            array[index + 7] = (float)M21;
            array[index + 8] = (float)M22;
        }

        public static explicit operator M33i(double[] a)
        {
            return new M33i(
                (int)a[0], (int)a[1], (int)a[2], 
                (int)a[3], (int)a[4], (int)a[5], 
                (int)a[6], (int)a[7], (int)a[8]);
        }

        public static explicit operator M33i(double[,] a)
        {
            return new M33i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2]);
        }

        public static explicit operator double[](M33i m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, 
                (double)m.M10, (double)m.M11, (double)m.M12, 
                (double)m.M20, (double)m.M21, (double)m.M22
            };
        }

        public static explicit operator double[,](M33i m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M10;
            array[index + 4] = (double)M11;
            array[index + 5] = (double)M12;
            array[index + 6] = (double)M20;
            array[index + 7] = (double)M21;
            array[index + 8] = (double)M22;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<int, int> element_fun)
        {
            return new M33i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<int, int, int, int> element_index0_index1_fun)
        {
            return new M33i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<int, long> element_fun)
        {
            return new M33l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<int, int, int, long> element_index0_index1_fun)
        {
            return new M33l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<int, float> element_fun)
        {
            return new M33f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<int, int, int, float> element_index0_index1_fun)
        {
            return new M33f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<int, double> element_fun)
        {
            return new M33d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<int, int, int, double> element_index0_index1_fun)
        {
            return new M33d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M22i UpperLeftM22()
        {
            return (M22i)this;
        }

        public int[] ToArray()
        {
            var array = new int[9];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            array[6] = M20;
            array[7] = M21;
            array[8] = M22;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i FromCols(V3i col0, V3i col1, V3i col2)
        {
            return new M33i(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y, 
                col0.Z, col1.Z, col2.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i FromRows(V3i row0, V3i row1, V3i row2)
        {
            return new M33i(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z, 
                row2.X, row2.Y, row2.Z);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M33i"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i Scale(int tX, int tY, int tZ)
        {
            return new M33i(
                tX, 0, 0, 
                0, tY, 0, 
                0, 0, tZ);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33i"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i Scale(int tX, int tY)
        {
            return new M33i(
                tX, 0, 0, 
                0, tY, 0, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33i"/> using a <see cref="V3i"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i Scale(V3i s)
        {
            return new M33i(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, s.Z);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33i"/> using a <see cref="V2i"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i Scale(V2i s)
        {
            return new M33i(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, 1);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M33i"/> with the translational component given by 2 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i Translation(int tX, int tY)
        {
            return new M33i(
                1, 0, tX, 
                0, 1, tY, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33i"/> with the translational component given by a <see cref="V2i"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i Translation(V2i t)
        {
            return new M33i(
                1, 0, t.X, 
                0, 1, t.Y, 
                0, 0, 1);
        }

        #endregion

        #region Shearing

        public static M33i ShearXY(int factorX, int factorY)
        {
            return new M33i(
                1, 0, factorX, 
                0, 1, factorY, 
                0, 0, 1);
        }

        public static M33i ShearXZ(int factorX, int factorZ)
        {
            return new M33i(
                1, factorX, 0, 
                0, 1, 0, 
                0, factorZ, 1);
        }

        public static M33i ShearYZ(int factorY, int factorZ)
        {
            return new M33i(
                1, 0, 0, 
                factorY, 1, 0, 
                factorZ, 0, 1);
        }

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<int> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M20;
                yield return M21;
                yield return M22;
            }
        }

        public IEnumerable<V3i> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3i> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        public V3i R0
        {
            get { return new V3i( M00,  M01,  M02); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        public V3i R1
        {
            get { return new V3i( M10,  M11,  M12); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        public V3i R2
        {
            get { return new V3i( M20,  M21,  M22); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
            }
        }

        public V3i C0
        {
            get { return new V3i( M00,  M10,  M20); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        public V3i C1
        {
            get { return new V3i( M01,  M11,  M21); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        public V3i C2
        {
            get { return new V3i( M02,  M12,  M22); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public int this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M10;
                    case 4: return M11;
                    case 5: return M12;
                    case 6: return M20;
                    case 7: return M21;
                    case 8: return M22;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M10 = value; return;
                    case 4: M11 = value; return;
                    case 5: M12 = value; return;
                    case 6: M20 = value; return;
                    case 7: M21 = value; return;
                    case 8: M22 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public int this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            case 2: return M02;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            case 2: return M12;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: return M20;
                            case 1: return M21;
                            case 2: return M22;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            case 2: M02 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            case 2: M12 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: M20 = value; return;
                            case 1: M21 = value; return;
                            case 2: M22 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 3;
        public const int ElementCount = 3 * 3;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(3, 3);
        }

        public static M33i Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M33i(0);
        }

        public static M33i Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M33i(1, 0, 0, 0, 1, 0, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public int Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + 
                    M20 * M20 + M21 * M21 + M22 * M22);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public int NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public int NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M33i operator -(M33i m)
        {
            return new M33i(
                -m.M00, -m.M01, -m.M02, 
                -m.M10, -m.M11, -m.M12, 
                -m.M20, -m.M21, -m.M22);
        }

        public static M33i operator  + (M33i a, M33i b)
        {
            return new M33i(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33i operator  + (M33i m, int s)
        {
            return new M33i(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        public static M33i operator  + (int s, M33i m)
        {
            return new M33i(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33l operator  + (M33i a, M33l b)
        {
            return new M33l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33l operator  + (M33i m, long s)
        {
            return new M33l(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        public static M33l operator  + (long s, M33i m)
        {
            return new M33l(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33f operator  + (M33i a, M33f b)
        {
            return new M33f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33f operator  + (M33i m, float s)
        {
            return new M33f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        public static M33f operator  + (float s, M33i m)
        {
            return new M33f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33d operator  + (M33i a, M33d b)
        {
            return new M33d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33d operator  + (M33i m, double s)
        {
            return new M33d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        public static M33d operator  + (double s, M33i m)
        {
            return new M33d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33i operator  - (M33i a, M33i b)
        {
            return new M33i(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33i operator  - (M33i m, int s)
        {
            return new M33i(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        public static M33i operator  - (int s, M33i m)
        {
            return new M33i(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33l operator  - (M33i a, M33l b)
        {
            return new M33l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33l operator  - (M33i m, long s)
        {
            return new M33l(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        public static M33l operator  - (long s, M33i m)
        {
            return new M33l(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33f operator  - (M33i a, M33f b)
        {
            return new M33f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33f operator  - (M33i m, float s)
        {
            return new M33f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        public static M33f operator  - (float s, M33i m)
        {
            return new M33f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33d operator  - (M33i a, M33d b)
        {
            return new M33d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33d operator  - (M33i m, double s)
        {
            return new M33d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        public static M33d operator  - (double s, M33i m)
        {
            return new M33d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33i operator  % (M33i a, M33i b)
        {
            return new M33i(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33i operator  % (M33i m, int s)
        {
            return new M33i(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        public static M33i operator  % (int s, M33i m)
        {
            return new M33i(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33l operator  % (M33i a, M33l b)
        {
            return new M33l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33l operator  % (M33i m, long s)
        {
            return new M33l(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        public static M33l operator  % (long s, M33i m)
        {
            return new M33l(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33f operator  % (M33i a, M33f b)
        {
            return new M33f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33f operator  % (M33i m, float s)
        {
            return new M33f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        public static M33f operator  % (float s, M33i m)
        {
            return new M33f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33d operator  % (M33i a, M33d b)
        {
            return new M33d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33d operator  % (M33i m, double s)
        {
            return new M33d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        public static M33d operator  % (double s, M33i m)
        {
            return new M33d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33i operator  / (M33i a, M33i b)
        {
            return new M33i(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33i operator  / (M33i m, int s)
        {
            return new M33i(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        public static M33i operator  / (int s, M33i m)
        {
            return new M33i(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33l operator  / (M33i a, M33l b)
        {
            return new M33l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33l operator  / (M33i m, long s)
        {
            return new M33l(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        public static M33l operator  / (long s, M33i m)
        {
            return new M33l(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33f operator  / (M33i a, M33f b)
        {
            return new M33f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33f operator  / (M33i m, float s)
        {
            return new M33f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        public static M33f operator  / (float s, M33i m)
        {
            return new M33f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33d operator  / (M33i a, M33d b)
        {
            return new M33d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33d operator  / (M33i m, double s)
        {
            return new M33d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        public static M33d operator  / (double s, M33i m)
        {
            return new M33d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33i operator  * (M33i m, int s)
        {
            return new M33i(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        public static M33i operator  * (int s, M33i m)
        {
            return new M33i(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33l operator  * (M33i m, long s)
        {
            return new M33l(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        public static M33l operator  * (long s, M33i m)
        {
            return new M33l(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33f operator  * (M33i m, float s)
        {
            return new M33f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        public static M33f operator  * (float s, M33i m)
        {
            return new M33f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33d operator  * (M33i m, double s)
        {
            return new M33d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        public static M33d operator  * (double s, M33i m)
        {
            return new M33d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M33i matrix with a V3i column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i operator *(M33i m, V3i v)
        {
            return new V3i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z);
        }

        /// <summary>
        /// Multiplies a V3i row vector with a M33i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i operator *(V3i v, M33i m)
        {
            return new V3i(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M33i a, M33i b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22;
        }

        public static bool operator <(M33i a, int s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s;
        }

        public static bool operator <(int s, M33i a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22 ;
        }

        public static bool operator >(M33i a, M33i b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22;
        }

        public static bool operator >(M33i a, int s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s;
        }

        public static bool operator >(int s, M33i a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22 ;
        }

        public static bool operator ==(M33i a, M33i b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22;
        }

        public static bool operator ==(M33i a, int s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s;
        }

        public static bool operator ==(int s, M33i a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22 ;
        }

        public static bool operator <=(M33i a, M33i b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22;
        }

        public static bool operator <=(M33i a, int s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s;
        }

        public static bool operator <=(int s, M33i a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22 ;
        }

        public static bool operator >=(M33i a, M33i b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22;
        }

        public static bool operator >=(M33i a, int s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s;
        }

        public static bool operator >=(int s, M33i a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22 ;
        }

        public static bool operator !=(M33i a, M33i b)
        {
            return !(a == b);
        }

        public static bool operator !=(M33i m, int s)
        {
            return !(m == s);
        }

        public static bool operator !=(int s, M33i m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M33i) ? (this == (M33i)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M33i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M33i.FromRows(
                V3i.Parse(x[0]), 
                V3i.Parse(x[1]), 
                V3i.Parse(x[2])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M33i Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                M33i result = new M33i();
                for (int row = 0; row < 3; row++)
                {
                    for (int col = 0; col < 3; col++)
                    {
                        if (((col + row) % 2) == 0)
                            result[col, row] = this.Minor(row, col).Determinant;
                        else
                            result[col, row] = -this.Minor(row, col).Determinant;
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public int Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 + M22 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public int Determinant
        {
            get
            {
                if (M10 == 0 && M20 == 0 && M21 == 0)
                {
                    return M00 * M11 * M22;
                }
                return
                M00 * M11 * M22 - M00 * M12 * M21 +
                M01 * M12 * M20 - M01 * M10 * M22 +
                M02 * M10 * M21 - M02 * M11 * M20;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M33i Transposed
        {
            get
            {
                return new M33i {
                    
                    M00 = M00, 
                    M01 = M10, 
                    M02 = M20, 
                    
                    M10 = M01, 
                    M11 = M11, 
                    M12 = M21, 
                    
                    M20 = M02, 
                    M21 = M12, 
                    M22 = M22
                };
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M33i operator *(M33i a, M33i b)
        {
            return new M33i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (int)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (int)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (int)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (int)value;
        }

        #endregion
    }

    public class M33iEqualityComparer : IEqualityComparer<M33i>
    {
        public static readonly M33iEqualityComparer Default
            = new M33iEqualityComparer();

        #region IEqualityComparer<M33i> Members

        public bool Equals(M33i v0, M33i v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M33i v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Norm1(M33i m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M33i m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMax(M33i m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMin(M33i m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M33i m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static int Distance1(this M33i a, M33i b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M33i a, M33i b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M33i a, M33i b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMax(this M33i a, M33i b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMin(this M33i a, M33i b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i Transform(this M33i m, V3i v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i Transform(this M33i m, V4i v)
        {
            return new V4i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z,
                v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i TransposedTransform(this M33i m, V3i v)
            => v * m;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i TransposedTransform(this M33i m, V4i v)
        {
            return new V4i(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22,
                v.W);
        }

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by matrix m.
        /// </summary>
        public static V2i TransformDir(this M33i m, V2i v)
        {
            return new V2i(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2i TransformPos(this M33i m, V2i p)
        {
            return new V2i(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Transforms point p (p.Z is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2i TransformPosProj(this M33i m, V2i p)
        {
            int s = m.M20 * p.X + m.M21 * p.Y + m.M22;
            return TransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (p.Z is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V3i TransformPosProjFull(this M33i m, V2i p)
        {
            return new V3i(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12, 
                m.M20 * p.X + m.M21 * p.Y + m.M22
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V2i TransposedTransformDir(this M33i m, V2i v)
        {
            return new V2i(
                m.M00 * v.X + m.M10 * v.Y, 
                m.M01 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2i TransposedTransformPos(this M33i m, V2i p)
        {
            return new V2i(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2i TransposedTransformProj(this M33i m, V2i p)
        {
            var s = m.M02 * p.X + m.M12 * p.Y + m.M22;
            return TransposedTransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3i TransposedTransformProjFull(this M33i m, V2i p)
        {
            return new V3i(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21, 
                m.M02 * p.X + m.M12 * p.Y + m.M22
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M33i"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static M22i Minor(this M33i m, int row, int column)
        {
            M22i rs = new M22i();

            for (int k = 0; k < 4; k++)
            {
                var i = k / 4;
                var j = k % 4;

                if (i != row && j != column)
                {
                    rs[k] = m[k];
                }
            }

            return rs;
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i Row(this M33i m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                case 2: return m.R2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i Column(this M33i m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                case 2: return m.C2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Determinant(M33i m)
            => m.Determinant;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        public static void Transpose(this ref M33i m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
            Fun.Swap(ref m.M20, ref m.M02);
            Fun.Swap(ref m.M21, ref m.M12);
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M33i a, M33i b, int epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M33l

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M33l : IValidity, IMatrix<double>
    {
        [DataMember]
        public long M00, M01, M02;
        [DataMember]
        public long M10, M11, M12;
        [DataMember]
        public long M20, M21, M22;

        #region Constructors

        public M33l(long value)
        {
            M00 = value; M01 = value; M02 = value; 
            M10 = value; M11 = value; M12 = value; 
            M20 = value; M21 = value; M22 = value; 
        }

        public M33l(
                long m00, long m01, long m02, 
                long m10, long m11, long m12, 
                long m20, long m21, long m22)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
            M20 = m20; M21 = m21; M22 = m22; 
        }

        public M33l(long[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
            M20 = a[6];
            M21 = a[7];
            M22 = a[8];
        }

        public M33l(long[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
            M20 = a[start + 6];
            M21 = a[start + 7];
            M22 = a[start + 8];
        }

        public M33l(M22i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33l(M23i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33l(M33i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; 
        }

        public M33l(M34i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; 
        }

        public M33l(M44i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; 
        }

        public M33l(M22l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33l(M23l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33l(M34l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; 
        }

        public M33l(M44l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; 
        }

        public M33l(M22f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33l(M23f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33l(M33f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; 
        }

        public M33l(M34f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; 
        }

        public M33l(M44f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; 
        }

        public M33l(M22d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33l(M23d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33l(M33d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; 
        }

        public M33l(M34d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; 
        }

        public M33l(M44d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; 
        }

        #endregion

        #region Conversions

        public static explicit operator M33l(M22i m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M23i m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M33i m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M34i m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M44i m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M22l m)
        {
            return new M33l {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M23l m)
        {
            return new M33l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M34l m)
        {
            return new M33l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33l(M44l m)
        {
            return new M33l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33l(M22f m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M23f m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M33f m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M34f m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M44f m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M22d m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M23d m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M33d m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M34d m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M44d m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(int[] a)
        {
            return new M33l(
                (long)a[0], (long)a[1], (long)a[2], 
                (long)a[3], (long)a[4], (long)a[5], 
                (long)a[6], (long)a[7], (long)a[8]);
        }

        public static explicit operator M33l(int[,] a)
        {
            return new M33l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2]);
        }

        public static explicit operator int[](M33l m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, 
                (int)m.M10, (int)m.M11, (int)m.M12, 
                (int)m.M20, (int)m.M21, (int)m.M22
            };
        }

        public static explicit operator int[,](M33l m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M10;
            array[index + 4] = (int)M11;
            array[index + 5] = (int)M12;
            array[index + 6] = (int)M20;
            array[index + 7] = (int)M21;
            array[index + 8] = (int)M22;
        }

        public static explicit operator M33l(long[] a)
        {
            return new M33l(
                a[0], a[1], a[2], 
                a[3], a[4], a[5], 
                a[6], a[7], a[8]);
        }

        public static explicit operator M33l(long[,] a)
        {
            return new M33l(
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2], 
                a[2, 0], a[2, 1], a[2, 2]);
        }

        public static explicit operator long[](M33l m)
        {
            return new long[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12, 
                m.M20, m.M21, m.M22
            };
        }

        public static explicit operator long[,](M33l m)
        {
            return new long[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }, 
                { m.M20, m.M21, m.M22 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
            array[index + 6] = M20;
            array[index + 7] = M21;
            array[index + 8] = M22;
        }

        public static explicit operator M33l(float[] a)
        {
            return new M33l(
                (long)a[0], (long)a[1], (long)a[2], 
                (long)a[3], (long)a[4], (long)a[5], 
                (long)a[6], (long)a[7], (long)a[8]);
        }

        public static explicit operator M33l(float[,] a)
        {
            return new M33l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2]);
        }

        public static explicit operator float[](M33l m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, 
                (float)m.M10, (float)m.M11, (float)m.M12, 
                (float)m.M20, (float)m.M21, (float)m.M22
            };
        }

        public static explicit operator float[,](M33l m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M10;
            array[index + 4] = (float)M11;
            array[index + 5] = (float)M12;
            array[index + 6] = (float)M20;
            array[index + 7] = (float)M21;
            array[index + 8] = (float)M22;
        }

        public static explicit operator M33l(double[] a)
        {
            return new M33l(
                (long)a[0], (long)a[1], (long)a[2], 
                (long)a[3], (long)a[4], (long)a[5], 
                (long)a[6], (long)a[7], (long)a[8]);
        }

        public static explicit operator M33l(double[,] a)
        {
            return new M33l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2]);
        }

        public static explicit operator double[](M33l m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, 
                (double)m.M10, (double)m.M11, (double)m.M12, 
                (double)m.M20, (double)m.M21, (double)m.M22
            };
        }

        public static explicit operator double[,](M33l m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M10;
            array[index + 4] = (double)M11;
            array[index + 5] = (double)M12;
            array[index + 6] = (double)M20;
            array[index + 7] = (double)M21;
            array[index + 8] = (double)M22;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<long, int> element_fun)
        {
            return new M33i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<long, int, int, int> element_index0_index1_fun)
        {
            return new M33i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<long, long> element_fun)
        {
            return new M33l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<long, int, int, long> element_index0_index1_fun)
        {
            return new M33l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<long, float> element_fun)
        {
            return new M33f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<long, int, int, float> element_index0_index1_fun)
        {
            return new M33f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<long, double> element_fun)
        {
            return new M33d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<long, int, int, double> element_index0_index1_fun)
        {
            return new M33d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M22l UpperLeftM22()
        {
            return (M22l)this;
        }

        public long[] ToArray()
        {
            var array = new long[9];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            array[6] = M20;
            array[7] = M21;
            array[8] = M22;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l FromCols(V3l col0, V3l col1, V3l col2)
        {
            return new M33l(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y, 
                col0.Z, col1.Z, col2.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l FromRows(V3l row0, V3l row1, V3l row2)
        {
            return new M33l(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z, 
                row2.X, row2.Y, row2.Z);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M33l"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l Scale(long tX, long tY, long tZ)
        {
            return new M33l(
                tX, 0, 0, 
                0, tY, 0, 
                0, 0, tZ);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33l"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l Scale(long tX, long tY)
        {
            return new M33l(
                tX, 0, 0, 
                0, tY, 0, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33l"/> using a <see cref="V3l"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l Scale(V3l s)
        {
            return new M33l(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, s.Z);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33l"/> using a <see cref="V2l"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l Scale(V2l s)
        {
            return new M33l(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, 1);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M33l"/> with the translational component given by 2 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l Translation(long tX, long tY)
        {
            return new M33l(
                1, 0, tX, 
                0, 1, tY, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33l"/> with the translational component given by a <see cref="V2l"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l Translation(V2l t)
        {
            return new M33l(
                1, 0, t.X, 
                0, 1, t.Y, 
                0, 0, 1);
        }

        #endregion

        #region Shearing

        public static M33l ShearXY(long factorX, long factorY)
        {
            return new M33l(
                1, 0, factorX, 
                0, 1, factorY, 
                0, 0, 1);
        }

        public static M33l ShearXZ(long factorX, long factorZ)
        {
            return new M33l(
                1, factorX, 0, 
                0, 1, 0, 
                0, factorZ, 1);
        }

        public static M33l ShearYZ(long factorY, long factorZ)
        {
            return new M33l(
                1, 0, 0, 
                factorY, 1, 0, 
                factorZ, 0, 1);
        }

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<long> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M20;
                yield return M21;
                yield return M22;
            }
        }

        public IEnumerable<V3l> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3l> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        public V3l R0
        {
            get { return new V3l( M00,  M01,  M02); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        public V3l R1
        {
            get { return new V3l( M10,  M11,  M12); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        public V3l R2
        {
            get { return new V3l( M20,  M21,  M22); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
            }
        }

        public V3l C0
        {
            get { return new V3l( M00,  M10,  M20); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        public V3l C1
        {
            get { return new V3l( M01,  M11,  M21); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        public V3l C2
        {
            get { return new V3l( M02,  M12,  M22); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public long this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M10;
                    case 4: return M11;
                    case 5: return M12;
                    case 6: return M20;
                    case 7: return M21;
                    case 8: return M22;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M10 = value; return;
                    case 4: M11 = value; return;
                    case 5: M12 = value; return;
                    case 6: M20 = value; return;
                    case 7: M21 = value; return;
                    case 8: M22 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public long this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            case 2: return M02;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            case 2: return M12;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: return M20;
                            case 1: return M21;
                            case 2: return M22;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            case 2: M02 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            case 2: M12 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: M20 = value; return;
                            case 1: M21 = value; return;
                            case 2: M22 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 3;
        public const int ElementCount = 3 * 3;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(3, 3);
        }

        public static M33l Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M33l(0);
        }

        public static M33l Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M33l(1, 0, 0, 0, 1, 0, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public long Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + 
                    M20 * M20 + M21 * M21 + M22 * M22);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public long NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public long NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M33l operator -(M33l m)
        {
            return new M33l(
                -m.M00, -m.M01, -m.M02, 
                -m.M10, -m.M11, -m.M12, 
                -m.M20, -m.M21, -m.M22);
        }

        public static M33l operator  + (M33l a, M33l b)
        {
            return new M33l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33l operator  + (M33l m, long s)
        {
            return new M33l(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        public static M33l operator  + (long s, M33l m)
        {
            return new M33l(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33f operator  + (M33l a, M33f b)
        {
            return new M33f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33f operator  + (M33l m, float s)
        {
            return new M33f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        public static M33f operator  + (float s, M33l m)
        {
            return new M33f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33d operator  + (M33l a, M33d b)
        {
            return new M33d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33d operator  + (M33l m, double s)
        {
            return new M33d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        public static M33d operator  + (double s, M33l m)
        {
            return new M33d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33l operator  - (M33l a, M33l b)
        {
            return new M33l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33l operator  - (M33l m, long s)
        {
            return new M33l(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        public static M33l operator  - (long s, M33l m)
        {
            return new M33l(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33f operator  - (M33l a, M33f b)
        {
            return new M33f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33f operator  - (M33l m, float s)
        {
            return new M33f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        public static M33f operator  - (float s, M33l m)
        {
            return new M33f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33d operator  - (M33l a, M33d b)
        {
            return new M33d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33d operator  - (M33l m, double s)
        {
            return new M33d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        public static M33d operator  - (double s, M33l m)
        {
            return new M33d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33l operator  % (M33l a, M33l b)
        {
            return new M33l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33l operator  % (M33l m, long s)
        {
            return new M33l(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        public static M33l operator  % (long s, M33l m)
        {
            return new M33l(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33f operator  % (M33l a, M33f b)
        {
            return new M33f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33f operator  % (M33l m, float s)
        {
            return new M33f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        public static M33f operator  % (float s, M33l m)
        {
            return new M33f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33d operator  % (M33l a, M33d b)
        {
            return new M33d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33d operator  % (M33l m, double s)
        {
            return new M33d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        public static M33d operator  % (double s, M33l m)
        {
            return new M33d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33l operator  / (M33l a, M33l b)
        {
            return new M33l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33l operator  / (M33l m, long s)
        {
            return new M33l(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        public static M33l operator  / (long s, M33l m)
        {
            return new M33l(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33f operator  / (M33l a, M33f b)
        {
            return new M33f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33f operator  / (M33l m, float s)
        {
            return new M33f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        public static M33f operator  / (float s, M33l m)
        {
            return new M33f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33d operator  / (M33l a, M33d b)
        {
            return new M33d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33d operator  / (M33l m, double s)
        {
            return new M33d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        public static M33d operator  / (double s, M33l m)
        {
            return new M33d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33l operator  * (M33l m, long s)
        {
            return new M33l(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        public static M33l operator  * (long s, M33l m)
        {
            return new M33l(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33f operator  * (M33l m, float s)
        {
            return new M33f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        public static M33f operator  * (float s, M33l m)
        {
            return new M33f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33d operator  * (M33l m, double s)
        {
            return new M33d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        public static M33d operator  * (double s, M33l m)
        {
            return new M33d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M33l matrix with a V3l column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l operator *(M33l m, V3l v)
        {
            return new V3l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z);
        }

        /// <summary>
        /// Multiplies a V3l row vector with a M33l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l operator *(V3l v, M33l m)
        {
            return new V3l(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M33l a, M33l b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22;
        }

        public static bool operator <(M33l a, long s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s;
        }

        public static bool operator <(long s, M33l a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22 ;
        }

        public static bool operator >(M33l a, M33l b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22;
        }

        public static bool operator >(M33l a, long s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s;
        }

        public static bool operator >(long s, M33l a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22 ;
        }

        public static bool operator ==(M33l a, M33l b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22;
        }

        public static bool operator ==(M33l a, long s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s;
        }

        public static bool operator ==(long s, M33l a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22 ;
        }

        public static bool operator <=(M33l a, M33l b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22;
        }

        public static bool operator <=(M33l a, long s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s;
        }

        public static bool operator <=(long s, M33l a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22 ;
        }

        public static bool operator >=(M33l a, M33l b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22;
        }

        public static bool operator >=(M33l a, long s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s;
        }

        public static bool operator >=(long s, M33l a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22 ;
        }

        public static bool operator !=(M33l a, M33l b)
        {
            return !(a == b);
        }

        public static bool operator !=(M33l m, long s)
        {
            return !(m == s);
        }

        public static bool operator !=(long s, M33l m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M33l) ? (this == (M33l)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M33l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M33l.FromRows(
                V3l.Parse(x[0]), 
                V3l.Parse(x[1]), 
                V3l.Parse(x[2])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M33l Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                M33l result = new M33l();
                for (int row = 0; row < 3; row++)
                {
                    for (int col = 0; col < 3; col++)
                    {
                        if (((col + row) % 2) == 0)
                            result[col, row] = this.Minor(row, col).Determinant;
                        else
                            result[col, row] = -this.Minor(row, col).Determinant;
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public long Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 + M22 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public long Determinant
        {
            get
            {
                if (M10 == 0 && M20 == 0 && M21 == 0)
                {
                    return M00 * M11 * M22;
                }
                return
                M00 * M11 * M22 - M00 * M12 * M21 +
                M01 * M12 * M20 - M01 * M10 * M22 +
                M02 * M10 * M21 - M02 * M11 * M20;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M33l Transposed
        {
            get
            {
                return new M33l {
                    
                    M00 = M00, 
                    M01 = M10, 
                    M02 = M20, 
                    
                    M10 = M01, 
                    M11 = M11, 
                    M12 = M21, 
                    
                    M20 = M02, 
                    M21 = M12, 
                    M22 = M22
                };
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M33l operator *(M33l a, M33l b)
        {
            return new M33l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (long)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (long)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (long)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (long)value;
        }

        #endregion
    }

    public class M33lEqualityComparer : IEqualityComparer<M33l>
    {
        public static readonly M33lEqualityComparer Default
            = new M33lEqualityComparer();

        #region IEqualityComparer<M33l> Members

        public bool Equals(M33l v0, M33l v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M33l v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Norm1(M33l m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M33l m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMax(M33l m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMin(M33l m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M33l m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static long Distance1(this M33l a, M33l b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M33l a, M33l b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M33l a, M33l b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMax(this M33l a, M33l b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMin(this M33l a, M33l b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l Transform(this M33l m, V3l v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l Transform(this M33l m, V4l v)
        {
            return new V4l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z,
                v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l TransposedTransform(this M33l m, V3l v)
            => v * m;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l TransposedTransform(this M33l m, V4l v)
        {
            return new V4l(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22,
                v.W);
        }

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by matrix m.
        /// </summary>
        public static V2l TransformDir(this M33l m, V2l v)
        {
            return new V2l(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2l TransformPos(this M33l m, V2l p)
        {
            return new V2l(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Transforms point p (p.Z is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2l TransformPosProj(this M33l m, V2l p)
        {
            long s = m.M20 * p.X + m.M21 * p.Y + m.M22;
            return TransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (p.Z is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V3l TransformPosProjFull(this M33l m, V2l p)
        {
            return new V3l(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12, 
                m.M20 * p.X + m.M21 * p.Y + m.M22
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V2l TransposedTransformDir(this M33l m, V2l v)
        {
            return new V2l(
                m.M00 * v.X + m.M10 * v.Y, 
                m.M01 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2l TransposedTransformPos(this M33l m, V2l p)
        {
            return new V2l(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2l TransposedTransformProj(this M33l m, V2l p)
        {
            var s = m.M02 * p.X + m.M12 * p.Y + m.M22;
            return TransposedTransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3l TransposedTransformProjFull(this M33l m, V2l p)
        {
            return new V3l(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21, 
                m.M02 * p.X + m.M12 * p.Y + m.M22
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M33l"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static M22l Minor(this M33l m, int row, int column)
        {
            M22l rs = new M22l();

            for (int k = 0; k < 4; k++)
            {
                var i = k / 4;
                var j = k % 4;

                if (i != row && j != column)
                {
                    rs[k] = m[k];
                }
            }

            return rs;
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l Row(this M33l m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                case 2: return m.R2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l Column(this M33l m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                case 2: return m.C2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Determinant(M33l m)
            => m.Determinant;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        public static void Transpose(this ref M33l m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
            Fun.Swap(ref m.M20, ref m.M02);
            Fun.Swap(ref m.M21, ref m.M12);
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M33l a, M33l b, long epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M33f

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M33f : IValidity, IMatrix<double>
    {
        [DataMember]
        public float M00, M01, M02;
        [DataMember]
        public float M10, M11, M12;
        [DataMember]
        public float M20, M21, M22;

        #region Constructors

        public M33f(float value)
        {
            M00 = value; M01 = value; M02 = value; 
            M10 = value; M11 = value; M12 = value; 
            M20 = value; M21 = value; M22 = value; 
        }

        public M33f(
                float m00, float m01, float m02, 
                float m10, float m11, float m12, 
                float m20, float m21, float m22)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
            M20 = m20; M21 = m21; M22 = m22; 
        }

        public M33f(float[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
            M20 = a[6];
            M21 = a[7];
            M22 = a[8];
        }

        public M33f(float[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
            M20 = a[start + 6];
            M21 = a[start + 7];
            M22 = a[start + 8];
        }

        public M33f(M22i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33f(M23i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33f(M33i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; 
        }

        public M33f(M34i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; 
        }

        public M33f(M44i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; 
        }

        public M33f(M22l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33f(M23l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33f(M33l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; 
        }

        public M33f(M34l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; 
        }

        public M33f(M44l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; 
        }

        public M33f(M22f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33f(M23f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33f(M34f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; 
        }

        public M33f(M44f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; 
        }

        public M33f(M22d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33f(M23d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33f(M33d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; 
        }

        public M33f(M34d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; 
        }

        public M33f(M44d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; 
        }

        #endregion

        #region Conversions

        public static explicit operator M33f(M22i m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M23i m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M33i m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M34i m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M44i m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M22l m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M23l m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M33l m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M34l m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M44l m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M22f m)
        {
            return new M33f {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M23f m)
        {
            return new M33f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M34f m)
        {
            return new M33f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33f(M44f m)
        {
            return new M33f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33f(M22d m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M23d m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M33d m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M34d m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M44d m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(int[] a)
        {
            return new M33f(
                (float)a[0], (float)a[1], (float)a[2], 
                (float)a[3], (float)a[4], (float)a[5], 
                (float)a[6], (float)a[7], (float)a[8]);
        }

        public static explicit operator M33f(int[,] a)
        {
            return new M33f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2]);
        }

        public static explicit operator int[](M33f m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, 
                (int)m.M10, (int)m.M11, (int)m.M12, 
                (int)m.M20, (int)m.M21, (int)m.M22
            };
        }

        public static explicit operator int[,](M33f m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M10;
            array[index + 4] = (int)M11;
            array[index + 5] = (int)M12;
            array[index + 6] = (int)M20;
            array[index + 7] = (int)M21;
            array[index + 8] = (int)M22;
        }

        public static explicit operator M33f(long[] a)
        {
            return new M33f(
                (float)a[0], (float)a[1], (float)a[2], 
                (float)a[3], (float)a[4], (float)a[5], 
                (float)a[6], (float)a[7], (float)a[8]);
        }

        public static explicit operator M33f(long[,] a)
        {
            return new M33f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2]);
        }

        public static explicit operator long[](M33f m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, 
                (long)m.M10, (long)m.M11, (long)m.M12, 
                (long)m.M20, (long)m.M21, (long)m.M22
            };
        }

        public static explicit operator long[,](M33f m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M10;
            array[index + 4] = (long)M11;
            array[index + 5] = (long)M12;
            array[index + 6] = (long)M20;
            array[index + 7] = (long)M21;
            array[index + 8] = (long)M22;
        }

        public static explicit operator M33f(float[] a)
        {
            return new M33f(
                a[0], a[1], a[2], 
                a[3], a[4], a[5], 
                a[6], a[7], a[8]);
        }

        public static explicit operator M33f(float[,] a)
        {
            return new M33f(
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2], 
                a[2, 0], a[2, 1], a[2, 2]);
        }

        public static explicit operator float[](M33f m)
        {
            return new float[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12, 
                m.M20, m.M21, m.M22
            };
        }

        public static explicit operator float[,](M33f m)
        {
            return new float[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }, 
                { m.M20, m.M21, m.M22 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
            array[index + 6] = M20;
            array[index + 7] = M21;
            array[index + 8] = M22;
        }

        public static explicit operator M33f(double[] a)
        {
            return new M33f(
                (float)a[0], (float)a[1], (float)a[2], 
                (float)a[3], (float)a[4], (float)a[5], 
                (float)a[6], (float)a[7], (float)a[8]);
        }

        public static explicit operator M33f(double[,] a)
        {
            return new M33f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2]);
        }

        public static explicit operator double[](M33f m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, 
                (double)m.M10, (double)m.M11, (double)m.M12, 
                (double)m.M20, (double)m.M21, (double)m.M22
            };
        }

        public static explicit operator double[,](M33f m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M10;
            array[index + 4] = (double)M11;
            array[index + 5] = (double)M12;
            array[index + 6] = (double)M20;
            array[index + 7] = (double)M21;
            array[index + 8] = (double)M22;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<float, int> element_fun)
        {
            return new M33i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<float, int, int, int> element_index0_index1_fun)
        {
            return new M33i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<float, long> element_fun)
        {
            return new M33l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<float, int, int, long> element_index0_index1_fun)
        {
            return new M33l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<float, float> element_fun)
        {
            return new M33f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<float, int, int, float> element_index0_index1_fun)
        {
            return new M33f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<float, double> element_fun)
        {
            return new M33d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<float, int, int, double> element_index0_index1_fun)
        {
            return new M33d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M22f UpperLeftM22()
        {
            return (M22f)this;
        }

        public float[] ToArray()
        {
            var array = new float[9];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            array[6] = M20;
            array[7] = M21;
            array[8] = M22;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f FromCols(V3f col0, V3f col1, V3f col2)
        {
            return new M33f(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y, 
                col0.Z, col1.Z, col2.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f FromRows(V3f row0, V3f row1, V3f row2)
        {
            return new M33f(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z, 
                row2.X, row2.Y, row2.Z);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M33f"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Scale(float tX, float tY, float tZ)
        {
            return new M33f(
                tX, 0, 0, 
                0, tY, 0, 
                0, 0, tZ);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33f"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Scale(float tX, float tY)
        {
            return new M33f(
                tX, 0, 0, 
                0, tY, 0, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33f"/> using a <see cref="V3f"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Scale(V3f s)
        {
            return new M33f(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, s.Z);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33f"/> using a <see cref="V2f"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Scale(V2f s)
        {
            return new M33f(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33f"/> from a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Scale(Scale3f s)
        {
            return new M33f(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, s.Z);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M33f"/> with the translational component given by 2 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Translation(float tX, float tY)
        {
            return new M33f(
                1, 0, tX, 
                0, 1, tY, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33f"/> with the translational component given by a <see cref="V2f"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Translation(V2f t)
        {
            return new M33f(
                1, 0, t.X, 
                0, 1, t.Y, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33f"/> from a <see cref="Shift2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Translation(Shift2f s)
        {
            return new M33f(
                1, 0, s.X, 
                0, 1, s.Y, 
                0, 0, 1);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 2D rotation matrix with the specified angle in radians.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Rotation(float angleInRadians)
        {
            var a = Fun.Cos(angleInRadians);
            var b = Fun.Sin(angleInRadians);

            return new M33f(
                 a, -b,  0, 
                 b,  a,  0, 
                 0,  0,  1);
        }

        /// <summary>
        /// Creates a 3D rotation matrix from a <see cref="Rot3f"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Rotation(Rot3f r)
            => (M33f)r;

        /// <summary>
        /// Creates a 2D rotation matrix from a <see cref="Rot2f"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Rotation(Rot2f r)
            => (M33f)r;

        /// <summary>
        /// Creates a 3D rotation matrix from an axis vector and an angle in radians.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Rotation(V3f normalizedAxis, float angleInRadians)
        {
            Debug.Assert(normalizedAxis.LengthSquared.ApproximateEquals(1));
            return (M33f)(Rot3f.Rotation(normalizedAxis, angleInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z). 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f RotationEuler(float rollInRadians, float pitchInRadians, float yawInRadians)
        {
            return (M33f)(Rot3f.RotationEuler(rollInRadians, pitchInRadians, yawInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) Vector.
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f RotationEuler(V3f roll_pitch_yaw_inRadians)
        {
            return (M33f)(Rot3f.RotationEuler(
                roll_pitch_yaw_inRadians.X,
                roll_pitch_yaw_inRadians.Y,
                roll_pitch_yaw_inRadians.Z));
        }

        /// <summary>
        /// Creates a 3D rotation matrix which rotates one vector into another.
        /// The input vectors have to be normalized.
        /// </summary>
        public static M33f RotateInto(V3f from, V3f into)
        {
            Debug.Assert(from.LengthSquared.ApproximateEquals(1));
            Debug.Assert(into.LengthSquared.ApproximateEquals(1));
            return (M33f)(Rot3f.RotateInto(from, into));
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the X-Axis.
        /// </summary>
        public static M33f RotationX(float angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M33f(
                 1,  0,  0, 
                 0,  a, -b, 
                 0,  b,  a);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the Y-Axis.
        /// </summary>
        public static M33f RotationY(float angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M33f(
                 a,  0,  b, 
                 0,  1,  0, 
                -b,  0,  a);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the Z-Axis.
        /// </summary>
        public static M33f RotationZ(float angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M33f(
                 a, -b,  0, 
                 b,  a,  0, 
                 0,  0,  1);
        }

        #endregion

        #region Shearing

        public static M33f ShearXY(float factorX, float factorY)
        {
            return new M33f(
                1, 0, factorX, 
                0, 1, factorY, 
                0, 0, 1);
        }

        public static M33f ShearXZ(float factorX, float factorZ)
        {
            return new M33f(
                1, factorX, 0, 
                0, 1, 0, 
                0, factorZ, 1);
        }

        public static M33f ShearYZ(float factorY, float factorZ)
        {
            return new M33f(
                1, 0, 0, 
                factorY, 1, 0, 
                factorZ, 0, 1);
        }

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<float> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M20;
                yield return M21;
                yield return M22;
            }
        }

        public IEnumerable<V3f> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3f> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        public V3f R0
        {
            get { return new V3f( M00,  M01,  M02); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        public V3f R1
        {
            get { return new V3f( M10,  M11,  M12); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        public V3f R2
        {
            get { return new V3f( M20,  M21,  M22); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
            }
        }

        public V3f C0
        {
            get { return new V3f( M00,  M10,  M20); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        public V3f C1
        {
            get { return new V3f( M01,  M11,  M21); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        public V3f C2
        {
            get { return new V3f( M02,  M12,  M22); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M10;
                    case 4: return M11;
                    case 5: return M12;
                    case 6: return M20;
                    case 7: return M21;
                    case 8: return M22;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M10 = value; return;
                    case 4: M11 = value; return;
                    case 5: M12 = value; return;
                    case 6: M20 = value; return;
                    case 7: M21 = value; return;
                    case 8: M22 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public float this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            case 2: return M02;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            case 2: return M12;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: return M20;
                            case 1: return M21;
                            case 2: return M22;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            case 2: M02 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            case 2: M12 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: M20 = value; return;
                            case 1: M21 = value; return;
                            case 2: M22 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 3;
        public const int ElementCount = 3 * 3;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(3, 3);
        }

        public static M33f Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M33f(0);
        }

        public static M33f Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M33f(1, 0, 0, 0, 1, 0, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public float Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public float Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + 
                    M20 * M20 + M21 * M21 + M22 * M22);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public float NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public float NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M33f operator -(M33f m)
        {
            return new M33f(
                -m.M00, -m.M01, -m.M02, 
                -m.M10, -m.M11, -m.M12, 
                -m.M20, -m.M21, -m.M22);
        }

        public static M33f operator  + (M33f a, M33f b)
        {
            return new M33f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33f operator  + (M33f m, float s)
        {
            return new M33f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        public static M33f operator  + (float s, M33f m)
        {
            return new M33f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33d operator  + (M33f a, M33d b)
        {
            return new M33d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33d operator  + (M33f m, double s)
        {
            return new M33d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        public static M33d operator  + (double s, M33f m)
        {
            return new M33d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33f operator  - (M33f a, M33f b)
        {
            return new M33f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33f operator  - (M33f m, float s)
        {
            return new M33f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        public static M33f operator  - (float s, M33f m)
        {
            return new M33f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33d operator  - (M33f a, M33d b)
        {
            return new M33d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33d operator  - (M33f m, double s)
        {
            return new M33d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        public static M33d operator  - (double s, M33f m)
        {
            return new M33d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33f operator  % (M33f a, M33f b)
        {
            return new M33f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33f operator  % (M33f m, float s)
        {
            return new M33f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        public static M33f operator  % (float s, M33f m)
        {
            return new M33f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33d operator  % (M33f a, M33d b)
        {
            return new M33d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33d operator  % (M33f m, double s)
        {
            return new M33d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        public static M33d operator  % (double s, M33f m)
        {
            return new M33d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33f operator  / (M33f a, M33f b)
        {
            return new M33f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33f operator  / (M33f m, float s)
        {
            return new M33f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        public static M33f operator  / (float s, M33f m)
        {
            return new M33f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33d operator  / (M33f a, M33d b)
        {
            return new M33d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33d operator  / (M33f m, double s)
        {
            return new M33d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        public static M33d operator  / (double s, M33f m)
        {
            return new M33d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33f operator  * (M33f m, float s)
        {
            return new M33f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        public static M33f operator  * (float s, M33f m)
        {
            return new M33f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33d operator  * (M33f m, double s)
        {
            return new M33d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        public static M33d operator  * (double s, M33f m)
        {
            return new M33d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M33f matrix with a V3f column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f operator *(M33f m, V3f v)
        {
            return new V3f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z);
        }

        /// <summary>
        /// Multiplies a V3f row vector with a M33f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f operator *(V3f v, M33f m)
        {
            return new V3f(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M33f a, M33f b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22;
        }

        public static bool operator <(M33f a, float s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s;
        }

        public static bool operator <(float s, M33f a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22 ;
        }

        public static bool operator >(M33f a, M33f b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22;
        }

        public static bool operator >(M33f a, float s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s;
        }

        public static bool operator >(float s, M33f a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22 ;
        }

        public static bool operator ==(M33f a, M33f b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22;
        }

        public static bool operator ==(M33f a, float s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s;
        }

        public static bool operator ==(float s, M33f a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22 ;
        }

        public static bool operator <=(M33f a, M33f b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22;
        }

        public static bool operator <=(M33f a, float s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s;
        }

        public static bool operator <=(float s, M33f a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22 ;
        }

        public static bool operator >=(M33f a, M33f b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22;
        }

        public static bool operator >=(M33f a, float s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s;
        }

        public static bool operator >=(float s, M33f a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22 ;
        }

        public static bool operator !=(M33f a, M33f b)
        {
            return !(a == b);
        }

        public static bool operator !=(M33f m, float s)
        {
            return !(m == s);
        }

        public static bool operator !=(float s, M33f m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M33f) ? (this == (M33f)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M33f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M33f.FromRows(
                V3f.Parse(x[0]), 
                V3f.Parse(x[1]), 
                V3f.Parse(x[2])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M33f Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                M33f result = new M33f();
                for (int row = 0; row < 3; row++)
                {
                    for (int col = 0; col < 3; col++)
                    {
                        if (((col + row) % 2) == 0)
                            result[col, row] = this.Minor(row, col).Determinant;
                        else
                            result[col, row] = -this.Minor(row, col).Determinant;
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public float Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 + M22 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public float Determinant
        {
            get
            {
                if (M10 == 0 && M20 == 0 && M21 == 0)
                {
                    return M00 * M11 * M22;
                }
                return
                M00 * M11 * M22 - M00 * M12 * M21 +
                M01 * M12 * M20 - M01 * M10 * M22 +
                M02 * M10 * M21 - M02 * M11 * M20;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M33f Transposed
        {
            get
            {
                return new M33f {
                    
                    M00 = M00, 
                    M01 = M10, 
                    M02 = M20, 
                    
                    M10 = M01, 
                    M11 = M11, 
                    M12 = M21, 
                    
                    M20 = M02, 
                    M21 = M12, 
                    M22 = M22
                };
            }
        }

        private static V2l s_luSize = new V2l(3, 3);
        private static V2l s_luDelta = new V2l(1, 3);

        /// <summary>
        /// Inverts the given matrix using lu factorization in place. Returns true
        /// if the matrix was invertible, otherwise the matrix remains unchanged.
        /// </summary>
        public bool LuInvert()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return false;
            this = (M33f)(lu.LuInverse(p).Data);
            return true;
        }

        /// <summary>
        /// Returns the inverse of the matrix using lu factorization.
        /// If the matrix is not invertible, M33f.Zero is returned.
        /// </summary>
        public M33f LuInverse()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return M33f.Zero;
            return (M33f)(lu.LuInverse(p).Data);
        }

        /// <summary>
        /// Returns the inverse of this matrix. If the matrix is not invertible
        /// M33f.Zero is returned.
        /// </summary>
        public M33f Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => LuInverse();
        }

        #endregion

        #region Matrix Multiplication

        public static M33f operator *(M33f a, M33f b)
        {
            return new M33f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (float)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (float)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (float)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (float)value;
        }

        #endregion
    }

    public class M33fEqualityComparer : IEqualityComparer<M33f>
    {
        public static readonly M33fEqualityComparer Default
            = new M33fEqualityComparer();

        #region IEqualityComparer<M33f> Members

        public bool Equals(M33f v0, M33f v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M33f v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm1(M33f m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm2(M33f m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMax(M33f m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMin(M33f m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm(this M33f m, float p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static float Distance1(this M33f a, M33f b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static float Distance2(this M33f a, M33f b)
        {
            return (float)Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static float Distance(this M33f a, M33f b, float p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMax(this M33f a, M33f b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMin(this M33f a, M33f b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Transform(this M33f m, V3f v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f Transform(this M33f m, V4f v)
        {
            return new V4f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z,
                v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f TransposedTransform(this M33f m, V3f v)
            => v * m;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f TransposedTransform(this M33f m, V4f v)
        {
            return new V4f(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22,
                v.W);
        }

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by matrix m.
        /// </summary>
        public static V2f TransformDir(this M33f m, V2f v)
        {
            return new V2f(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2f TransformPos(this M33f m, V2f p)
        {
            return new V2f(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Transforms point p (p.Z is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2f TransformPosProj(this M33f m, V2f p)
        {
            float s = m.M20 * p.X + m.M21 * p.Y + m.M22;
            return TransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (p.Z is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V3f TransformPosProjFull(this M33f m, V2f p)
        {
            return new V3f(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12, 
                m.M20 * p.X + m.M21 * p.Y + m.M22
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V2f TransposedTransformDir(this M33f m, V2f v)
        {
            return new V2f(
                m.M00 * v.X + m.M10 * v.Y, 
                m.M01 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2f TransposedTransformPos(this M33f m, V2f p)
        {
            return new V2f(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2f TransposedTransformProj(this M33f m, V2f p)
        {
            var s = m.M02 * p.X + m.M12 * p.Y + m.M22;
            return TransposedTransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3f TransposedTransformProjFull(this M33f m, V2f p)
        {
            return new V3f(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21, 
                m.M02 * p.X + m.M12 * p.Y + m.M22
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M33f"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static M22f Minor(this M33f m, int row, int column)
        {
            M22f rs = new M22f();

            for (int k = 0; k < 4; k++)
            {
                var i = k / 4;
                var j = k % 4;

                if (i != row && j != column)
                {
                    rs[k] = m[k];
                }
            }

            return rs;
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Row(this M33f m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                case 2: return m.R2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Column(this M33f m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                case 2: return m.C2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Determinant(M33f m)
            => m.Determinant;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        public static void Transpose(this ref M33f m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
            Fun.Swap(ref m.M20, ref m.M02);
            Fun.Swap(ref m.M21, ref m.M12);
        }

        /// <summary>
        /// Inverts the given matrix in place. Returns true if the matrix was invertible,
        /// otherwise the matrix remains unchanged.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Invert(this ref M33f m) { return m.LuInvert(); }

        /// <summary>
        /// Returns if the given matrix is the identity matrix I.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsIdentity(this M33f m, float epsilon)
        {
            return Fun.ApproximateEquals(m, M33f.Identity, epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthonormal(this M33f m, float epsilon)
        {
            var i = m * m.Transposed;
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthogonal(this M33f m, float epsilon)
        {
            var i = m * m.Transposed;
            for (int j = 0; j < 3; j++)
                i[j, j] = 1; //inefficient implementation: just leave out the comparisons at the diagonal entries.
            return i.IsIdentity(epsilon);
        }
        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M33f a, M33f b, float epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M33d

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M33d : IValidity, IMatrix<double>
    {
        [DataMember]
        public double M00, M01, M02;
        [DataMember]
        public double M10, M11, M12;
        [DataMember]
        public double M20, M21, M22;

        #region Constructors

        public M33d(double value)
        {
            M00 = value; M01 = value; M02 = value; 
            M10 = value; M11 = value; M12 = value; 
            M20 = value; M21 = value; M22 = value; 
        }

        public M33d(
                double m00, double m01, double m02, 
                double m10, double m11, double m12, 
                double m20, double m21, double m22)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
            M20 = m20; M21 = m21; M22 = m22; 
        }

        public M33d(double[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
            M20 = a[6];
            M21 = a[7];
            M22 = a[8];
        }

        public M33d(double[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
            M20 = a[start + 6];
            M21 = a[start + 7];
            M22 = a[start + 8];
        }

        public M33d(M22i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33d(M23i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33d(M33i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; 
        }

        public M33d(M34i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; 
        }

        public M33d(M44i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; 
        }

        public M33d(M22l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33d(M23l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33d(M33l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; 
        }

        public M33d(M34l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; 
        }

        public M33d(M44l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; 
        }

        public M33d(M22f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33d(M23f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33d(M33f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; 
        }

        public M33d(M34f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; 
        }

        public M33d(M44f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; 
        }

        public M33d(M22d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33d(M23d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        public M33d(M34d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; 
        }

        public M33d(M44d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; 
        }

        #endregion

        #region Conversions

        public static explicit operator M33d(M22i m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M23i m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M33i m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M34i m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M44i m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M22l m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M23l m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M33l m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M34l m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M44l m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M22f m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M23f m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M33f m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M34f m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M44f m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M22d m)
        {
            return new M33d {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M23d m)
        {
            return new M33d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M34d m)
        {
            return new M33d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33d(M44d m)
        {
            return new M33d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33d(int[] a)
        {
            return new M33d(
                (double)a[0], (double)a[1], (double)a[2], 
                (double)a[3], (double)a[4], (double)a[5], 
                (double)a[6], (double)a[7], (double)a[8]);
        }

        public static explicit operator M33d(int[,] a)
        {
            return new M33d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2]);
        }

        public static explicit operator int[](M33d m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, 
                (int)m.M10, (int)m.M11, (int)m.M12, 
                (int)m.M20, (int)m.M21, (int)m.M22
            };
        }

        public static explicit operator int[,](M33d m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M10;
            array[index + 4] = (int)M11;
            array[index + 5] = (int)M12;
            array[index + 6] = (int)M20;
            array[index + 7] = (int)M21;
            array[index + 8] = (int)M22;
        }

        public static explicit operator M33d(long[] a)
        {
            return new M33d(
                (double)a[0], (double)a[1], (double)a[2], 
                (double)a[3], (double)a[4], (double)a[5], 
                (double)a[6], (double)a[7], (double)a[8]);
        }

        public static explicit operator M33d(long[,] a)
        {
            return new M33d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2]);
        }

        public static explicit operator long[](M33d m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, 
                (long)m.M10, (long)m.M11, (long)m.M12, 
                (long)m.M20, (long)m.M21, (long)m.M22
            };
        }

        public static explicit operator long[,](M33d m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M10;
            array[index + 4] = (long)M11;
            array[index + 5] = (long)M12;
            array[index + 6] = (long)M20;
            array[index + 7] = (long)M21;
            array[index + 8] = (long)M22;
        }

        public static explicit operator M33d(float[] a)
        {
            return new M33d(
                (double)a[0], (double)a[1], (double)a[2], 
                (double)a[3], (double)a[4], (double)a[5], 
                (double)a[6], (double)a[7], (double)a[8]);
        }

        public static explicit operator M33d(float[,] a)
        {
            return new M33d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2]);
        }

        public static explicit operator float[](M33d m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, 
                (float)m.M10, (float)m.M11, (float)m.M12, 
                (float)m.M20, (float)m.M21, (float)m.M22
            };
        }

        public static explicit operator float[,](M33d m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M10;
            array[index + 4] = (float)M11;
            array[index + 5] = (float)M12;
            array[index + 6] = (float)M20;
            array[index + 7] = (float)M21;
            array[index + 8] = (float)M22;
        }

        public static explicit operator M33d(double[] a)
        {
            return new M33d(
                a[0], a[1], a[2], 
                a[3], a[4], a[5], 
                a[6], a[7], a[8]);
        }

        public static explicit operator M33d(double[,] a)
        {
            return new M33d(
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2], 
                a[2, 0], a[2, 1], a[2, 2]);
        }

        public static explicit operator double[](M33d m)
        {
            return new double[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12, 
                m.M20, m.M21, m.M22
            };
        }

        public static explicit operator double[,](M33d m)
        {
            return new double[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }, 
                { m.M20, m.M21, m.M22 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
            array[index + 6] = M20;
            array[index + 7] = M21;
            array[index + 8] = M22;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<double, int> element_fun)
        {
            return new M33i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<double, int, int, int> element_index0_index1_fun)
        {
            return new M33i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<double, long> element_fun)
        {
            return new M33l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<double, int, int, long> element_index0_index1_fun)
        {
            return new M33l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<double, float> element_fun)
        {
            return new M33f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<double, int, int, float> element_index0_index1_fun)
        {
            return new M33f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<double, double> element_fun)
        {
            return new M33d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<double, int, int, double> element_index0_index1_fun)
        {
            return new M33d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M22d UpperLeftM22()
        {
            return (M22d)this;
        }

        public double[] ToArray()
        {
            var array = new double[9];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            array[6] = M20;
            array[7] = M21;
            array[8] = M22;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d FromCols(V3d col0, V3d col1, V3d col2)
        {
            return new M33d(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y, 
                col0.Z, col1.Z, col2.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d FromRows(V3d row0, V3d row1, V3d row2)
        {
            return new M33d(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z, 
                row2.X, row2.Y, row2.Z);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M33d"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Scale(double tX, double tY, double tZ)
        {
            return new M33d(
                tX, 0, 0, 
                0, tY, 0, 
                0, 0, tZ);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33d"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Scale(double tX, double tY)
        {
            return new M33d(
                tX, 0, 0, 
                0, tY, 0, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33d"/> using a <see cref="V3d"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Scale(V3d s)
        {
            return new M33d(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, s.Z);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33d"/> using a <see cref="V2d"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Scale(V2d s)
        {
            return new M33d(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33d"/> from a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Scale(Scale3d s)
        {
            return new M33d(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, s.Z);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M33d"/> with the translational component given by 2 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Translation(double tX, double tY)
        {
            return new M33d(
                1, 0, tX, 
                0, 1, tY, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33d"/> with the translational component given by a <see cref="V2d"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Translation(V2d t)
        {
            return new M33d(
                1, 0, t.X, 
                0, 1, t.Y, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33d"/> from a <see cref="Shift2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Translation(Shift2d s)
        {
            return new M33d(
                1, 0, s.X, 
                0, 1, s.Y, 
                0, 0, 1);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 2D rotation matrix with the specified angle in radians.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Rotation(double angleInRadians)
        {
            var a = Fun.Cos(angleInRadians);
            var b = Fun.Sin(angleInRadians);

            return new M33d(
                 a, -b,  0, 
                 b,  a,  0, 
                 0,  0,  1);
        }

        /// <summary>
        /// Creates a 3D rotation matrix from a <see cref="Rot3d"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Rotation(Rot3d r)
            => (M33d)r;

        /// <summary>
        /// Creates a 2D rotation matrix from a <see cref="Rot2d"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Rotation(Rot2d r)
            => (M33d)r;

        /// <summary>
        /// Creates a 3D rotation matrix from an axis vector and an angle in radians.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Rotation(V3d normalizedAxis, double angleInRadians)
        {
            Debug.Assert(normalizedAxis.LengthSquared.ApproximateEquals(1));
            return (M33d)(Rot3d.Rotation(normalizedAxis, angleInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z). 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d RotationEuler(double rollInRadians, double pitchInRadians, double yawInRadians)
        {
            return (M33d)(Rot3d.RotationEuler(rollInRadians, pitchInRadians, yawInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) Vector.
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d RotationEuler(V3d roll_pitch_yaw_inRadians)
        {
            return (M33d)(Rot3d.RotationEuler(
                roll_pitch_yaw_inRadians.X,
                roll_pitch_yaw_inRadians.Y,
                roll_pitch_yaw_inRadians.Z));
        }

        /// <summary>
        /// Creates a 3D rotation matrix which rotates one vector into another.
        /// The input vectors have to be normalized.
        /// </summary>
        public static M33d RotateInto(V3d from, V3d into)
        {
            Debug.Assert(from.LengthSquared.ApproximateEquals(1));
            Debug.Assert(into.LengthSquared.ApproximateEquals(1));
            return (M33d)(Rot3d.RotateInto(from, into));
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the X-Axis.
        /// </summary>
        public static M33d RotationX(double angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M33d(
                 1,  0,  0, 
                 0,  a, -b, 
                 0,  b,  a);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the Y-Axis.
        /// </summary>
        public static M33d RotationY(double angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M33d(
                 a,  0,  b, 
                 0,  1,  0, 
                -b,  0,  a);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the Z-Axis.
        /// </summary>
        public static M33d RotationZ(double angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M33d(
                 a, -b,  0, 
                 b,  a,  0, 
                 0,  0,  1);
        }

        #endregion

        #region Shearing

        public static M33d ShearXY(double factorX, double factorY)
        {
            return new M33d(
                1, 0, factorX, 
                0, 1, factorY, 
                0, 0, 1);
        }

        public static M33d ShearXZ(double factorX, double factorZ)
        {
            return new M33d(
                1, factorX, 0, 
                0, 1, 0, 
                0, factorZ, 1);
        }

        public static M33d ShearYZ(double factorY, double factorZ)
        {
            return new M33d(
                1, 0, 0, 
                factorY, 1, 0, 
                factorZ, 0, 1);
        }

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<double> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M20;
                yield return M21;
                yield return M22;
            }
        }

        public IEnumerable<V3d> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3d> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        public V3d R0
        {
            get { return new V3d( M00,  M01,  M02); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        public V3d R1
        {
            get { return new V3d( M10,  M11,  M12); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        public V3d R2
        {
            get { return new V3d( M20,  M21,  M22); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
            }
        }

        public V3d C0
        {
            get { return new V3d( M00,  M10,  M20); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        public V3d C1
        {
            get { return new V3d( M01,  M11,  M21); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        public V3d C2
        {
            get { return new V3d( M02,  M12,  M22); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public double this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M10;
                    case 4: return M11;
                    case 5: return M12;
                    case 6: return M20;
                    case 7: return M21;
                    case 8: return M22;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M10 = value; return;
                    case 4: M11 = value; return;
                    case 5: M12 = value; return;
                    case 6: M20 = value; return;
                    case 7: M21 = value; return;
                    case 8: M22 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public double this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            case 2: return M02;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            case 2: return M12;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: return M20;
                            case 1: return M21;
                            case 2: return M22;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            case 2: M02 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            case 2: M12 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: M20 = value; return;
                            case 1: M21 = value; return;
                            case 2: M22 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 3;
        public const int ElementCount = 3 * 3;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(3, 3);
        }

        public static M33d Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M33d(0);
        }

        public static M33d Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M33d(1, 0, 0, 0, 1, 0, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public double Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + 
                    M20 * M20 + M21 * M21 + M22 * M22);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public double NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public double NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M33d operator -(M33d m)
        {
            return new M33d(
                -m.M00, -m.M01, -m.M02, 
                -m.M10, -m.M11, -m.M12, 
                -m.M20, -m.M21, -m.M22);
        }

        public static M33d operator  + (M33d a, M33d b)
        {
            return new M33d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33d operator  + (M33d m, double s)
        {
            return new M33d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        public static M33d operator  + (double s, M33d m)
        {
            return new M33d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33d operator  - (M33d a, M33d b)
        {
            return new M33d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33d operator  - (M33d m, double s)
        {
            return new M33d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        public static M33d operator  - (double s, M33d m)
        {
            return new M33d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33d operator  % (M33d a, M33d b)
        {
            return new M33d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33d operator  % (M33d m, double s)
        {
            return new M33d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        public static M33d operator  % (double s, M33d m)
        {
            return new M33d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33d operator  / (M33d a, M33d b)
        {
            return new M33d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33d operator  / (M33d m, double s)
        {
            return new M33d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        public static M33d operator  / (double s, M33d m)
        {
            return new M33d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33d operator  * (M33d m, double s)
        {
            return new M33d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        public static M33d operator  * (double s, M33d m)
        {
            return new M33d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M33d matrix with a V3d column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d operator *(M33d m, V3d v)
        {
            return new V3d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z);
        }

        /// <summary>
        /// Multiplies a V3d row vector with a M33d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d operator *(V3d v, M33d m)
        {
            return new V3d(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M33d a, M33d b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22;
        }

        public static bool operator <(M33d a, double s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s;
        }

        public static bool operator <(double s, M33d a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22 ;
        }

        public static bool operator >(M33d a, M33d b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22;
        }

        public static bool operator >(M33d a, double s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s;
        }

        public static bool operator >(double s, M33d a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22 ;
        }

        public static bool operator ==(M33d a, M33d b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22;
        }

        public static bool operator ==(M33d a, double s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s;
        }

        public static bool operator ==(double s, M33d a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22 ;
        }

        public static bool operator <=(M33d a, M33d b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22;
        }

        public static bool operator <=(M33d a, double s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s;
        }

        public static bool operator <=(double s, M33d a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22 ;
        }

        public static bool operator >=(M33d a, M33d b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22;
        }

        public static bool operator >=(M33d a, double s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s;
        }

        public static bool operator >=(double s, M33d a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22 ;
        }

        public static bool operator !=(M33d a, M33d b)
        {
            return !(a == b);
        }

        public static bool operator !=(M33d m, double s)
        {
            return !(m == s);
        }

        public static bool operator !=(double s, M33d m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M33d) ? (this == (M33d)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M33d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M33d.FromRows(
                V3d.Parse(x[0]), 
                V3d.Parse(x[1]), 
                V3d.Parse(x[2])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M33d Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                M33d result = new M33d();
                for (int row = 0; row < 3; row++)
                {
                    for (int col = 0; col < 3; col++)
                    {
                        if (((col + row) % 2) == 0)
                            result[col, row] = this.Minor(row, col).Determinant;
                        else
                            result[col, row] = -this.Minor(row, col).Determinant;
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public double Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 + M22 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public double Determinant
        {
            get
            {
                if (M10 == 0 && M20 == 0 && M21 == 0)
                {
                    return M00 * M11 * M22;
                }
                return
                M00 * M11 * M22 - M00 * M12 * M21 +
                M01 * M12 * M20 - M01 * M10 * M22 +
                M02 * M10 * M21 - M02 * M11 * M20;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M33d Transposed
        {
            get
            {
                return new M33d {
                    
                    M00 = M00, 
                    M01 = M10, 
                    M02 = M20, 
                    
                    M10 = M01, 
                    M11 = M11, 
                    M12 = M21, 
                    
                    M20 = M02, 
                    M21 = M12, 
                    M22 = M22
                };
            }
        }

        private static V2l s_luSize = new V2l(3, 3);
        private static V2l s_luDelta = new V2l(1, 3);

        /// <summary>
        /// Inverts the given matrix using lu factorization in place. Returns true
        /// if the matrix was invertible, otherwise the matrix remains unchanged.
        /// </summary>
        public bool LuInvert()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return false;
            this = (M33d)(lu.LuInverse(p).Data);
            return true;
        }

        /// <summary>
        /// Returns the inverse of the matrix using lu factorization.
        /// If the matrix is not invertible, M33d.Zero is returned.
        /// </summary>
        public M33d LuInverse()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return M33d.Zero;
            return (M33d)(lu.LuInverse(p).Data);
        }

        /// <summary>
        /// Returns the inverse of this matrix. If the matrix is not invertible
        /// M33d.Zero is returned.
        /// </summary>
        public M33d Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => LuInverse();
        }

        #endregion

        #region Matrix Multiplication

        public static M33d operator *(M33d a, M33d b)
        {
            return new M33d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (double)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (double)value;
        }

        #endregion
    }

    public class M33dEqualityComparer : IEqualityComparer<M33d>
    {
        public static readonly M33dEqualityComparer Default
            = new M33dEqualityComparer();

        #region IEqualityComparer<M33d> Members

        public bool Equals(M33d v0, M33d v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M33d v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm1(M33d m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M33d m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMax(M33d m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMin(M33d m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M33d m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static double Distance1(this M33d a, M33d b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M33d a, M33d b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M33d a, M33d b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMax(this M33d a, M33d b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMin(this M33d a, M33d b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Transform(this M33d m, V3d v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d Transform(this M33d m, V4d v)
        {
            return new V4d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z,
                v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d TransposedTransform(this M33d m, V3d v)
            => v * m;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d TransposedTransform(this M33d m, V4d v)
        {
            return new V4d(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22,
                v.W);
        }

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by matrix m.
        /// </summary>
        public static V2d TransformDir(this M33d m, V2d v)
        {
            return new V2d(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2d TransformPos(this M33d m, V2d p)
        {
            return new V2d(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Transforms point p (p.Z is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2d TransformPosProj(this M33d m, V2d p)
        {
            double s = m.M20 * p.X + m.M21 * p.Y + m.M22;
            return TransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (p.Z is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V3d TransformPosProjFull(this M33d m, V2d p)
        {
            return new V3d(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12, 
                m.M20 * p.X + m.M21 * p.Y + m.M22
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V2d TransposedTransformDir(this M33d m, V2d v)
        {
            return new V2d(
                m.M00 * v.X + m.M10 * v.Y, 
                m.M01 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2d TransposedTransformPos(this M33d m, V2d p)
        {
            return new V2d(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2d TransposedTransformProj(this M33d m, V2d p)
        {
            var s = m.M02 * p.X + m.M12 * p.Y + m.M22;
            return TransposedTransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3d TransposedTransformProjFull(this M33d m, V2d p)
        {
            return new V3d(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21, 
                m.M02 * p.X + m.M12 * p.Y + m.M22
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M33d"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static M22d Minor(this M33d m, int row, int column)
        {
            M22d rs = new M22d();

            for (int k = 0; k < 4; k++)
            {
                var i = k / 4;
                var j = k % 4;

                if (i != row && j != column)
                {
                    rs[k] = m[k];
                }
            }

            return rs;
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Row(this M33d m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                case 2: return m.R2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Column(this M33d m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                case 2: return m.C2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Determinant(M33d m)
            => m.Determinant;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        public static void Transpose(this ref M33d m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
            Fun.Swap(ref m.M20, ref m.M02);
            Fun.Swap(ref m.M21, ref m.M12);
        }

        /// <summary>
        /// Inverts the given matrix in place. Returns true if the matrix was invertible,
        /// otherwise the matrix remains unchanged.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Invert(this ref M33d m) { return m.LuInvert(); }

        /// <summary>
        /// Returns if the given matrix is the identity matrix I.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsIdentity(this M33d m, double epsilon)
        {
            return Fun.ApproximateEquals(m, M33d.Identity, epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthonormal(this M33d m, double epsilon)
        {
            var i = m * m.Transposed;
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthogonal(this M33d m, double epsilon)
        {
            var i = m * m.Transposed;
            for (int j = 0; j < 3; j++)
                i[j, j] = 1; //inefficient implementation: just leave out the comparisons at the diagonal entries.
            return i.IsIdentity(epsilon);
        }
        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M33d a, M33d b, double epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M34i

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M34i : IValidity, IMatrix<double>
    {
        [DataMember]
        public int M00, M01, M02, M03;
        [DataMember]
        public int M10, M11, M12, M13;
        [DataMember]
        public int M20, M21, M22, M23;

        #region Constructors

        public M34i(int value)
        {
            M00 = value; M01 = value; M02 = value; M03 = value; 
            M10 = value; M11 = value; M12 = value; M13 = value; 
            M20 = value; M21 = value; M22 = value; M23 = value; 
        }

        public M34i(
                int m00, int m01, int m02, int m03, 
                int m10, int m11, int m12, int m13, 
                int m20, int m21, int m22, int m23)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
        }

        public M34i(int[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
        }

        public M34i(int[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
        }

        public M34i(M33i m, V3i v)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = v.X; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = v.Y; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = v.Z; 
        }

        public M34i(M22i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34i(M23i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34i(M33i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = 0; 
        }

        public M34i(M44i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = m.M03; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = m.M13; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = m.M23; 
        }

        public M34i(M22l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34i(M23l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34i(M33l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = 0; 
        }

        public M34i(M34l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
        }

        public M34i(M44l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
        }

        public M34i(M22f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34i(M23f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34i(M33f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = 0; 
        }

        public M34i(M34f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
        }

        public M34i(M44f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
        }

        public M34i(M22d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34i(M23d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34i(M33d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = 0; 
        }

        public M34i(M34d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
        }

        public M34i(M44d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
        }

        #endregion

        #region Conversions

        public static explicit operator M34i(M22i m)
        {
            return new M34i {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M23i m)
        {
            return new M34i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M33i m)
        {
            return new M34i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34i(M44i m)
        {
            return new M34i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
            };
        }

        public static explicit operator M34i(M22l m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M23l m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M33l m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34i(M34l m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
            };
        }

        public static explicit operator M34i(M44l m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
            };
        }

        public static explicit operator M34i(M22f m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M23f m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M33f m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34i(M34f m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
            };
        }

        public static explicit operator M34i(M44f m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
            };
        }

        public static explicit operator M34i(M22d m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M23d m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M33d m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34i(M34d m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
            };
        }

        public static explicit operator M34i(M44d m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
            };
        }

        public static explicit operator M34i(int[] a)
        {
            return new M34i(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11]);
        }

        public static explicit operator M34i(int[,] a)
        {
            return new M34i(
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3]);
        }

        public static explicit operator int[](M34i m)
        {
            return new int[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23
            };
        }

        public static explicit operator int[,](M34i m)
        {
            return new int[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
        }

        public static explicit operator M34i(long[] a)
        {
            return new M34i(
                (int)a[0], (int)a[1], (int)a[2], (int)a[3], 
                (int)a[4], (int)a[5], (int)a[6], (int)a[7], 
                (int)a[8], (int)a[9], (int)a[10], (int)a[11]);
        }

        public static explicit operator M34i(long[,] a)
        {
            return new M34i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], (int)a[0, 3], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], (int)a[1, 3], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2], (int)a[2, 3]);
        }

        public static explicit operator long[](M34i m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03, 
                (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13, 
                (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23
            };
        }

        public static explicit operator long[,](M34i m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M03;
            array[index + 4] = (long)M10;
            array[index + 5] = (long)M11;
            array[index + 6] = (long)M12;
            array[index + 7] = (long)M13;
            array[index + 8] = (long)M20;
            array[index + 9] = (long)M21;
            array[index + 10] = (long)M22;
            array[index + 11] = (long)M23;
        }

        public static explicit operator M34i(float[] a)
        {
            return new M34i(
                (int)a[0], (int)a[1], (int)a[2], (int)a[3], 
                (int)a[4], (int)a[5], (int)a[6], (int)a[7], 
                (int)a[8], (int)a[9], (int)a[10], (int)a[11]);
        }

        public static explicit operator M34i(float[,] a)
        {
            return new M34i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], (int)a[0, 3], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], (int)a[1, 3], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2], (int)a[2, 3]);
        }

        public static explicit operator float[](M34i m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03, 
                (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13, 
                (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23
            };
        }

        public static explicit operator float[,](M34i m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M03;
            array[index + 4] = (float)M10;
            array[index + 5] = (float)M11;
            array[index + 6] = (float)M12;
            array[index + 7] = (float)M13;
            array[index + 8] = (float)M20;
            array[index + 9] = (float)M21;
            array[index + 10] = (float)M22;
            array[index + 11] = (float)M23;
        }

        public static explicit operator M34i(double[] a)
        {
            return new M34i(
                (int)a[0], (int)a[1], (int)a[2], (int)a[3], 
                (int)a[4], (int)a[5], (int)a[6], (int)a[7], 
                (int)a[8], (int)a[9], (int)a[10], (int)a[11]);
        }

        public static explicit operator M34i(double[,] a)
        {
            return new M34i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], (int)a[0, 3], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], (int)a[1, 3], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2], (int)a[2, 3]);
        }

        public static explicit operator double[](M34i m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03, 
                (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13, 
                (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23
            };
        }

        public static explicit operator double[,](M34i m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M03;
            array[index + 4] = (double)M10;
            array[index + 5] = (double)M11;
            array[index + 6] = (double)M12;
            array[index + 7] = (double)M13;
            array[index + 8] = (double)M20;
            array[index + 9] = (double)M21;
            array[index + 10] = (double)M22;
            array[index + 11] = (double)M23;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<int, int> element_fun)
        {
            return new M34i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<int, int, int, int> element_index0_index1_fun)
        {
            return new M34i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<int, long> element_fun)
        {
            return new M34l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<int, int, int, long> element_index0_index1_fun)
        {
            return new M34l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<int, float> element_fun)
        {
            return new M34f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<int, int, int, float> element_index0_index1_fun)
        {
            return new M34f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<int, double> element_fun)
        {
            return new M34d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<int, int, int, double> element_index0_index1_fun)
        {
            return new M34d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        public int[] ToArray()
        {
            var array = new int[12];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i FromCols(V3i col0, V3i col1, V3i col2, V3i col3)
        {
            return new M34i(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i FromRows(V4i row0, V4i row1, V4i row2)
        {
            return new M34i(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M34i"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i Scale(int tX, int tY, int tZ)
        {
            return new M34i(
                tX, 0, 0, 0, 
                0, tY, 0, 0, 
                0, 0, tZ, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34i"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i Scale(int tX, int tY)
        {
            return new M34i(
                tX, 0, 0, 0, 
                0, tY, 0, 0, 
                0, 0, 1, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34i"/> using a <see cref="V4i"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i Scale(V4i s)
        {
            return new M34i(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34i"/> using a <see cref="V3i"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i Scale(V3i s)
        {
            return new M34i(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, 1, 0);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M34i"/> with the translational component given by 3 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i Translation(int tX, int tY, int tZ)
        {
            return new M34i(
                1, 0, 0, tX, 
                0, 1, 0, tY, 
                0, 0, 1, tZ);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34i"/> with the translational component given by a <see cref="V3i"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i Translation(V3i t)
        {
            return new M34i(
                1, 0, 0, t.X, 
                0, 1, 0, t.Y, 
                0, 0, 1, t.Z);
        }

        #endregion

        #region Shearing

        public static M34i ShearXY(int factorX, int factorY)
        {
            return new M34i(
                1, 0, factorX, 0, 
                0, 1, factorY, 0, 
                0, 0, 1, 0);
        }

        public static M34i ShearXZ(int factorX, int factorZ)
        {
            return new M34i(
                1, factorX, 0, 0, 
                0, 1, 0, 0, 
                0, factorZ, 1, 0);
        }

        public static M34i ShearYZ(int factorY, int factorZ)
        {
            return new M34i(
                1, 0, 0, 0, 
                factorY, 1, 0, 0, 
                factorZ, 0, 1, 0);
        }

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<int> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M03;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M13;
                yield return M20;
                yield return M21;
                yield return M22;
                yield return M23;
            }
        }

        public IEnumerable<V4i> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3i> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        public V4i R0
        {
            get { return new V4i( M00,  M01,  M02,  M03); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        public V4i R1
        {
            get { return new V4i( M10,  M11,  M12,  M13); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        public V4i R2
        {
            get { return new V4i( M20,  M21,  M22,  M23); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        public V3i C0
        {
            get { return new V3i( M00,  M10,  M20); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        public V3i C1
        {
            get { return new V3i( M01,  M11,  M21); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        public V3i C2
        {
            get { return new V3i( M02,  M12,  M22); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public V3i C3
        {
            get { return new V3i( M03,  M13,  M23); }
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
            }
        }

        public int this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M03;
                    case 4: return M10;
                    case 5: return M11;
                    case 6: return M12;
                    case 7: return M13;
                    case 8: return M20;
                    case 9: return M21;
                    case 10: return M22;
                    case 11: return M23;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M03 = value; return;
                    case 4: M10 = value; return;
                    case 5: M11 = value; return;
                    case 6: M12 = value; return;
                    case 7: M13 = value; return;
                    case 8: M20 = value; return;
                    case 9: M21 = value; return;
                    case 10: M22 = value; return;
                    case 11: M23 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public int this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            case 2: return M02;
                            case 3: return M03;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            case 2: return M12;
                            case 3: return M13;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: return M20;
                            case 1: return M21;
                            case 2: return M22;
                            case 3: return M23;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            case 2: M02 = value; return;
                            case 3: M03 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            case 2: M12 = value; return;
                            case 3: M13 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: M20 = value; return;
                            case 1: M21 = value; return;
                            case 2: M22 = value; return;
                            case 3: M23 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 4;
        public const int ElementCount = 3 * 4;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(3, 4);
        }

        public static M34i Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M34i(0);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public int Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public int NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public int NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M34i operator -(M34i m)
        {
            return new M34i(
                -m.M00, -m.M01, -m.M02, -m.M03, 
                -m.M10, -m.M11, -m.M12, -m.M13, 
                -m.M20, -m.M21, -m.M22, -m.M23);
        }

        public static M34i operator  + (M34i a, M34i b)
        {
            return new M34i(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34i operator  + (M34i m, int s)
        {
            return new M34i(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        public static M34i operator  + (int s, M34i m)
        {
            return new M34i(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34l operator  + (M34i a, M34l b)
        {
            return new M34l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34l operator  + (M34i m, long s)
        {
            return new M34l(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        public static M34l operator  + (long s, M34i m)
        {
            return new M34l(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34f operator  + (M34i a, M34f b)
        {
            return new M34f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34f operator  + (M34i m, float s)
        {
            return new M34f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        public static M34f operator  + (float s, M34i m)
        {
            return new M34f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34d operator  + (M34i a, M34d b)
        {
            return new M34d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34d operator  + (M34i m, double s)
        {
            return new M34d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        public static M34d operator  + (double s, M34i m)
        {
            return new M34d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34i operator  - (M34i a, M34i b)
        {
            return new M34i(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34i operator  - (M34i m, int s)
        {
            return new M34i(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        public static M34i operator  - (int s, M34i m)
        {
            return new M34i(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34l operator  - (M34i a, M34l b)
        {
            return new M34l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34l operator  - (M34i m, long s)
        {
            return new M34l(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        public static M34l operator  - (long s, M34i m)
        {
            return new M34l(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34f operator  - (M34i a, M34f b)
        {
            return new M34f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34f operator  - (M34i m, float s)
        {
            return new M34f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        public static M34f operator  - (float s, M34i m)
        {
            return new M34f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34d operator  - (M34i a, M34d b)
        {
            return new M34d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34d operator  - (M34i m, double s)
        {
            return new M34d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        public static M34d operator  - (double s, M34i m)
        {
            return new M34d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34i operator  % (M34i a, M34i b)
        {
            return new M34i(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34i operator  % (M34i m, int s)
        {
            return new M34i(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        public static M34i operator  % (int s, M34i m)
        {
            return new M34i(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34l operator  % (M34i a, M34l b)
        {
            return new M34l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34l operator  % (M34i m, long s)
        {
            return new M34l(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        public static M34l operator  % (long s, M34i m)
        {
            return new M34l(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34f operator  % (M34i a, M34f b)
        {
            return new M34f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34f operator  % (M34i m, float s)
        {
            return new M34f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        public static M34f operator  % (float s, M34i m)
        {
            return new M34f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34d operator  % (M34i a, M34d b)
        {
            return new M34d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34d operator  % (M34i m, double s)
        {
            return new M34d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        public static M34d operator  % (double s, M34i m)
        {
            return new M34d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34i operator  / (M34i a, M34i b)
        {
            return new M34i(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34i operator  / (M34i m, int s)
        {
            return new M34i(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        public static M34i operator  / (int s, M34i m)
        {
            return new M34i(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34l operator  / (M34i a, M34l b)
        {
            return new M34l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34l operator  / (M34i m, long s)
        {
            return new M34l(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        public static M34l operator  / (long s, M34i m)
        {
            return new M34l(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34f operator  / (M34i a, M34f b)
        {
            return new M34f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34f operator  / (M34i m, float s)
        {
            return new M34f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        public static M34f operator  / (float s, M34i m)
        {
            return new M34f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34d operator  / (M34i a, M34d b)
        {
            return new M34d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34d operator  / (M34i m, double s)
        {
            return new M34d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        public static M34d operator  / (double s, M34i m)
        {
            return new M34d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34i operator  * (M34i m, int s)
        {
            return new M34i(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        public static M34i operator  * (int s, M34i m)
        {
            return new M34i(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34l operator  * (M34i m, long s)
        {
            return new M34l(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        public static M34l operator  * (long s, M34i m)
        {
            return new M34l(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34f operator  * (M34i m, float s)
        {
            return new M34f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        public static M34f operator  * (float s, M34i m)
        {
            return new M34f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34d operator  * (M34i m, double s)
        {
            return new M34d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        public static M34d operator  * (double s, M34i m)
        {
            return new M34d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M34i matrix with a V4i column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i operator *(M34i m, V4i v)
        {
            return new V3i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W);
        }

        /// <summary>
        /// Multiplies a V3i row vector with a M34i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i operator *(V3i v, M34i m)
        {
            return new V4i(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M34i a, M34i b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23;
        }

        public static bool operator <(M34i a, int s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s;
        }

        public static bool operator <(int s, M34i a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23 ;
        }

        public static bool operator >(M34i a, M34i b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23;
        }

        public static bool operator >(M34i a, int s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s;
        }

        public static bool operator >(int s, M34i a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23 ;
        }

        public static bool operator ==(M34i a, M34i b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23;
        }

        public static bool operator ==(M34i a, int s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s;
        }

        public static bool operator ==(int s, M34i a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23 ;
        }

        public static bool operator <=(M34i a, M34i b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23;
        }

        public static bool operator <=(M34i a, int s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s;
        }

        public static bool operator <=(int s, M34i a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23 ;
        }

        public static bool operator >=(M34i a, M34i b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23;
        }

        public static bool operator >=(M34i a, int s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s;
        }

        public static bool operator >=(int s, M34i a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23 ;
        }

        public static bool operator !=(M34i a, M34i b)
        {
            return !(a == b);
        }

        public static bool operator !=(M34i m, int s)
        {
            return !(m == s);
        }

        public static bool operator !=(int s, M34i m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), M03.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), M13.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode(), M23.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M34i) ? (this == (M34i)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M34i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M34i.FromRows(
                V4i.Parse(x[0]), 
                V4i.Parse(x[1]), 
                V4i.Parse(x[2])
            );
        }

        #endregion

        #region Matrix Operations

        #endregion

        #region Matrix Multiplication

        public static M34i operator *(M33i a, M34i b)
        {
            return new M34i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23
             );
        }

        public static M34i operator *(M34i a, M44i b)
        {
            return new M34i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (int)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (int)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (int)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (int)value;
        }

        #endregion
    }

    public class M34iEqualityComparer : IEqualityComparer<M34i>
    {
        public static readonly M34iEqualityComparer Default
            = new M34iEqualityComparer();

        #region IEqualityComparer<M34i> Members

        public bool Equals(M34i v0, M34i v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M34i v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Norm1(M34i m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M34i m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMax(M34i m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMin(M34i m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M34i m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M03).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M13).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p) + 
                Fun.Abs(m.M23).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static int Distance1(this M34i a, M34i b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M34i a, M34i b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M34i a, M34i b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMax(this M34i a, M34i b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMin(this M34i a, M34i b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i Transform(this M34i m, V4i v)
            => m * v;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i TransposedTransform(this M34i m, V3i v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by matrix m.
        /// </summary>
        public static V3i TransformDir(this M34i m, V3i v)
        {
            return new V3i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by matrix m.
        /// </summary>
        public static V3i TransformPos(this M34i m, V3i p)
        {
            return new V3i(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i Row(this M34i m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                case 2: return m.R2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i Column(this M34i m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                case 2: return m.C2;
                case 3: return m.C3;
                default: throw new IndexOutOfRangeException();
            }
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M34i a, M34i b, int epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M34l

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M34l : IValidity, IMatrix<double>
    {
        [DataMember]
        public long M00, M01, M02, M03;
        [DataMember]
        public long M10, M11, M12, M13;
        [DataMember]
        public long M20, M21, M22, M23;

        #region Constructors

        public M34l(long value)
        {
            M00 = value; M01 = value; M02 = value; M03 = value; 
            M10 = value; M11 = value; M12 = value; M13 = value; 
            M20 = value; M21 = value; M22 = value; M23 = value; 
        }

        public M34l(
                long m00, long m01, long m02, long m03, 
                long m10, long m11, long m12, long m13, 
                long m20, long m21, long m22, long m23)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
        }

        public M34l(long[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
        }

        public M34l(long[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
        }

        public M34l(M33l m, V3l v)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = v.X; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = v.Y; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = v.Z; 
        }

        public M34l(M22i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34l(M23i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34l(M33i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = 0; 
        }

        public M34l(M34i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
        }

        public M34l(M44i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
        }

        public M34l(M22l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34l(M23l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34l(M33l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = 0; 
        }

        public M34l(M44l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = m.M03; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = m.M13; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = m.M23; 
        }

        public M34l(M22f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34l(M23f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34l(M33f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = 0; 
        }

        public M34l(M34f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
        }

        public M34l(M44f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
        }

        public M34l(M22d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34l(M23d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34l(M33d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = 0; 
        }

        public M34l(M34d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
        }

        public M34l(M44d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
        }

        #endregion

        #region Conversions

        public static explicit operator M34l(M22i m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M23i m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M33i m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34l(M34i m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
            };
        }

        public static explicit operator M34l(M44i m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
            };
        }

        public static explicit operator M34l(M22l m)
        {
            return new M34l {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M23l m)
        {
            return new M34l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M33l m)
        {
            return new M34l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34l(M44l m)
        {
            return new M34l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
            };
        }

        public static explicit operator M34l(M22f m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M23f m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M33f m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34l(M34f m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
            };
        }

        public static explicit operator M34l(M44f m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
            };
        }

        public static explicit operator M34l(M22d m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M23d m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M33d m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34l(M34d m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
            };
        }

        public static explicit operator M34l(M44d m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
            };
        }

        public static explicit operator M34l(int[] a)
        {
            return new M34l(
                (long)a[0], (long)a[1], (long)a[2], (long)a[3], 
                (long)a[4], (long)a[5], (long)a[6], (long)a[7], 
                (long)a[8], (long)a[9], (long)a[10], (long)a[11]);
        }

        public static explicit operator M34l(int[,] a)
        {
            return new M34l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], (long)a[0, 3], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], (long)a[1, 3], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2], (long)a[2, 3]);
        }

        public static explicit operator int[](M34l m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03, 
                (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13, 
                (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23
            };
        }

        public static explicit operator int[,](M34l m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M03;
            array[index + 4] = (int)M10;
            array[index + 5] = (int)M11;
            array[index + 6] = (int)M12;
            array[index + 7] = (int)M13;
            array[index + 8] = (int)M20;
            array[index + 9] = (int)M21;
            array[index + 10] = (int)M22;
            array[index + 11] = (int)M23;
        }

        public static explicit operator M34l(long[] a)
        {
            return new M34l(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11]);
        }

        public static explicit operator M34l(long[,] a)
        {
            return new M34l(
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3]);
        }

        public static explicit operator long[](M34l m)
        {
            return new long[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23
            };
        }

        public static explicit operator long[,](M34l m)
        {
            return new long[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
        }

        public static explicit operator M34l(float[] a)
        {
            return new M34l(
                (long)a[0], (long)a[1], (long)a[2], (long)a[3], 
                (long)a[4], (long)a[5], (long)a[6], (long)a[7], 
                (long)a[8], (long)a[9], (long)a[10], (long)a[11]);
        }

        public static explicit operator M34l(float[,] a)
        {
            return new M34l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], (long)a[0, 3], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], (long)a[1, 3], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2], (long)a[2, 3]);
        }

        public static explicit operator float[](M34l m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03, 
                (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13, 
                (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23
            };
        }

        public static explicit operator float[,](M34l m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M03;
            array[index + 4] = (float)M10;
            array[index + 5] = (float)M11;
            array[index + 6] = (float)M12;
            array[index + 7] = (float)M13;
            array[index + 8] = (float)M20;
            array[index + 9] = (float)M21;
            array[index + 10] = (float)M22;
            array[index + 11] = (float)M23;
        }

        public static explicit operator M34l(double[] a)
        {
            return new M34l(
                (long)a[0], (long)a[1], (long)a[2], (long)a[3], 
                (long)a[4], (long)a[5], (long)a[6], (long)a[7], 
                (long)a[8], (long)a[9], (long)a[10], (long)a[11]);
        }

        public static explicit operator M34l(double[,] a)
        {
            return new M34l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], (long)a[0, 3], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], (long)a[1, 3], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2], (long)a[2, 3]);
        }

        public static explicit operator double[](M34l m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03, 
                (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13, 
                (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23
            };
        }

        public static explicit operator double[,](M34l m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M03;
            array[index + 4] = (double)M10;
            array[index + 5] = (double)M11;
            array[index + 6] = (double)M12;
            array[index + 7] = (double)M13;
            array[index + 8] = (double)M20;
            array[index + 9] = (double)M21;
            array[index + 10] = (double)M22;
            array[index + 11] = (double)M23;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<long, int> element_fun)
        {
            return new M34i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<long, int, int, int> element_index0_index1_fun)
        {
            return new M34i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<long, long> element_fun)
        {
            return new M34l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<long, int, int, long> element_index0_index1_fun)
        {
            return new M34l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<long, float> element_fun)
        {
            return new M34f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<long, int, int, float> element_index0_index1_fun)
        {
            return new M34f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<long, double> element_fun)
        {
            return new M34d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<long, int, int, double> element_index0_index1_fun)
        {
            return new M34d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        public long[] ToArray()
        {
            var array = new long[12];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l FromCols(V3l col0, V3l col1, V3l col2, V3l col3)
        {
            return new M34l(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l FromRows(V4l row0, V4l row1, V4l row2)
        {
            return new M34l(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M34l"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l Scale(long tX, long tY, long tZ)
        {
            return new M34l(
                tX, 0, 0, 0, 
                0, tY, 0, 0, 
                0, 0, tZ, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34l"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l Scale(long tX, long tY)
        {
            return new M34l(
                tX, 0, 0, 0, 
                0, tY, 0, 0, 
                0, 0, 1, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34l"/> using a <see cref="V4l"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l Scale(V4l s)
        {
            return new M34l(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34l"/> using a <see cref="V3l"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l Scale(V3l s)
        {
            return new M34l(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, 1, 0);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M34l"/> with the translational component given by 3 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l Translation(long tX, long tY, long tZ)
        {
            return new M34l(
                1, 0, 0, tX, 
                0, 1, 0, tY, 
                0, 0, 1, tZ);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34l"/> with the translational component given by a <see cref="V3l"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l Translation(V3l t)
        {
            return new M34l(
                1, 0, 0, t.X, 
                0, 1, 0, t.Y, 
                0, 0, 1, t.Z);
        }

        #endregion

        #region Shearing

        public static M34l ShearXY(long factorX, long factorY)
        {
            return new M34l(
                1, 0, factorX, 0, 
                0, 1, factorY, 0, 
                0, 0, 1, 0);
        }

        public static M34l ShearXZ(long factorX, long factorZ)
        {
            return new M34l(
                1, factorX, 0, 0, 
                0, 1, 0, 0, 
                0, factorZ, 1, 0);
        }

        public static M34l ShearYZ(long factorY, long factorZ)
        {
            return new M34l(
                1, 0, 0, 0, 
                factorY, 1, 0, 0, 
                factorZ, 0, 1, 0);
        }

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<long> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M03;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M13;
                yield return M20;
                yield return M21;
                yield return M22;
                yield return M23;
            }
        }

        public IEnumerable<V4l> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3l> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        public V4l R0
        {
            get { return new V4l( M00,  M01,  M02,  M03); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        public V4l R1
        {
            get { return new V4l( M10,  M11,  M12,  M13); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        public V4l R2
        {
            get { return new V4l( M20,  M21,  M22,  M23); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        public V3l C0
        {
            get { return new V3l( M00,  M10,  M20); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        public V3l C1
        {
            get { return new V3l( M01,  M11,  M21); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        public V3l C2
        {
            get { return new V3l( M02,  M12,  M22); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public V3l C3
        {
            get { return new V3l( M03,  M13,  M23); }
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
            }
        }

        public long this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M03;
                    case 4: return M10;
                    case 5: return M11;
                    case 6: return M12;
                    case 7: return M13;
                    case 8: return M20;
                    case 9: return M21;
                    case 10: return M22;
                    case 11: return M23;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M03 = value; return;
                    case 4: M10 = value; return;
                    case 5: M11 = value; return;
                    case 6: M12 = value; return;
                    case 7: M13 = value; return;
                    case 8: M20 = value; return;
                    case 9: M21 = value; return;
                    case 10: M22 = value; return;
                    case 11: M23 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public long this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            case 2: return M02;
                            case 3: return M03;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            case 2: return M12;
                            case 3: return M13;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: return M20;
                            case 1: return M21;
                            case 2: return M22;
                            case 3: return M23;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            case 2: M02 = value; return;
                            case 3: M03 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            case 2: M12 = value; return;
                            case 3: M13 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: M20 = value; return;
                            case 1: M21 = value; return;
                            case 2: M22 = value; return;
                            case 3: M23 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 4;
        public const int ElementCount = 3 * 4;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(3, 4);
        }

        public static M34l Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M34l(0);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public long Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public long NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public long NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M34l operator -(M34l m)
        {
            return new M34l(
                -m.M00, -m.M01, -m.M02, -m.M03, 
                -m.M10, -m.M11, -m.M12, -m.M13, 
                -m.M20, -m.M21, -m.M22, -m.M23);
        }

        public static M34l operator  + (M34l a, M34l b)
        {
            return new M34l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34l operator  + (M34l m, long s)
        {
            return new M34l(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        public static M34l operator  + (long s, M34l m)
        {
            return new M34l(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34f operator  + (M34l a, M34f b)
        {
            return new M34f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34f operator  + (M34l m, float s)
        {
            return new M34f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        public static M34f operator  + (float s, M34l m)
        {
            return new M34f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34d operator  + (M34l a, M34d b)
        {
            return new M34d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34d operator  + (M34l m, double s)
        {
            return new M34d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        public static M34d operator  + (double s, M34l m)
        {
            return new M34d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34l operator  - (M34l a, M34l b)
        {
            return new M34l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34l operator  - (M34l m, long s)
        {
            return new M34l(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        public static M34l operator  - (long s, M34l m)
        {
            return new M34l(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34f operator  - (M34l a, M34f b)
        {
            return new M34f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34f operator  - (M34l m, float s)
        {
            return new M34f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        public static M34f operator  - (float s, M34l m)
        {
            return new M34f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34d operator  - (M34l a, M34d b)
        {
            return new M34d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34d operator  - (M34l m, double s)
        {
            return new M34d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        public static M34d operator  - (double s, M34l m)
        {
            return new M34d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34l operator  % (M34l a, M34l b)
        {
            return new M34l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34l operator  % (M34l m, long s)
        {
            return new M34l(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        public static M34l operator  % (long s, M34l m)
        {
            return new M34l(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34f operator  % (M34l a, M34f b)
        {
            return new M34f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34f operator  % (M34l m, float s)
        {
            return new M34f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        public static M34f operator  % (float s, M34l m)
        {
            return new M34f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34d operator  % (M34l a, M34d b)
        {
            return new M34d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34d operator  % (M34l m, double s)
        {
            return new M34d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        public static M34d operator  % (double s, M34l m)
        {
            return new M34d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34l operator  / (M34l a, M34l b)
        {
            return new M34l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34l operator  / (M34l m, long s)
        {
            return new M34l(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        public static M34l operator  / (long s, M34l m)
        {
            return new M34l(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34f operator  / (M34l a, M34f b)
        {
            return new M34f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34f operator  / (M34l m, float s)
        {
            return new M34f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        public static M34f operator  / (float s, M34l m)
        {
            return new M34f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34d operator  / (M34l a, M34d b)
        {
            return new M34d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34d operator  / (M34l m, double s)
        {
            return new M34d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        public static M34d operator  / (double s, M34l m)
        {
            return new M34d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34l operator  * (M34l m, long s)
        {
            return new M34l(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        public static M34l operator  * (long s, M34l m)
        {
            return new M34l(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34f operator  * (M34l m, float s)
        {
            return new M34f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        public static M34f operator  * (float s, M34l m)
        {
            return new M34f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34d operator  * (M34l m, double s)
        {
            return new M34d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        public static M34d operator  * (double s, M34l m)
        {
            return new M34d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M34l matrix with a V4l column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l operator *(M34l m, V4l v)
        {
            return new V3l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W);
        }

        /// <summary>
        /// Multiplies a V3l row vector with a M34l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l operator *(V3l v, M34l m)
        {
            return new V4l(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M34l a, M34l b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23;
        }

        public static bool operator <(M34l a, long s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s;
        }

        public static bool operator <(long s, M34l a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23 ;
        }

        public static bool operator >(M34l a, M34l b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23;
        }

        public static bool operator >(M34l a, long s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s;
        }

        public static bool operator >(long s, M34l a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23 ;
        }

        public static bool operator ==(M34l a, M34l b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23;
        }

        public static bool operator ==(M34l a, long s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s;
        }

        public static bool operator ==(long s, M34l a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23 ;
        }

        public static bool operator <=(M34l a, M34l b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23;
        }

        public static bool operator <=(M34l a, long s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s;
        }

        public static bool operator <=(long s, M34l a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23 ;
        }

        public static bool operator >=(M34l a, M34l b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23;
        }

        public static bool operator >=(M34l a, long s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s;
        }

        public static bool operator >=(long s, M34l a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23 ;
        }

        public static bool operator !=(M34l a, M34l b)
        {
            return !(a == b);
        }

        public static bool operator !=(M34l m, long s)
        {
            return !(m == s);
        }

        public static bool operator !=(long s, M34l m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), M03.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), M13.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode(), M23.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M34l) ? (this == (M34l)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M34l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M34l.FromRows(
                V4l.Parse(x[0]), 
                V4l.Parse(x[1]), 
                V4l.Parse(x[2])
            );
        }

        #endregion

        #region Matrix Operations

        #endregion

        #region Matrix Multiplication

        public static M34l operator *(M33l a, M34l b)
        {
            return new M34l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23
             );
        }

        public static M34l operator *(M34l a, M44l b)
        {
            return new M34l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (long)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (long)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (long)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (long)value;
        }

        #endregion
    }

    public class M34lEqualityComparer : IEqualityComparer<M34l>
    {
        public static readonly M34lEqualityComparer Default
            = new M34lEqualityComparer();

        #region IEqualityComparer<M34l> Members

        public bool Equals(M34l v0, M34l v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M34l v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Norm1(M34l m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M34l m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMax(M34l m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMin(M34l m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M34l m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M03).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M13).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p) + 
                Fun.Abs(m.M23).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static long Distance1(this M34l a, M34l b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M34l a, M34l b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M34l a, M34l b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMax(this M34l a, M34l b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMin(this M34l a, M34l b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l Transform(this M34l m, V4l v)
            => m * v;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l TransposedTransform(this M34l m, V3l v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by matrix m.
        /// </summary>
        public static V3l TransformDir(this M34l m, V3l v)
        {
            return new V3l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by matrix m.
        /// </summary>
        public static V3l TransformPos(this M34l m, V3l p)
        {
            return new V3l(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l Row(this M34l m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                case 2: return m.R2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l Column(this M34l m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                case 2: return m.C2;
                case 3: return m.C3;
                default: throw new IndexOutOfRangeException();
            }
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M34l a, M34l b, long epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M34f

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M34f : IValidity, IMatrix<double>
    {
        [DataMember]
        public float M00, M01, M02, M03;
        [DataMember]
        public float M10, M11, M12, M13;
        [DataMember]
        public float M20, M21, M22, M23;

        #region Constructors

        public M34f(float value)
        {
            M00 = value; M01 = value; M02 = value; M03 = value; 
            M10 = value; M11 = value; M12 = value; M13 = value; 
            M20 = value; M21 = value; M22 = value; M23 = value; 
        }

        public M34f(
                float m00, float m01, float m02, float m03, 
                float m10, float m11, float m12, float m13, 
                float m20, float m21, float m22, float m23)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
        }

        public M34f(float[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
        }

        public M34f(float[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
        }

        public M34f(M33f m, V3f v)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = v.X; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = v.Y; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = v.Z; 
        }

        public M34f(M22i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34f(M23i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34f(M33i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = 0; 
        }

        public M34f(M34i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
        }

        public M34f(M44i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
        }

        public M34f(M22l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34f(M23l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34f(M33l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = 0; 
        }

        public M34f(M34l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
        }

        public M34f(M44l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
        }

        public M34f(M22f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34f(M23f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34f(M33f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = 0; 
        }

        public M34f(M44f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = m.M03; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = m.M13; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = m.M23; 
        }

        public M34f(M22d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34f(M23d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34f(M33d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = 0; 
        }

        public M34f(M34d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
        }

        public M34f(M44d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
        }

        #endregion

        #region Conversions

        public static explicit operator M34f(M22i m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M23i m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M33i m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34f(M34i m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
            };
        }

        public static explicit operator M34f(M44i m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
            };
        }

        public static explicit operator M34f(M22l m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M23l m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M33l m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34f(M34l m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
            };
        }

        public static explicit operator M34f(M44l m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
            };
        }

        public static explicit operator M34f(M22f m)
        {
            return new M34f {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M23f m)
        {
            return new M34f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M33f m)
        {
            return new M34f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34f(M44f m)
        {
            return new M34f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
            };
        }

        public static explicit operator M34f(M22d m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M23d m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M33d m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34f(M34d m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
            };
        }

        public static explicit operator M34f(M44d m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
            };
        }

        public static explicit operator M34f(int[] a)
        {
            return new M34f(
                (float)a[0], (float)a[1], (float)a[2], (float)a[3], 
                (float)a[4], (float)a[5], (float)a[6], (float)a[7], 
                (float)a[8], (float)a[9], (float)a[10], (float)a[11]);
        }

        public static explicit operator M34f(int[,] a)
        {
            return new M34f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], (float)a[0, 3], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], (float)a[1, 3], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2], (float)a[2, 3]);
        }

        public static explicit operator int[](M34f m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03, 
                (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13, 
                (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23
            };
        }

        public static explicit operator int[,](M34f m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M03;
            array[index + 4] = (int)M10;
            array[index + 5] = (int)M11;
            array[index + 6] = (int)M12;
            array[index + 7] = (int)M13;
            array[index + 8] = (int)M20;
            array[index + 9] = (int)M21;
            array[index + 10] = (int)M22;
            array[index + 11] = (int)M23;
        }

        public static explicit operator M34f(long[] a)
        {
            return new M34f(
                (float)a[0], (float)a[1], (float)a[2], (float)a[3], 
                (float)a[4], (float)a[5], (float)a[6], (float)a[7], 
                (float)a[8], (float)a[9], (float)a[10], (float)a[11]);
        }

        public static explicit operator M34f(long[,] a)
        {
            return new M34f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], (float)a[0, 3], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], (float)a[1, 3], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2], (float)a[2, 3]);
        }

        public static explicit operator long[](M34f m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03, 
                (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13, 
                (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23
            };
        }

        public static explicit operator long[,](M34f m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M03;
            array[index + 4] = (long)M10;
            array[index + 5] = (long)M11;
            array[index + 6] = (long)M12;
            array[index + 7] = (long)M13;
            array[index + 8] = (long)M20;
            array[index + 9] = (long)M21;
            array[index + 10] = (long)M22;
            array[index + 11] = (long)M23;
        }

        public static explicit operator M34f(float[] a)
        {
            return new M34f(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11]);
        }

        public static explicit operator M34f(float[,] a)
        {
            return new M34f(
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3]);
        }

        public static explicit operator float[](M34f m)
        {
            return new float[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23
            };
        }

        public static explicit operator float[,](M34f m)
        {
            return new float[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
        }

        public static explicit operator M34f(double[] a)
        {
            return new M34f(
                (float)a[0], (float)a[1], (float)a[2], (float)a[3], 
                (float)a[4], (float)a[5], (float)a[6], (float)a[7], 
                (float)a[8], (float)a[9], (float)a[10], (float)a[11]);
        }

        public static explicit operator M34f(double[,] a)
        {
            return new M34f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], (float)a[0, 3], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], (float)a[1, 3], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2], (float)a[2, 3]);
        }

        public static explicit operator double[](M34f m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03, 
                (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13, 
                (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23
            };
        }

        public static explicit operator double[,](M34f m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M03;
            array[index + 4] = (double)M10;
            array[index + 5] = (double)M11;
            array[index + 6] = (double)M12;
            array[index + 7] = (double)M13;
            array[index + 8] = (double)M20;
            array[index + 9] = (double)M21;
            array[index + 10] = (double)M22;
            array[index + 11] = (double)M23;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<float, int> element_fun)
        {
            return new M34i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<float, int, int, int> element_index0_index1_fun)
        {
            return new M34i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<float, long> element_fun)
        {
            return new M34l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<float, int, int, long> element_index0_index1_fun)
        {
            return new M34l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<float, float> element_fun)
        {
            return new M34f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<float, int, int, float> element_index0_index1_fun)
        {
            return new M34f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<float, double> element_fun)
        {
            return new M34d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<float, int, int, double> element_index0_index1_fun)
        {
            return new M34d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        public float[] ToArray()
        {
            var array = new float[12];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f FromCols(V3f col0, V3f col1, V3f col2, V3f col3)
        {
            return new M34f(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f FromRows(V4f row0, V4f row1, V4f row2)
        {
            return new M34f(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M34f"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f Scale(float tX, float tY, float tZ)
        {
            return new M34f(
                tX, 0, 0, 0, 
                0, tY, 0, 0, 
                0, 0, tZ, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34f"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f Scale(float tX, float tY)
        {
            return new M34f(
                tX, 0, 0, 0, 
                0, tY, 0, 0, 
                0, 0, 1, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34f"/> using a <see cref="V4f"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f Scale(V4f s)
        {
            return new M34f(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34f"/> using a <see cref="V3f"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f Scale(V3f s)
        {
            return new M34f(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, 1, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34f"/> from a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f Scale(Scale3f s)
        {
            return new M34f(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M34f"/> with the translational component given by 3 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f Translation(float tX, float tY, float tZ)
        {
            return new M34f(
                1, 0, 0, tX, 
                0, 1, 0, tY, 
                0, 0, 1, tZ);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34f"/> with the translational component given by a <see cref="V3f"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f Translation(V3f t)
        {
            return new M34f(
                1, 0, 0, t.X, 
                0, 1, 0, t.Y, 
                0, 0, 1, t.Z);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34f"/> from a <see cref="Shift3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f Translation(Shift3f s)
        {
            return new M34f(
                1, 0, 0, s.X, 
                0, 1, 0, s.Y, 
                0, 0, 1, s.Z);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 3D rotation matrix from an axis vector and an angle in radians.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f Rotation(V3f normalizedAxis, float angleInRadians)
        {
            Debug.Assert(normalizedAxis.LengthSquared.ApproximateEquals(1));
            return (M34f)(Rot3f.Rotation(normalizedAxis, angleInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z). 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f RotationEuler(float rollInRadians, float pitchInRadians, float yawInRadians)
        {
            return (M34f)(Rot3f.RotationEuler(rollInRadians, pitchInRadians, yawInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) Vector.
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f RotationEuler(V3f roll_pitch_yaw_inRadians)
        {
            return (M34f)(Rot3f.RotationEuler(
                roll_pitch_yaw_inRadians.X,
                roll_pitch_yaw_inRadians.Y,
                roll_pitch_yaw_inRadians.Z));
        }

        /// <summary>
        /// Creates a 3D rotation matrix which rotates one vector into another.
        /// The input vectors have to be normalized.
        /// </summary>
        public static M34f RotateInto(V3f from, V3f into)
        {
            Debug.Assert(from.LengthSquared.ApproximateEquals(1));
            Debug.Assert(into.LengthSquared.ApproximateEquals(1));
            return (M34f)(Rot3f.RotateInto(from, into));
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the X-Axis.
        /// </summary>
        public static M34f RotationX(float angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M34f(
                 1,  0,  0,  0, 
                 0,  a, -b,  0, 
                 0,  b,  a,  0);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the Y-Axis.
        /// </summary>
        public static M34f RotationY(float angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M34f(
                 a,  0,  b,  0, 
                 0,  1,  0,  0, 
                -b,  0,  a,  0);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the Z-Axis.
        /// </summary>
        public static M34f RotationZ(float angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M34f(
                 a, -b,  0,  0, 
                 b,  a,  0,  0, 
                 0,  0,  1,  0);
        }

        #endregion

        #region Shearing

        public static M34f ShearXY(float factorX, float factorY)
        {
            return new M34f(
                1, 0, factorX, 0, 
                0, 1, factorY, 0, 
                0, 0, 1, 0);
        }

        public static M34f ShearXZ(float factorX, float factorZ)
        {
            return new M34f(
                1, factorX, 0, 0, 
                0, 1, 0, 0, 
                0, factorZ, 1, 0);
        }

        public static M34f ShearYZ(float factorY, float factorZ)
        {
            return new M34f(
                1, 0, 0, 0, 
                factorY, 1, 0, 0, 
                factorZ, 0, 1, 0);
        }

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<float> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M03;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M13;
                yield return M20;
                yield return M21;
                yield return M22;
                yield return M23;
            }
        }

        public IEnumerable<V4f> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3f> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        public V4f R0
        {
            get { return new V4f( M00,  M01,  M02,  M03); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        public V4f R1
        {
            get { return new V4f( M10,  M11,  M12,  M13); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        public V4f R2
        {
            get { return new V4f( M20,  M21,  M22,  M23); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        public V3f C0
        {
            get { return new V3f( M00,  M10,  M20); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        public V3f C1
        {
            get { return new V3f( M01,  M11,  M21); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        public V3f C2
        {
            get { return new V3f( M02,  M12,  M22); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public V3f C3
        {
            get { return new V3f( M03,  M13,  M23); }
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
            }
        }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M03;
                    case 4: return M10;
                    case 5: return M11;
                    case 6: return M12;
                    case 7: return M13;
                    case 8: return M20;
                    case 9: return M21;
                    case 10: return M22;
                    case 11: return M23;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M03 = value; return;
                    case 4: M10 = value; return;
                    case 5: M11 = value; return;
                    case 6: M12 = value; return;
                    case 7: M13 = value; return;
                    case 8: M20 = value; return;
                    case 9: M21 = value; return;
                    case 10: M22 = value; return;
                    case 11: M23 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public float this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            case 2: return M02;
                            case 3: return M03;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            case 2: return M12;
                            case 3: return M13;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: return M20;
                            case 1: return M21;
                            case 2: return M22;
                            case 3: return M23;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            case 2: M02 = value; return;
                            case 3: M03 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            case 2: M12 = value; return;
                            case 3: M13 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: M20 = value; return;
                            case 1: M21 = value; return;
                            case 2: M22 = value; return;
                            case 3: M23 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 4;
        public const int ElementCount = 3 * 4;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(3, 4);
        }

        public static M34f Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M34f(0);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public float Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public float Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public float NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public float NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M34f operator -(M34f m)
        {
            return new M34f(
                -m.M00, -m.M01, -m.M02, -m.M03, 
                -m.M10, -m.M11, -m.M12, -m.M13, 
                -m.M20, -m.M21, -m.M22, -m.M23);
        }

        public static M34f operator  + (M34f a, M34f b)
        {
            return new M34f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34f operator  + (M34f m, float s)
        {
            return new M34f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        public static M34f operator  + (float s, M34f m)
        {
            return new M34f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34d operator  + (M34f a, M34d b)
        {
            return new M34d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34d operator  + (M34f m, double s)
        {
            return new M34d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        public static M34d operator  + (double s, M34f m)
        {
            return new M34d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34f operator  - (M34f a, M34f b)
        {
            return new M34f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34f operator  - (M34f m, float s)
        {
            return new M34f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        public static M34f operator  - (float s, M34f m)
        {
            return new M34f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34d operator  - (M34f a, M34d b)
        {
            return new M34d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34d operator  - (M34f m, double s)
        {
            return new M34d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        public static M34d operator  - (double s, M34f m)
        {
            return new M34d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34f operator  % (M34f a, M34f b)
        {
            return new M34f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34f operator  % (M34f m, float s)
        {
            return new M34f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        public static M34f operator  % (float s, M34f m)
        {
            return new M34f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34d operator  % (M34f a, M34d b)
        {
            return new M34d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34d operator  % (M34f m, double s)
        {
            return new M34d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        public static M34d operator  % (double s, M34f m)
        {
            return new M34d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34f operator  / (M34f a, M34f b)
        {
            return new M34f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34f operator  / (M34f m, float s)
        {
            return new M34f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        public static M34f operator  / (float s, M34f m)
        {
            return new M34f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34d operator  / (M34f a, M34d b)
        {
            return new M34d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34d operator  / (M34f m, double s)
        {
            return new M34d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        public static M34d operator  / (double s, M34f m)
        {
            return new M34d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34f operator  * (M34f m, float s)
        {
            return new M34f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        public static M34f operator  * (float s, M34f m)
        {
            return new M34f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34d operator  * (M34f m, double s)
        {
            return new M34d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        public static M34d operator  * (double s, M34f m)
        {
            return new M34d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M34f matrix with a V4f column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f operator *(M34f m, V4f v)
        {
            return new V3f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W);
        }

        /// <summary>
        /// Multiplies a V3f row vector with a M34f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f operator *(V3f v, M34f m)
        {
            return new V4f(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M34f a, M34f b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23;
        }

        public static bool operator <(M34f a, float s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s;
        }

        public static bool operator <(float s, M34f a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23 ;
        }

        public static bool operator >(M34f a, M34f b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23;
        }

        public static bool operator >(M34f a, float s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s;
        }

        public static bool operator >(float s, M34f a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23 ;
        }

        public static bool operator ==(M34f a, M34f b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23;
        }

        public static bool operator ==(M34f a, float s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s;
        }

        public static bool operator ==(float s, M34f a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23 ;
        }

        public static bool operator <=(M34f a, M34f b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23;
        }

        public static bool operator <=(M34f a, float s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s;
        }

        public static bool operator <=(float s, M34f a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23 ;
        }

        public static bool operator >=(M34f a, M34f b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23;
        }

        public static bool operator >=(M34f a, float s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s;
        }

        public static bool operator >=(float s, M34f a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23 ;
        }

        public static bool operator !=(M34f a, M34f b)
        {
            return !(a == b);
        }

        public static bool operator !=(M34f m, float s)
        {
            return !(m == s);
        }

        public static bool operator !=(float s, M34f m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), M03.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), M13.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode(), M23.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M34f) ? (this == (M34f)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M34f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M34f.FromRows(
                V4f.Parse(x[0]), 
                V4f.Parse(x[1]), 
                V4f.Parse(x[2])
            );
        }

        #endregion

        #region Matrix Operations

        #endregion

        #region Matrix Multiplication

        public static M34f operator *(M33f a, M34f b)
        {
            return new M34f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23
             );
        }

        public static M34f operator *(M34f a, M44f b)
        {
            return new M34f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (float)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (float)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (float)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (float)value;
        }

        #endregion
    }

    public class M34fEqualityComparer : IEqualityComparer<M34f>
    {
        public static readonly M34fEqualityComparer Default
            = new M34fEqualityComparer();

        #region IEqualityComparer<M34f> Members

        public bool Equals(M34f v0, M34f v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M34f v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm1(M34f m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm2(M34f m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMax(M34f m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMin(M34f m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm(this M34f m, float p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M03).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M13).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p) + 
                Fun.Abs(m.M23).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static float Distance1(this M34f a, M34f b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static float Distance2(this M34f a, M34f b)
        {
            return (float)Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static float Distance(this M34f a, M34f b, float p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMax(this M34f a, M34f b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMin(this M34f a, M34f b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Transform(this M34f m, V4f v)
            => m * v;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f TransposedTransform(this M34f m, V3f v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by matrix m.
        /// </summary>
        public static V3f TransformDir(this M34f m, V3f v)
        {
            return new V3f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by matrix m.
        /// </summary>
        public static V3f TransformPos(this M34f m, V3f p)
        {
            return new V3f(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f Row(this M34f m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                case 2: return m.R2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Column(this M34f m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                case 2: return m.C2;
                case 3: return m.C3;
                default: throw new IndexOutOfRangeException();
            }
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M34f a, M34f b, float epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M34d

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M34d : IValidity, IMatrix<double>
    {
        [DataMember]
        public double M00, M01, M02, M03;
        [DataMember]
        public double M10, M11, M12, M13;
        [DataMember]
        public double M20, M21, M22, M23;

        #region Constructors

        public M34d(double value)
        {
            M00 = value; M01 = value; M02 = value; M03 = value; 
            M10 = value; M11 = value; M12 = value; M13 = value; 
            M20 = value; M21 = value; M22 = value; M23 = value; 
        }

        public M34d(
                double m00, double m01, double m02, double m03, 
                double m10, double m11, double m12, double m13, 
                double m20, double m21, double m22, double m23)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
        }

        public M34d(double[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
        }

        public M34d(double[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
        }

        public M34d(M33d m, V3d v)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = v.X; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = v.Y; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = v.Z; 
        }

        public M34d(M22i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34d(M23i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34d(M33i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = 0; 
        }

        public M34d(M34i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
        }

        public M34d(M44i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
        }

        public M34d(M22l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34d(M23l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34d(M33l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = 0; 
        }

        public M34d(M34l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
        }

        public M34d(M44l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
        }

        public M34d(M22f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34d(M23f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34d(M33f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = 0; 
        }

        public M34d(M34f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
        }

        public M34d(M44f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
        }

        public M34d(M22d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34d(M23d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        public M34d(M33d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = 0; 
        }

        public M34d(M44d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = m.M03; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = m.M13; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = m.M23; 
        }

        #endregion

        #region Conversions

        public static explicit operator M34d(M22i m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M23i m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M33i m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34d(M34i m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
            };
        }

        public static explicit operator M34d(M44i m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
            };
        }

        public static explicit operator M34d(M22l m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M23l m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M33l m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34d(M34l m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
            };
        }

        public static explicit operator M34d(M44l m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
            };
        }

        public static explicit operator M34d(M22f m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M23f m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M33f m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34d(M34f m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
            };
        }

        public static explicit operator M34d(M44f m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
            };
        }

        public static explicit operator M34d(M22d m)
        {
            return new M34d {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M23d m)
        {
            return new M34d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M33d m)
        {
            return new M34d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34d(M44d m)
        {
            return new M34d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
            };
        }

        public static explicit operator M34d(int[] a)
        {
            return new M34d(
                (double)a[0], (double)a[1], (double)a[2], (double)a[3], 
                (double)a[4], (double)a[5], (double)a[6], (double)a[7], 
                (double)a[8], (double)a[9], (double)a[10], (double)a[11]);
        }

        public static explicit operator M34d(int[,] a)
        {
            return new M34d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], (double)a[0, 3], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], (double)a[1, 3], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2], (double)a[2, 3]);
        }

        public static explicit operator int[](M34d m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03, 
                (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13, 
                (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23
            };
        }

        public static explicit operator int[,](M34d m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M03;
            array[index + 4] = (int)M10;
            array[index + 5] = (int)M11;
            array[index + 6] = (int)M12;
            array[index + 7] = (int)M13;
            array[index + 8] = (int)M20;
            array[index + 9] = (int)M21;
            array[index + 10] = (int)M22;
            array[index + 11] = (int)M23;
        }

        public static explicit operator M34d(long[] a)
        {
            return new M34d(
                (double)a[0], (double)a[1], (double)a[2], (double)a[3], 
                (double)a[4], (double)a[5], (double)a[6], (double)a[7], 
                (double)a[8], (double)a[9], (double)a[10], (double)a[11]);
        }

        public static explicit operator M34d(long[,] a)
        {
            return new M34d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], (double)a[0, 3], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], (double)a[1, 3], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2], (double)a[2, 3]);
        }

        public static explicit operator long[](M34d m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03, 
                (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13, 
                (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23
            };
        }

        public static explicit operator long[,](M34d m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M03;
            array[index + 4] = (long)M10;
            array[index + 5] = (long)M11;
            array[index + 6] = (long)M12;
            array[index + 7] = (long)M13;
            array[index + 8] = (long)M20;
            array[index + 9] = (long)M21;
            array[index + 10] = (long)M22;
            array[index + 11] = (long)M23;
        }

        public static explicit operator M34d(float[] a)
        {
            return new M34d(
                (double)a[0], (double)a[1], (double)a[2], (double)a[3], 
                (double)a[4], (double)a[5], (double)a[6], (double)a[7], 
                (double)a[8], (double)a[9], (double)a[10], (double)a[11]);
        }

        public static explicit operator M34d(float[,] a)
        {
            return new M34d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], (double)a[0, 3], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], (double)a[1, 3], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2], (double)a[2, 3]);
        }

        public static explicit operator float[](M34d m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03, 
                (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13, 
                (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23
            };
        }

        public static explicit operator float[,](M34d m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M03;
            array[index + 4] = (float)M10;
            array[index + 5] = (float)M11;
            array[index + 6] = (float)M12;
            array[index + 7] = (float)M13;
            array[index + 8] = (float)M20;
            array[index + 9] = (float)M21;
            array[index + 10] = (float)M22;
            array[index + 11] = (float)M23;
        }

        public static explicit operator M34d(double[] a)
        {
            return new M34d(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11]);
        }

        public static explicit operator M34d(double[,] a)
        {
            return new M34d(
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3]);
        }

        public static explicit operator double[](M34d m)
        {
            return new double[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23
            };
        }

        public static explicit operator double[,](M34d m)
        {
            return new double[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<double, int> element_fun)
        {
            return new M34i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<double, int, int, int> element_index0_index1_fun)
        {
            return new M34i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<double, long> element_fun)
        {
            return new M34l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<double, int, int, long> element_index0_index1_fun)
        {
            return new M34l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<double, float> element_fun)
        {
            return new M34f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<double, int, int, float> element_index0_index1_fun)
        {
            return new M34f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<double, double> element_fun)
        {
            return new M34d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<double, int, int, double> element_index0_index1_fun)
        {
            return new M34d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        public double[] ToArray()
        {
            var array = new double[12];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d FromCols(V3d col0, V3d col1, V3d col2, V3d col3)
        {
            return new M34d(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d FromRows(V4d row0, V4d row1, V4d row2)
        {
            return new M34d(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M34d"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d Scale(double tX, double tY, double tZ)
        {
            return new M34d(
                tX, 0, 0, 0, 
                0, tY, 0, 0, 
                0, 0, tZ, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34d"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d Scale(double tX, double tY)
        {
            return new M34d(
                tX, 0, 0, 0, 
                0, tY, 0, 0, 
                0, 0, 1, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34d"/> using a <see cref="V4d"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d Scale(V4d s)
        {
            return new M34d(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34d"/> using a <see cref="V3d"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d Scale(V3d s)
        {
            return new M34d(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, 1, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34d"/> from a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d Scale(Scale3d s)
        {
            return new M34d(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M34d"/> with the translational component given by 3 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d Translation(double tX, double tY, double tZ)
        {
            return new M34d(
                1, 0, 0, tX, 
                0, 1, 0, tY, 
                0, 0, 1, tZ);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34d"/> with the translational component given by a <see cref="V3d"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d Translation(V3d t)
        {
            return new M34d(
                1, 0, 0, t.X, 
                0, 1, 0, t.Y, 
                0, 0, 1, t.Z);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34d"/> from a <see cref="Shift3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d Translation(Shift3d s)
        {
            return new M34d(
                1, 0, 0, s.X, 
                0, 1, 0, s.Y, 
                0, 0, 1, s.Z);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 3D rotation matrix from an axis vector and an angle in radians.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d Rotation(V3d normalizedAxis, double angleInRadians)
        {
            Debug.Assert(normalizedAxis.LengthSquared.ApproximateEquals(1));
            return (M34d)(Rot3d.Rotation(normalizedAxis, angleInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z). 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d RotationEuler(double rollInRadians, double pitchInRadians, double yawInRadians)
        {
            return (M34d)(Rot3d.RotationEuler(rollInRadians, pitchInRadians, yawInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) Vector.
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d RotationEuler(V3d roll_pitch_yaw_inRadians)
        {
            return (M34d)(Rot3d.RotationEuler(
                roll_pitch_yaw_inRadians.X,
                roll_pitch_yaw_inRadians.Y,
                roll_pitch_yaw_inRadians.Z));
        }

        /// <summary>
        /// Creates a 3D rotation matrix which rotates one vector into another.
        /// The input vectors have to be normalized.
        /// </summary>
        public static M34d RotateInto(V3d from, V3d into)
        {
            Debug.Assert(from.LengthSquared.ApproximateEquals(1));
            Debug.Assert(into.LengthSquared.ApproximateEquals(1));
            return (M34d)(Rot3d.RotateInto(from, into));
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the X-Axis.
        /// </summary>
        public static M34d RotationX(double angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M34d(
                 1,  0,  0,  0, 
                 0,  a, -b,  0, 
                 0,  b,  a,  0);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the Y-Axis.
        /// </summary>
        public static M34d RotationY(double angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M34d(
                 a,  0,  b,  0, 
                 0,  1,  0,  0, 
                -b,  0,  a,  0);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the Z-Axis.
        /// </summary>
        public static M34d RotationZ(double angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M34d(
                 a, -b,  0,  0, 
                 b,  a,  0,  0, 
                 0,  0,  1,  0);
        }

        #endregion

        #region Shearing

        public static M34d ShearXY(double factorX, double factorY)
        {
            return new M34d(
                1, 0, factorX, 0, 
                0, 1, factorY, 0, 
                0, 0, 1, 0);
        }

        public static M34d ShearXZ(double factorX, double factorZ)
        {
            return new M34d(
                1, factorX, 0, 0, 
                0, 1, 0, 0, 
                0, factorZ, 1, 0);
        }

        public static M34d ShearYZ(double factorY, double factorZ)
        {
            return new M34d(
                1, 0, 0, 0, 
                factorY, 1, 0, 0, 
                factorZ, 0, 1, 0);
        }

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<double> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M03;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M13;
                yield return M20;
                yield return M21;
                yield return M22;
                yield return M23;
            }
        }

        public IEnumerable<V4d> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3d> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        public V4d R0
        {
            get { return new V4d( M00,  M01,  M02,  M03); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        public V4d R1
        {
            get { return new V4d( M10,  M11,  M12,  M13); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        public V4d R2
        {
            get { return new V4d( M20,  M21,  M22,  M23); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        public V3d C0
        {
            get { return new V3d( M00,  M10,  M20); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        public V3d C1
        {
            get { return new V3d( M01,  M11,  M21); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        public V3d C2
        {
            get { return new V3d( M02,  M12,  M22); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public V3d C3
        {
            get { return new V3d( M03,  M13,  M23); }
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
            }
        }

        public double this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M03;
                    case 4: return M10;
                    case 5: return M11;
                    case 6: return M12;
                    case 7: return M13;
                    case 8: return M20;
                    case 9: return M21;
                    case 10: return M22;
                    case 11: return M23;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M03 = value; return;
                    case 4: M10 = value; return;
                    case 5: M11 = value; return;
                    case 6: M12 = value; return;
                    case 7: M13 = value; return;
                    case 8: M20 = value; return;
                    case 9: M21 = value; return;
                    case 10: M22 = value; return;
                    case 11: M23 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public double this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            case 2: return M02;
                            case 3: return M03;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            case 2: return M12;
                            case 3: return M13;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: return M20;
                            case 1: return M21;
                            case 2: return M22;
                            case 3: return M23;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            case 2: M02 = value; return;
                            case 3: M03 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            case 2: M12 = value; return;
                            case 3: M13 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: M20 = value; return;
                            case 1: M21 = value; return;
                            case 2: M22 = value; return;
                            case 3: M23 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 4;
        public const int ElementCount = 3 * 4;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(3, 4);
        }

        public static M34d Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M34d(0);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public double Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public double NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public double NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M34d operator -(M34d m)
        {
            return new M34d(
                -m.M00, -m.M01, -m.M02, -m.M03, 
                -m.M10, -m.M11, -m.M12, -m.M13, 
                -m.M20, -m.M21, -m.M22, -m.M23);
        }

        public static M34d operator  + (M34d a, M34d b)
        {
            return new M34d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34d operator  + (M34d m, double s)
        {
            return new M34d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        public static M34d operator  + (double s, M34d m)
        {
            return new M34d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34d operator  - (M34d a, M34d b)
        {
            return new M34d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34d operator  - (M34d m, double s)
        {
            return new M34d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        public static M34d operator  - (double s, M34d m)
        {
            return new M34d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34d operator  % (M34d a, M34d b)
        {
            return new M34d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34d operator  % (M34d m, double s)
        {
            return new M34d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        public static M34d operator  % (double s, M34d m)
        {
            return new M34d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34d operator  / (M34d a, M34d b)
        {
            return new M34d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34d operator  / (M34d m, double s)
        {
            return new M34d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        public static M34d operator  / (double s, M34d m)
        {
            return new M34d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34d operator  * (M34d m, double s)
        {
            return new M34d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        public static M34d operator  * (double s, M34d m)
        {
            return new M34d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M34d matrix with a V4d column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d operator *(M34d m, V4d v)
        {
            return new V3d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W);
        }

        /// <summary>
        /// Multiplies a V3d row vector with a M34d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d operator *(V3d v, M34d m)
        {
            return new V4d(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M34d a, M34d b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23;
        }

        public static bool operator <(M34d a, double s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s;
        }

        public static bool operator <(double s, M34d a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23 ;
        }

        public static bool operator >(M34d a, M34d b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23;
        }

        public static bool operator >(M34d a, double s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s;
        }

        public static bool operator >(double s, M34d a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23 ;
        }

        public static bool operator ==(M34d a, M34d b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23;
        }

        public static bool operator ==(M34d a, double s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s;
        }

        public static bool operator ==(double s, M34d a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23 ;
        }

        public static bool operator <=(M34d a, M34d b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23;
        }

        public static bool operator <=(M34d a, double s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s;
        }

        public static bool operator <=(double s, M34d a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23 ;
        }

        public static bool operator >=(M34d a, M34d b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23;
        }

        public static bool operator >=(M34d a, double s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s;
        }

        public static bool operator >=(double s, M34d a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23 ;
        }

        public static bool operator !=(M34d a, M34d b)
        {
            return !(a == b);
        }

        public static bool operator !=(M34d m, double s)
        {
            return !(m == s);
        }

        public static bool operator !=(double s, M34d m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), M03.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), M13.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode(), M23.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M34d) ? (this == (M34d)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M34d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M34d.FromRows(
                V4d.Parse(x[0]), 
                V4d.Parse(x[1]), 
                V4d.Parse(x[2])
            );
        }

        #endregion

        #region Matrix Operations

        #endregion

        #region Matrix Multiplication

        public static M34d operator *(M33d a, M34d b)
        {
            return new M34d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23
             );
        }

        public static M34d operator *(M34d a, M44d b)
        {
            return new M34d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (double)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (double)value;
        }

        #endregion
    }

    public class M34dEqualityComparer : IEqualityComparer<M34d>
    {
        public static readonly M34dEqualityComparer Default
            = new M34dEqualityComparer();

        #region IEqualityComparer<M34d> Members

        public bool Equals(M34d v0, M34d v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M34d v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm1(M34d m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M34d m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMax(M34d m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMin(M34d m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M34d m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M03).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M13).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p) + 
                Fun.Abs(m.M23).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static double Distance1(this M34d a, M34d b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M34d a, M34d b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M34d a, M34d b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMax(this M34d a, M34d b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMin(this M34d a, M34d b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Transform(this M34d m, V4d v)
            => m * v;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d TransposedTransform(this M34d m, V3d v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by matrix m.
        /// </summary>
        public static V3d TransformDir(this M34d m, V3d v)
        {
            return new V3d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by matrix m.
        /// </summary>
        public static V3d TransformPos(this M34d m, V3d p)
        {
            return new V3d(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d Row(this M34d m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                case 2: return m.R2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Column(this M34d m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                case 2: return m.C2;
                case 3: return m.C3;
                default: throw new IndexOutOfRangeException();
            }
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M34d a, M34d b, double epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M44i

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M44i : IValidity, IMatrix<double>
    {
        [DataMember]
        public int M00, M01, M02, M03;
        [DataMember]
        public int M10, M11, M12, M13;
        [DataMember]
        public int M20, M21, M22, M23;
        [DataMember]
        public int M30, M31, M32, M33;

        #region Constructors

        public M44i(int value)
        {
            M00 = value; M01 = value; M02 = value; M03 = value; 
            M10 = value; M11 = value; M12 = value; M13 = value; 
            M20 = value; M21 = value; M22 = value; M23 = value; 
            M30 = value; M31 = value; M32 = value; M33 = value; 
        }

        public M44i(
                int m00, int m01, int m02, int m03, 
                int m10, int m11, int m12, int m13, 
                int m20, int m21, int m22, int m23, 
                int m30, int m31, int m32, int m33)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
            M30 = m30; M31 = m31; M32 = m32; M33 = m33; 
        }

        public M44i(int[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
            M30 = a[12];
            M31 = a[13];
            M32 = a[14];
            M33 = a[15];
        }

        public M44i(int[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
            M30 = a[start + 12];
            M31 = a[start + 13];
            M32 = a[start + 14];
            M33 = a[start + 15];
        }

        public M44i(M22i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44i(M23i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44i(M33i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44i(M34i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = m.M03; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = m.M13; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44i(M22l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44i(M23l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44i(M33l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44i(M34l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44i(M44l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
            M30 = (int)m.M30; M31 = (int)m.M31; M32 = (int)m.M32; M33 = (int)m.M33; 
        }

        public M44i(M22f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44i(M23f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44i(M33f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44i(M34f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44i(M44f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
            M30 = (int)m.M30; M31 = (int)m.M31; M32 = (int)m.M32; M33 = (int)m.M33; 
        }

        public M44i(M22d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44i(M23d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44i(M33d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44i(M34d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44i(M44d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
            M30 = (int)m.M30; M31 = (int)m.M31; M32 = (int)m.M32; M33 = (int)m.M33; 
        }

        #endregion

        #region Conversions

        public static explicit operator M44i(M22i m)
        {
            return new M44i {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M23i m)
        {
            return new M44i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M33i m)
        {
            return new M44i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M34i m)
        {
            return new M44i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M22l m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M23l m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M33l m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M34l m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M44l m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
                M30 = (int)m.M30, M31 = (int)m.M31, M32 = (int)m.M32, M33 = (int)m.M33, 
            };
        }

        public static explicit operator M44i(M22f m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M23f m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M33f m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M34f m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M44f m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
                M30 = (int)m.M30, M31 = (int)m.M31, M32 = (int)m.M32, M33 = (int)m.M33, 
            };
        }

        public static explicit operator M44i(M22d m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M23d m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M33d m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M34d m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M44d m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
                M30 = (int)m.M30, M31 = (int)m.M31, M32 = (int)m.M32, M33 = (int)m.M33, 
            };
        }

        public static explicit operator M44i(int[] a)
        {
            return new M44i(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11], 
                a[12], a[13], a[14], a[15]);
        }

        public static explicit operator M44i(int[,] a)
        {
            return new M44i(
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3], 
                a[3, 0], a[3, 1], a[3, 2], a[3, 3]);
        }

        public static explicit operator int[](M44i m)
        {
            return new int[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23, 
                m.M30, m.M31, m.M32, m.M33
            };
        }

        public static explicit operator int[,](M44i m)
        {
            return new int[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }, 
                { m.M30, m.M31, m.M32, m.M33 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
            array[index + 12] = M30;
            array[index + 13] = M31;
            array[index + 14] = M32;
            array[index + 15] = M33;
        }

        public static explicit operator M44i(long[] a)
        {
            return new M44i(
                (int)a[0], (int)a[1], (int)a[2], (int)a[3], 
                (int)a[4], (int)a[5], (int)a[6], (int)a[7], 
                (int)a[8], (int)a[9], (int)a[10], (int)a[11], 
                (int)a[12], (int)a[13], (int)a[14], (int)a[15]);
        }

        public static explicit operator M44i(long[,] a)
        {
            return new M44i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], (int)a[0, 3], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], (int)a[1, 3], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2], (int)a[2, 3], 
                (int)a[3, 0], (int)a[3, 1], (int)a[3, 2], (int)a[3, 3]);
        }

        public static explicit operator long[](M44i m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03, 
                (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13, 
                (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23, 
                (long)m.M30, (long)m.M31, (long)m.M32, (long)m.M33
            };
        }

        public static explicit operator long[,](M44i m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23 }, 
                { (long)m.M30, (long)m.M31, (long)m.M32, (long)m.M33 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M03;
            array[index + 4] = (long)M10;
            array[index + 5] = (long)M11;
            array[index + 6] = (long)M12;
            array[index + 7] = (long)M13;
            array[index + 8] = (long)M20;
            array[index + 9] = (long)M21;
            array[index + 10] = (long)M22;
            array[index + 11] = (long)M23;
            array[index + 12] = (long)M30;
            array[index + 13] = (long)M31;
            array[index + 14] = (long)M32;
            array[index + 15] = (long)M33;
        }

        public static explicit operator M44i(float[] a)
        {
            return new M44i(
                (int)a[0], (int)a[1], (int)a[2], (int)a[3], 
                (int)a[4], (int)a[5], (int)a[6], (int)a[7], 
                (int)a[8], (int)a[9], (int)a[10], (int)a[11], 
                (int)a[12], (int)a[13], (int)a[14], (int)a[15]);
        }

        public static explicit operator M44i(float[,] a)
        {
            return new M44i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], (int)a[0, 3], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], (int)a[1, 3], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2], (int)a[2, 3], 
                (int)a[3, 0], (int)a[3, 1], (int)a[3, 2], (int)a[3, 3]);
        }

        public static explicit operator float[](M44i m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03, 
                (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13, 
                (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23, 
                (float)m.M30, (float)m.M31, (float)m.M32, (float)m.M33
            };
        }

        public static explicit operator float[,](M44i m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23 }, 
                { (float)m.M30, (float)m.M31, (float)m.M32, (float)m.M33 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M03;
            array[index + 4] = (float)M10;
            array[index + 5] = (float)M11;
            array[index + 6] = (float)M12;
            array[index + 7] = (float)M13;
            array[index + 8] = (float)M20;
            array[index + 9] = (float)M21;
            array[index + 10] = (float)M22;
            array[index + 11] = (float)M23;
            array[index + 12] = (float)M30;
            array[index + 13] = (float)M31;
            array[index + 14] = (float)M32;
            array[index + 15] = (float)M33;
        }

        public static explicit operator M44i(double[] a)
        {
            return new M44i(
                (int)a[0], (int)a[1], (int)a[2], (int)a[3], 
                (int)a[4], (int)a[5], (int)a[6], (int)a[7], 
                (int)a[8], (int)a[9], (int)a[10], (int)a[11], 
                (int)a[12], (int)a[13], (int)a[14], (int)a[15]);
        }

        public static explicit operator M44i(double[,] a)
        {
            return new M44i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], (int)a[0, 3], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], (int)a[1, 3], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2], (int)a[2, 3], 
                (int)a[3, 0], (int)a[3, 1], (int)a[3, 2], (int)a[3, 3]);
        }

        public static explicit operator double[](M44i m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03, 
                (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13, 
                (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23, 
                (double)m.M30, (double)m.M31, (double)m.M32, (double)m.M33
            };
        }

        public static explicit operator double[,](M44i m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23 }, 
                { (double)m.M30, (double)m.M31, (double)m.M32, (double)m.M33 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M03;
            array[index + 4] = (double)M10;
            array[index + 5] = (double)M11;
            array[index + 6] = (double)M12;
            array[index + 7] = (double)M13;
            array[index + 8] = (double)M20;
            array[index + 9] = (double)M21;
            array[index + 10] = (double)M22;
            array[index + 11] = (double)M23;
            array[index + 12] = (double)M30;
            array[index + 13] = (double)M31;
            array[index + 14] = (double)M32;
            array[index + 15] = (double)M33;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<int, int> element_fun)
        {
            return new M44i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<int, int, int, int> element_index0_index1_fun)
        {
            return new M44i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<int, long> element_fun)
        {
            return new M44l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<int, int, int, long> element_index0_index1_fun)
        {
            return new M44l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<int, float> element_fun)
        {
            return new M44f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<int, int, int, float> element_index0_index1_fun)
        {
            return new M44f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<int, double> element_fun)
        {
            return new M44d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<int, int, int, double> element_index0_index1_fun)
        {
            return new M44d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M33i UpperLeftM33()
        {
            return (M33i)this;
        }

        public int[] ToArray()
        {
            var array = new int[16];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            array[12] = M30;
            array[13] = M31;
            array[14] = M32;
            array[15] = M33;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i FromCols(V4i col0, V4i col1, V4i col2, V4i col3)
        {
            return new M44i(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z, 
                col0.W, col1.W, col2.W, col3.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i FromRows(V4i row0, V4i row1, V4i row2, V4i row3)
        {
            return new M44i(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W, 
                row3.X, row3.Y, row3.Z, row3.W);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M44i"/> using 4 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i Scale(int tX, int tY, int tZ, int tW)
        {
            return new M44i(
                tX, 0, 0, 0, 
                0, tY, 0, 0, 
                0, 0, tZ, 0, 
                0, 0, 0, tW);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44i"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i Scale(int tX, int tY, int tZ)
        {
            return new M44i(
                tX, 0, 0, 0, 
                0, tY, 0, 0, 
                0, 0, tZ, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44i"/> using a <see cref="V4i"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i Scale(V4i s)
        {
            return new M44i(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, s.W);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44i"/> using a <see cref="V3i"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i Scale(V3i s)
        {
            return new M44i(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, 1);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M44i"/> with the translational component given by 3 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i Translation(int tX, int tY, int tZ)
        {
            return new M44i(
                1, 0, 0, tX, 
                0, 1, 0, tY, 
                0, 0, 1, tZ, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44i"/> with the translational component given by a <see cref="V3i"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i Translation(V3i t)
        {
            return new M44i(
                1, 0, 0, t.X, 
                0, 1, 0, t.Y, 
                0, 0, 1, t.Z, 
                0, 0, 0, 1);
        }

        #endregion

        #region Shearing

        public static M44i ShearXY(int factorX, int factorY)
        {
            return new M44i(
                1, 0, factorX, 0, 
                0, 1, factorY, 0, 
                0, 0, 1, 0, 
                0, 0, 0, 1);
        }

        public static M44i ShearXZ(int factorX, int factorZ)
        {
            return new M44i(
                1, factorX, 0, 0, 
                0, 1, 0, 0, 
                0, factorZ, 1, 0, 
                0, 0, 0, 1);
        }

        public static M44i ShearYZ(int factorY, int factorZ)
        {
            return new M44i(
                1, 0, 0, 0, 
                factorY, 1, 0, 0, 
                factorZ, 0, 1, 0, 
                0, 0, 0, 1);
        }

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<int> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M03;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M13;
                yield return M20;
                yield return M21;
                yield return M22;
                yield return M23;
                yield return M30;
                yield return M31;
                yield return M32;
                yield return M33;
            }
        }

        public IEnumerable<V4i> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
                yield return R3;
            }
        }

        public IEnumerable<V4i> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        public V4i R0
        {
            get { return new V4i( M00,  M01,  M02,  M03); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        public V4i R1
        {
            get { return new V4i( M10,  M11,  M12,  M13); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        public V4i R2
        {
            get { return new V4i( M20,  M21,  M22,  M23); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        public V4i R3
        {
            get { return new V4i( M30,  M31,  M32,  M33); }
            set
            {
                M30 = value.X;
                M31 = value.Y;
                M32 = value.Z;
                M33 = value.W;
            }
        }

        public V4i C0
        {
            get { return new V4i( M00,  M10,  M20,  M30); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
                M30 = value.W;
            }
        }

        public V4i C1
        {
            get { return new V4i( M01,  M11,  M21,  M31); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
                M31 = value.W;
            }
        }

        public V4i C2
        {
            get { return new V4i( M02,  M12,  M22,  M32); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
                M32 = value.W;
            }
        }

        public V4i C3
        {
            get { return new V4i( M03,  M13,  M23,  M33); }
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
                M33 = value.W;
            }
        }

        public int this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M03;
                    case 4: return M10;
                    case 5: return M11;
                    case 6: return M12;
                    case 7: return M13;
                    case 8: return M20;
                    case 9: return M21;
                    case 10: return M22;
                    case 11: return M23;
                    case 12: return M30;
                    case 13: return M31;
                    case 14: return M32;
                    case 15: return M33;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M03 = value; return;
                    case 4: M10 = value; return;
                    case 5: M11 = value; return;
                    case 6: M12 = value; return;
                    case 7: M13 = value; return;
                    case 8: M20 = value; return;
                    case 9: M21 = value; return;
                    case 10: M22 = value; return;
                    case 11: M23 = value; return;
                    case 12: M30 = value; return;
                    case 13: M31 = value; return;
                    case 14: M32 = value; return;
                    case 15: M33 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public int this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            case 2: return M02;
                            case 3: return M03;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            case 2: return M12;
                            case 3: return M13;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: return M20;
                            case 1: return M21;
                            case 2: return M22;
                            case 3: return M23;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 3: switch (column)
                        {
                            case 0: return M30;
                            case 1: return M31;
                            case 2: return M32;
                            case 3: return M33;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            case 2: M02 = value; return;
                            case 3: M03 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            case 2: M12 = value; return;
                            case 3: M13 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: M20 = value; return;
                            case 1: M21 = value; return;
                            case 2: M22 = value; return;
                            case 3: M23 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 3: switch (column)
                        {
                            case 0: M30 = value; return;
                            case 1: M31 = value; return;
                            case 2: M32 = value; return;
                            case 3: M33 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 4;
        public const int ColumnCount = 4;
        public const int ElementCount = 4 * 4;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(4, 4);
        }

        public static M44i Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M44i(0);
        }

        public static M44i Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M44i(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public int Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23) + 
                    Fun.Abs(M30) + Fun.Abs(M31) + Fun.Abs(M32) + Fun.Abs(M33);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23 + 
                    M30 * M30 + M31 * M31 + M32 * M32 + M33 * M33);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public int NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Max(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public int NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Min(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M44i operator -(M44i m)
        {
            return new M44i(
                -m.M00, -m.M01, -m.M02, -m.M03, 
                -m.M10, -m.M11, -m.M12, -m.M13, 
                -m.M20, -m.M21, -m.M22, -m.M23, 
                -m.M30, -m.M31, -m.M32, -m.M33);
        }

        public static M44i operator  + (M44i a, M44i b)
        {
            return new M44i(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44i operator  + (M44i m, int s)
        {
            return new M44i(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        public static M44i operator  + (int s, M44i m)
        {
            return new M44i(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44l operator  + (M44i a, M44l b)
        {
            return new M44l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44l operator  + (M44i m, long s)
        {
            return new M44l(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        public static M44l operator  + (long s, M44i m)
        {
            return new M44l(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44f operator  + (M44i a, M44f b)
        {
            return new M44f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44f operator  + (M44i m, float s)
        {
            return new M44f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        public static M44f operator  + (float s, M44i m)
        {
            return new M44f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44d operator  + (M44i a, M44d b)
        {
            return new M44d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44d operator  + (M44i m, double s)
        {
            return new M44d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        public static M44d operator  + (double s, M44i m)
        {
            return new M44d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44i operator  - (M44i a, M44i b)
        {
            return new M44i(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44i operator  - (M44i m, int s)
        {
            return new M44i(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        public static M44i operator  - (int s, M44i m)
        {
            return new M44i(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44l operator  - (M44i a, M44l b)
        {
            return new M44l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44l operator  - (M44i m, long s)
        {
            return new M44l(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        public static M44l operator  - (long s, M44i m)
        {
            return new M44l(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44f operator  - (M44i a, M44f b)
        {
            return new M44f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44f operator  - (M44i m, float s)
        {
            return new M44f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        public static M44f operator  - (float s, M44i m)
        {
            return new M44f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44d operator  - (M44i a, M44d b)
        {
            return new M44d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44d operator  - (M44i m, double s)
        {
            return new M44d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        public static M44d operator  - (double s, M44i m)
        {
            return new M44d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44i operator  % (M44i a, M44i b)
        {
            return new M44i(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44i operator  % (M44i m, int s)
        {
            return new M44i(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        public static M44i operator  % (int s, M44i m)
        {
            return new M44i(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44l operator  % (M44i a, M44l b)
        {
            return new M44l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44l operator  % (M44i m, long s)
        {
            return new M44l(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        public static M44l operator  % (long s, M44i m)
        {
            return new M44l(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44f operator  % (M44i a, M44f b)
        {
            return new M44f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44f operator  % (M44i m, float s)
        {
            return new M44f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        public static M44f operator  % (float s, M44i m)
        {
            return new M44f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44d operator  % (M44i a, M44d b)
        {
            return new M44d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44d operator  % (M44i m, double s)
        {
            return new M44d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        public static M44d operator  % (double s, M44i m)
        {
            return new M44d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44i operator  / (M44i a, M44i b)
        {
            return new M44i(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44i operator  / (M44i m, int s)
        {
            return new M44i(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        public static M44i operator  / (int s, M44i m)
        {
            return new M44i(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44l operator  / (M44i a, M44l b)
        {
            return new M44l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44l operator  / (M44i m, long s)
        {
            return new M44l(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        public static M44l operator  / (long s, M44i m)
        {
            return new M44l(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44f operator  / (M44i a, M44f b)
        {
            return new M44f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44f operator  / (M44i m, float s)
        {
            return new M44f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        public static M44f operator  / (float s, M44i m)
        {
            return new M44f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44d operator  / (M44i a, M44d b)
        {
            return new M44d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44d operator  / (M44i m, double s)
        {
            return new M44d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        public static M44d operator  / (double s, M44i m)
        {
            return new M44d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44i operator  * (M44i m, int s)
        {
            return new M44i(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        public static M44i operator  * (int s, M44i m)
        {
            return new M44i(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44l operator  * (M44i m, long s)
        {
            return new M44l(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        public static M44l operator  * (long s, M44i m)
        {
            return new M44l(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44f operator  * (M44i m, float s)
        {
            return new M44f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        public static M44f operator  * (float s, M44i m)
        {
            return new M44f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44d operator  * (M44i m, double s)
        {
            return new M44d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        public static M44d operator  * (double s, M44i m)
        {
            return new M44d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M44i matrix with a V4i column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i operator *(M44i m, V4i v)
        {
            return new V4i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W, 
                m.M30 * v.X + m.M31 * v.Y + m.M32 * v.Z + m.M33 * v.W);
        }

        /// <summary>
        /// Multiplies a V4i row vector with a M44i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i operator *(V4i v, M44i m)
        {
            return new V4i(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20 + v.W * m.M30, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21 + v.W * m.M31, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22 + v.W * m.M32, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23 + v.W * m.M33);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M44i a, M44i b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23 && 
                a.M30 < b.M30 && 
                a.M31 < b.M31 && 
                a.M32 < b.M32 && 
                a.M33 < b.M33;
        }

        public static bool operator <(M44i a, int s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s && 
                a.M30 < s && 
                a.M31 < s && 
                a.M32 < s && 
                a.M33 < s;
        }

        public static bool operator <(int s, M44i a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23  && 
                s < a.M30  && 
                s < a.M31  && 
                s < a.M32  && 
                s < a.M33 ;
        }

        public static bool operator >(M44i a, M44i b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23 && 
                a.M30 > b.M30 && 
                a.M31 > b.M31 && 
                a.M32 > b.M32 && 
                a.M33 > b.M33;
        }

        public static bool operator >(M44i a, int s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s && 
                a.M30 > s && 
                a.M31 > s && 
                a.M32 > s && 
                a.M33 > s;
        }

        public static bool operator >(int s, M44i a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23  && 
                s > a.M30  && 
                s > a.M31  && 
                s > a.M32  && 
                s > a.M33 ;
        }

        public static bool operator ==(M44i a, M44i b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23 && 
                a.M30 == b.M30 && 
                a.M31 == b.M31 && 
                a.M32 == b.M32 && 
                a.M33 == b.M33;
        }

        public static bool operator ==(M44i a, int s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s && 
                a.M30 == s && 
                a.M31 == s && 
                a.M32 == s && 
                a.M33 == s;
        }

        public static bool operator ==(int s, M44i a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23  && 
                s == a.M30  && 
                s == a.M31  && 
                s == a.M32  && 
                s == a.M33 ;
        }

        public static bool operator <=(M44i a, M44i b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23 && 
                a.M30 <= b.M30 && 
                a.M31 <= b.M31 && 
                a.M32 <= b.M32 && 
                a.M33 <= b.M33;
        }

        public static bool operator <=(M44i a, int s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s && 
                a.M30 <= s && 
                a.M31 <= s && 
                a.M32 <= s && 
                a.M33 <= s;
        }

        public static bool operator <=(int s, M44i a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23  && 
                s <= a.M30  && 
                s <= a.M31  && 
                s <= a.M32  && 
                s <= a.M33 ;
        }

        public static bool operator >=(M44i a, M44i b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23 && 
                a.M30 >= b.M30 && 
                a.M31 >= b.M31 && 
                a.M32 >= b.M32 && 
                a.M33 >= b.M33;
        }

        public static bool operator >=(M44i a, int s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s && 
                a.M30 >= s && 
                a.M31 >= s && 
                a.M32 >= s && 
                a.M33 >= s;
        }

        public static bool operator >=(int s, M44i a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23  && 
                s >= a.M30  && 
                s >= a.M31  && 
                s >= a.M32  && 
                s >= a.M33 ;
        }

        public static bool operator !=(M44i a, M44i b)
        {
            return !(a == b);
        }

        public static bool operator !=(M44i m, int s)
        {
            return !(m == s);
        }

        public static bool operator !=(int s, M44i m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), M03.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), M13.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode(), M23.GetHashCode(), 
                M30.GetHashCode(), M31.GetHashCode(), M32.GetHashCode(), M33.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M44i) ? (this == (M44i)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R3.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M44i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M44i.FromRows(
                V4i.Parse(x[0]), 
                V4i.Parse(x[1]), 
                V4i.Parse(x[2]), 
                V4i.Parse(x[3])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M44i Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                M44i result = new M44i();
                for (int row = 0; row < 4; row++)
                {
                    for (int col = 0; col < 4; col++)
                    {
                        if (((col + row) % 2) == 0)
                            result[col, row] = this.Minor(row, col).Determinant;
                        else
                            result[col, row] = -this.Minor(row, col).Determinant;
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public int Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 + M22 + M33 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public int Determinant
        {
            get
            {
                // using bottom row because elements M30, M31, and M32
                // are zero most of the time.
                int d = 0;
                if (M30 != 0.0f) d -= M30 * (
                M01 * M12 * M23 + M02 * M13 * M21 + M03 * M11 * M22
                - M21 * M12 * M03 - M22 * M13 * M01 - M23 * M11 * M02
                );
                if (M31 != 0.0f) d += M31 * (
                M00 * M12 * M23 + M02 * M13 * M20 + M03 * M10 * M22
                - M20 * M12 * M03 - M22 * M13 * M00 - M23 * M10 * M02
                );
                if (M32 != 0.0f) d -= M32 * (
                M00 * M11 * M23 + M01 * M13 * M20 + M03 * M10 * M21
                - M20 * M11 * M03 - M21 * M13 * M00 - M23 * M10 * M01
                );
                if (M33 != 0.0f) d += M33 * (
                M00 * M11 * M22 + M01 * M12 * M20 + M02 * M10 * M21
                - M20 * M11 * M02 - M21 * M12 * M00 - M22 * M10 * M01
                );
                return d;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M44i Transposed
        {
            get
            {
                return new M44i {
                    
                    M00 = M00, 
                    M01 = M10, 
                    M02 = M20, 
                    M03 = M30, 
                    
                    M10 = M01, 
                    M11 = M11, 
                    M12 = M21, 
                    M13 = M31, 
                    
                    M20 = M02, 
                    M21 = M12, 
                    M22 = M22, 
                    M23 = M32, 
                    
                    M30 = M03, 
                    M31 = M13, 
                    M32 = M23, 
                    M33 = M33
                };
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M44i operator *(M44i a, M44i b)
        {
            return new M44i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33, 
                a.M30 * b.M00 + a.M31 * b.M10 + a.M32 * b.M20 + a.M33 * b.M30, 
                a.M30 * b.M01 + a.M31 * b.M11 + a.M32 * b.M21 + a.M33 * b.M31, 
                a.M30 * b.M02 + a.M31 * b.M12 + a.M32 * b.M22 + a.M33 * b.M32, 
                a.M30 * b.M03 + a.M31 * b.M13 + a.M32 * b.M23 + a.M33 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (int)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (int)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (int)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (int)value;
        }

        #endregion
    }

    public class M44iEqualityComparer : IEqualityComparer<M44i>
    {
        public static readonly M44iEqualityComparer Default
            = new M44iEqualityComparer();

        #region IEqualityComparer<M44i> Members

        public bool Equals(M44i v0, M44i v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M44i v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Norm1(M44i m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M44i m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMax(M44i m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMin(M44i m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M44i m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M03).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M13).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p) + 
                Fun.Abs(m.M23).Pow(p) + 
                Fun.Abs(m.M30).Pow(p) + 
                Fun.Abs(m.M31).Pow(p) + 
                Fun.Abs(m.M32).Pow(p) + 
                Fun.Abs(m.M33).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static int Distance1(this M44i a, M44i b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23) + 
                Fun.Abs(b.M30 - a.M30) + 
                Fun.Abs(b.M31 - a.M31) + 
                Fun.Abs(b.M32 - a.M32) + 
                Fun.Abs(b.M33 - a.M33);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M44i a, M44i b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23) + 
                        Fun.Square(b.M30 - a.M30) + 
                        Fun.Square(b.M31 - a.M31) + 
                        Fun.Square(b.M32 - a.M32) + 
                        Fun.Square(b.M33 - a.M33));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M44i a, M44i b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p) + 
                Fun.Abs(b.M30 - a.M30).Pow(p) + 
                Fun.Abs(b.M31 - a.M31).Pow(p) + 
                Fun.Abs(b.M32 - a.M32).Pow(p) + 
                Fun.Abs(b.M33 - a.M33).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMax(this M44i a, M44i b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Max(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMin(this M44i a, M44i b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Min(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i Transform(this M44i m, V4i v)
            => m * v;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i TransposedTransform(this M44i m, V4i v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by matrix m.
        /// </summary>
        public static V3i TransformDir(this M44i m, V3i v)
        {
            return new V3i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3i TransformPos(this M44i m, V3i p)
        {
            return new V3i(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Transforms point p (p.W is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3i TransformPosProj(this M44i m, V3i p)
        {
            int s = m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z + m.M33;
            return TransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (p.W is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V4i TransformPosProjFull(this M44i m, V3i p)
        {
            return new V4i(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23, 
                m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z + m.M33
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V3i TransposedTransformDir(this M44i m, V3i v)
        {
            return new V3i(
                m.M00 * v.X + m.M10 * v.Y + m.M20 * v.Z, 
                m.M01 * v.X + m.M11 * v.Y + m.M21 * v.Z, 
                m.M02 * v.X + m.M12 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3i TransposedTransformPos(this M44i m, V3i p)
        {
            return new V3i(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3i TransposedTransformProj(this M44i m, V3i p)
        {
            var s = m.M03 * p.X + m.M13 * p.Y + m.M23 * p.Z + m.M33;
            return TransposedTransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V4i TransposedTransformProjFull(this M44i m, V3i p)
        {
            return new V4i(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32, 
                m.M03 * p.X + m.M13 * p.Y + m.M23 * p.Z + m.M33
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M44i"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static M33i Minor(this M44i m, int row, int column)
        {
            M33i rs = new M33i();

            for (int k = 0; k < 9; k++)
            {
                var i = k / 9;
                var j = k % 9;

                if (i != row && j != column)
                {
                    rs[k] = m[k];
                }
            }

            return rs;
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i Row(this M44i m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                case 2: return m.R2;
                case 3: return m.R3;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i Column(this M44i m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                case 2: return m.C2;
                case 3: return m.C3;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Determinant(M44i m)
            => m.Determinant;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        public static void Transpose(this ref M44i m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
            Fun.Swap(ref m.M20, ref m.M02);
            Fun.Swap(ref m.M21, ref m.M12);
            Fun.Swap(ref m.M30, ref m.M03);
            Fun.Swap(ref m.M31, ref m.M13);
            Fun.Swap(ref m.M32, ref m.M23);
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M44i a, M44i b, int epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M44l

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M44l : IValidity, IMatrix<double>
    {
        [DataMember]
        public long M00, M01, M02, M03;
        [DataMember]
        public long M10, M11, M12, M13;
        [DataMember]
        public long M20, M21, M22, M23;
        [DataMember]
        public long M30, M31, M32, M33;

        #region Constructors

        public M44l(long value)
        {
            M00 = value; M01 = value; M02 = value; M03 = value; 
            M10 = value; M11 = value; M12 = value; M13 = value; 
            M20 = value; M21 = value; M22 = value; M23 = value; 
            M30 = value; M31 = value; M32 = value; M33 = value; 
        }

        public M44l(
                long m00, long m01, long m02, long m03, 
                long m10, long m11, long m12, long m13, 
                long m20, long m21, long m22, long m23, 
                long m30, long m31, long m32, long m33)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
            M30 = m30; M31 = m31; M32 = m32; M33 = m33; 
        }

        public M44l(long[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
            M30 = a[12];
            M31 = a[13];
            M32 = a[14];
            M33 = a[15];
        }

        public M44l(long[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
            M30 = a[start + 12];
            M31 = a[start + 13];
            M32 = a[start + 14];
            M33 = a[start + 15];
        }

        public M44l(M22i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44l(M23i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44l(M33i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44l(M34i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44l(M44i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
            M30 = (long)m.M30; M31 = (long)m.M31; M32 = (long)m.M32; M33 = (long)m.M33; 
        }

        public M44l(M22l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44l(M23l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44l(M33l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44l(M34l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = m.M03; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = m.M13; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44l(M22f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44l(M23f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44l(M33f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44l(M34f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44l(M44f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
            M30 = (long)m.M30; M31 = (long)m.M31; M32 = (long)m.M32; M33 = (long)m.M33; 
        }

        public M44l(M22d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44l(M23d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44l(M33d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44l(M34d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44l(M44d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
            M30 = (long)m.M30; M31 = (long)m.M31; M32 = (long)m.M32; M33 = (long)m.M33; 
        }

        #endregion

        #region Conversions

        public static explicit operator M44l(M22i m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M23i m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M33i m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M34i m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M44i m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
                M30 = (long)m.M30, M31 = (long)m.M31, M32 = (long)m.M32, M33 = (long)m.M33, 
            };
        }

        public static explicit operator M44l(M22l m)
        {
            return new M44l {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M23l m)
        {
            return new M44l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M33l m)
        {
            return new M44l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M34l m)
        {
            return new M44l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M22f m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M23f m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M33f m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M34f m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M44f m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
                M30 = (long)m.M30, M31 = (long)m.M31, M32 = (long)m.M32, M33 = (long)m.M33, 
            };
        }

        public static explicit operator M44l(M22d m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M23d m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M33d m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M34d m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M44d m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
                M30 = (long)m.M30, M31 = (long)m.M31, M32 = (long)m.M32, M33 = (long)m.M33, 
            };
        }

        public static explicit operator M44l(int[] a)
        {
            return new M44l(
                (long)a[0], (long)a[1], (long)a[2], (long)a[3], 
                (long)a[4], (long)a[5], (long)a[6], (long)a[7], 
                (long)a[8], (long)a[9], (long)a[10], (long)a[11], 
                (long)a[12], (long)a[13], (long)a[14], (long)a[15]);
        }

        public static explicit operator M44l(int[,] a)
        {
            return new M44l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], (long)a[0, 3], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], (long)a[1, 3], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2], (long)a[2, 3], 
                (long)a[3, 0], (long)a[3, 1], (long)a[3, 2], (long)a[3, 3]);
        }

        public static explicit operator int[](M44l m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03, 
                (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13, 
                (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23, 
                (int)m.M30, (int)m.M31, (int)m.M32, (int)m.M33
            };
        }

        public static explicit operator int[,](M44l m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23 }, 
                { (int)m.M30, (int)m.M31, (int)m.M32, (int)m.M33 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M03;
            array[index + 4] = (int)M10;
            array[index + 5] = (int)M11;
            array[index + 6] = (int)M12;
            array[index + 7] = (int)M13;
            array[index + 8] = (int)M20;
            array[index + 9] = (int)M21;
            array[index + 10] = (int)M22;
            array[index + 11] = (int)M23;
            array[index + 12] = (int)M30;
            array[index + 13] = (int)M31;
            array[index + 14] = (int)M32;
            array[index + 15] = (int)M33;
        }

        public static explicit operator M44l(long[] a)
        {
            return new M44l(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11], 
                a[12], a[13], a[14], a[15]);
        }

        public static explicit operator M44l(long[,] a)
        {
            return new M44l(
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3], 
                a[3, 0], a[3, 1], a[3, 2], a[3, 3]);
        }

        public static explicit operator long[](M44l m)
        {
            return new long[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23, 
                m.M30, m.M31, m.M32, m.M33
            };
        }

        public static explicit operator long[,](M44l m)
        {
            return new long[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }, 
                { m.M30, m.M31, m.M32, m.M33 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
            array[index + 12] = M30;
            array[index + 13] = M31;
            array[index + 14] = M32;
            array[index + 15] = M33;
        }

        public static explicit operator M44l(float[] a)
        {
            return new M44l(
                (long)a[0], (long)a[1], (long)a[2], (long)a[3], 
                (long)a[4], (long)a[5], (long)a[6], (long)a[7], 
                (long)a[8], (long)a[9], (long)a[10], (long)a[11], 
                (long)a[12], (long)a[13], (long)a[14], (long)a[15]);
        }

        public static explicit operator M44l(float[,] a)
        {
            return new M44l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], (long)a[0, 3], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], (long)a[1, 3], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2], (long)a[2, 3], 
                (long)a[3, 0], (long)a[3, 1], (long)a[3, 2], (long)a[3, 3]);
        }

        public static explicit operator float[](M44l m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03, 
                (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13, 
                (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23, 
                (float)m.M30, (float)m.M31, (float)m.M32, (float)m.M33
            };
        }

        public static explicit operator float[,](M44l m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23 }, 
                { (float)m.M30, (float)m.M31, (float)m.M32, (float)m.M33 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M03;
            array[index + 4] = (float)M10;
            array[index + 5] = (float)M11;
            array[index + 6] = (float)M12;
            array[index + 7] = (float)M13;
            array[index + 8] = (float)M20;
            array[index + 9] = (float)M21;
            array[index + 10] = (float)M22;
            array[index + 11] = (float)M23;
            array[index + 12] = (float)M30;
            array[index + 13] = (float)M31;
            array[index + 14] = (float)M32;
            array[index + 15] = (float)M33;
        }

        public static explicit operator M44l(double[] a)
        {
            return new M44l(
                (long)a[0], (long)a[1], (long)a[2], (long)a[3], 
                (long)a[4], (long)a[5], (long)a[6], (long)a[7], 
                (long)a[8], (long)a[9], (long)a[10], (long)a[11], 
                (long)a[12], (long)a[13], (long)a[14], (long)a[15]);
        }

        public static explicit operator M44l(double[,] a)
        {
            return new M44l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], (long)a[0, 3], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], (long)a[1, 3], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2], (long)a[2, 3], 
                (long)a[3, 0], (long)a[3, 1], (long)a[3, 2], (long)a[3, 3]);
        }

        public static explicit operator double[](M44l m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03, 
                (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13, 
                (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23, 
                (double)m.M30, (double)m.M31, (double)m.M32, (double)m.M33
            };
        }

        public static explicit operator double[,](M44l m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23 }, 
                { (double)m.M30, (double)m.M31, (double)m.M32, (double)m.M33 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M03;
            array[index + 4] = (double)M10;
            array[index + 5] = (double)M11;
            array[index + 6] = (double)M12;
            array[index + 7] = (double)M13;
            array[index + 8] = (double)M20;
            array[index + 9] = (double)M21;
            array[index + 10] = (double)M22;
            array[index + 11] = (double)M23;
            array[index + 12] = (double)M30;
            array[index + 13] = (double)M31;
            array[index + 14] = (double)M32;
            array[index + 15] = (double)M33;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<long, int> element_fun)
        {
            return new M44i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<long, int, int, int> element_index0_index1_fun)
        {
            return new M44i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<long, long> element_fun)
        {
            return new M44l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<long, int, int, long> element_index0_index1_fun)
        {
            return new M44l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<long, float> element_fun)
        {
            return new M44f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<long, int, int, float> element_index0_index1_fun)
        {
            return new M44f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<long, double> element_fun)
        {
            return new M44d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<long, int, int, double> element_index0_index1_fun)
        {
            return new M44d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M33l UpperLeftM33()
        {
            return (M33l)this;
        }

        public long[] ToArray()
        {
            var array = new long[16];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            array[12] = M30;
            array[13] = M31;
            array[14] = M32;
            array[15] = M33;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l FromCols(V4l col0, V4l col1, V4l col2, V4l col3)
        {
            return new M44l(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z, 
                col0.W, col1.W, col2.W, col3.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l FromRows(V4l row0, V4l row1, V4l row2, V4l row3)
        {
            return new M44l(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W, 
                row3.X, row3.Y, row3.Z, row3.W);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M44l"/> using 4 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l Scale(long tX, long tY, long tZ, long tW)
        {
            return new M44l(
                tX, 0, 0, 0, 
                0, tY, 0, 0, 
                0, 0, tZ, 0, 
                0, 0, 0, tW);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44l"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l Scale(long tX, long tY, long tZ)
        {
            return new M44l(
                tX, 0, 0, 0, 
                0, tY, 0, 0, 
                0, 0, tZ, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44l"/> using a <see cref="V4l"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l Scale(V4l s)
        {
            return new M44l(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, s.W);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44l"/> using a <see cref="V3l"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l Scale(V3l s)
        {
            return new M44l(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, 1);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M44l"/> with the translational component given by 3 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l Translation(long tX, long tY, long tZ)
        {
            return new M44l(
                1, 0, 0, tX, 
                0, 1, 0, tY, 
                0, 0, 1, tZ, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44l"/> with the translational component given by a <see cref="V3l"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l Translation(V3l t)
        {
            return new M44l(
                1, 0, 0, t.X, 
                0, 1, 0, t.Y, 
                0, 0, 1, t.Z, 
                0, 0, 0, 1);
        }

        #endregion

        #region Shearing

        public static M44l ShearXY(long factorX, long factorY)
        {
            return new M44l(
                1, 0, factorX, 0, 
                0, 1, factorY, 0, 
                0, 0, 1, 0, 
                0, 0, 0, 1);
        }

        public static M44l ShearXZ(long factorX, long factorZ)
        {
            return new M44l(
                1, factorX, 0, 0, 
                0, 1, 0, 0, 
                0, factorZ, 1, 0, 
                0, 0, 0, 1);
        }

        public static M44l ShearYZ(long factorY, long factorZ)
        {
            return new M44l(
                1, 0, 0, 0, 
                factorY, 1, 0, 0, 
                factorZ, 0, 1, 0, 
                0, 0, 0, 1);
        }

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<long> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M03;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M13;
                yield return M20;
                yield return M21;
                yield return M22;
                yield return M23;
                yield return M30;
                yield return M31;
                yield return M32;
                yield return M33;
            }
        }

        public IEnumerable<V4l> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
                yield return R3;
            }
        }

        public IEnumerable<V4l> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        public V4l R0
        {
            get { return new V4l( M00,  M01,  M02,  M03); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        public V4l R1
        {
            get { return new V4l( M10,  M11,  M12,  M13); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        public V4l R2
        {
            get { return new V4l( M20,  M21,  M22,  M23); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        public V4l R3
        {
            get { return new V4l( M30,  M31,  M32,  M33); }
            set
            {
                M30 = value.X;
                M31 = value.Y;
                M32 = value.Z;
                M33 = value.W;
            }
        }

        public V4l C0
        {
            get { return new V4l( M00,  M10,  M20,  M30); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
                M30 = value.W;
            }
        }

        public V4l C1
        {
            get { return new V4l( M01,  M11,  M21,  M31); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
                M31 = value.W;
            }
        }

        public V4l C2
        {
            get { return new V4l( M02,  M12,  M22,  M32); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
                M32 = value.W;
            }
        }

        public V4l C3
        {
            get { return new V4l( M03,  M13,  M23,  M33); }
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
                M33 = value.W;
            }
        }

        public long this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M03;
                    case 4: return M10;
                    case 5: return M11;
                    case 6: return M12;
                    case 7: return M13;
                    case 8: return M20;
                    case 9: return M21;
                    case 10: return M22;
                    case 11: return M23;
                    case 12: return M30;
                    case 13: return M31;
                    case 14: return M32;
                    case 15: return M33;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M03 = value; return;
                    case 4: M10 = value; return;
                    case 5: M11 = value; return;
                    case 6: M12 = value; return;
                    case 7: M13 = value; return;
                    case 8: M20 = value; return;
                    case 9: M21 = value; return;
                    case 10: M22 = value; return;
                    case 11: M23 = value; return;
                    case 12: M30 = value; return;
                    case 13: M31 = value; return;
                    case 14: M32 = value; return;
                    case 15: M33 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public long this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            case 2: return M02;
                            case 3: return M03;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            case 2: return M12;
                            case 3: return M13;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: return M20;
                            case 1: return M21;
                            case 2: return M22;
                            case 3: return M23;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 3: switch (column)
                        {
                            case 0: return M30;
                            case 1: return M31;
                            case 2: return M32;
                            case 3: return M33;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            case 2: M02 = value; return;
                            case 3: M03 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            case 2: M12 = value; return;
                            case 3: M13 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: M20 = value; return;
                            case 1: M21 = value; return;
                            case 2: M22 = value; return;
                            case 3: M23 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 3: switch (column)
                        {
                            case 0: M30 = value; return;
                            case 1: M31 = value; return;
                            case 2: M32 = value; return;
                            case 3: M33 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 4;
        public const int ColumnCount = 4;
        public const int ElementCount = 4 * 4;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(4, 4);
        }

        public static M44l Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M44l(0);
        }

        public static M44l Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M44l(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public long Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23) + 
                    Fun.Abs(M30) + Fun.Abs(M31) + Fun.Abs(M32) + Fun.Abs(M33);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23 + 
                    M30 * M30 + M31 * M31 + M32 * M32 + M33 * M33);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public long NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Max(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public long NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Min(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M44l operator -(M44l m)
        {
            return new M44l(
                -m.M00, -m.M01, -m.M02, -m.M03, 
                -m.M10, -m.M11, -m.M12, -m.M13, 
                -m.M20, -m.M21, -m.M22, -m.M23, 
                -m.M30, -m.M31, -m.M32, -m.M33);
        }

        public static M44l operator  + (M44l a, M44l b)
        {
            return new M44l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44l operator  + (M44l m, long s)
        {
            return new M44l(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        public static M44l operator  + (long s, M44l m)
        {
            return new M44l(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44f operator  + (M44l a, M44f b)
        {
            return new M44f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44f operator  + (M44l m, float s)
        {
            return new M44f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        public static M44f operator  + (float s, M44l m)
        {
            return new M44f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44d operator  + (M44l a, M44d b)
        {
            return new M44d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44d operator  + (M44l m, double s)
        {
            return new M44d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        public static M44d operator  + (double s, M44l m)
        {
            return new M44d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44l operator  - (M44l a, M44l b)
        {
            return new M44l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44l operator  - (M44l m, long s)
        {
            return new M44l(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        public static M44l operator  - (long s, M44l m)
        {
            return new M44l(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44f operator  - (M44l a, M44f b)
        {
            return new M44f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44f operator  - (M44l m, float s)
        {
            return new M44f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        public static M44f operator  - (float s, M44l m)
        {
            return new M44f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44d operator  - (M44l a, M44d b)
        {
            return new M44d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44d operator  - (M44l m, double s)
        {
            return new M44d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        public static M44d operator  - (double s, M44l m)
        {
            return new M44d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44l operator  % (M44l a, M44l b)
        {
            return new M44l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44l operator  % (M44l m, long s)
        {
            return new M44l(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        public static M44l operator  % (long s, M44l m)
        {
            return new M44l(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44f operator  % (M44l a, M44f b)
        {
            return new M44f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44f operator  % (M44l m, float s)
        {
            return new M44f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        public static M44f operator  % (float s, M44l m)
        {
            return new M44f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44d operator  % (M44l a, M44d b)
        {
            return new M44d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44d operator  % (M44l m, double s)
        {
            return new M44d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        public static M44d operator  % (double s, M44l m)
        {
            return new M44d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44l operator  / (M44l a, M44l b)
        {
            return new M44l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44l operator  / (M44l m, long s)
        {
            return new M44l(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        public static M44l operator  / (long s, M44l m)
        {
            return new M44l(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44f operator  / (M44l a, M44f b)
        {
            return new M44f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44f operator  / (M44l m, float s)
        {
            return new M44f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        public static M44f operator  / (float s, M44l m)
        {
            return new M44f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44d operator  / (M44l a, M44d b)
        {
            return new M44d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44d operator  / (M44l m, double s)
        {
            return new M44d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        public static M44d operator  / (double s, M44l m)
        {
            return new M44d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44l operator  * (M44l m, long s)
        {
            return new M44l(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        public static M44l operator  * (long s, M44l m)
        {
            return new M44l(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44f operator  * (M44l m, float s)
        {
            return new M44f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        public static M44f operator  * (float s, M44l m)
        {
            return new M44f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44d operator  * (M44l m, double s)
        {
            return new M44d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        public static M44d operator  * (double s, M44l m)
        {
            return new M44d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M44l matrix with a V4l column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l operator *(M44l m, V4l v)
        {
            return new V4l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W, 
                m.M30 * v.X + m.M31 * v.Y + m.M32 * v.Z + m.M33 * v.W);
        }

        /// <summary>
        /// Multiplies a V4l row vector with a M44l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l operator *(V4l v, M44l m)
        {
            return new V4l(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20 + v.W * m.M30, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21 + v.W * m.M31, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22 + v.W * m.M32, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23 + v.W * m.M33);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M44l a, M44l b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23 && 
                a.M30 < b.M30 && 
                a.M31 < b.M31 && 
                a.M32 < b.M32 && 
                a.M33 < b.M33;
        }

        public static bool operator <(M44l a, long s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s && 
                a.M30 < s && 
                a.M31 < s && 
                a.M32 < s && 
                a.M33 < s;
        }

        public static bool operator <(long s, M44l a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23  && 
                s < a.M30  && 
                s < a.M31  && 
                s < a.M32  && 
                s < a.M33 ;
        }

        public static bool operator >(M44l a, M44l b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23 && 
                a.M30 > b.M30 && 
                a.M31 > b.M31 && 
                a.M32 > b.M32 && 
                a.M33 > b.M33;
        }

        public static bool operator >(M44l a, long s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s && 
                a.M30 > s && 
                a.M31 > s && 
                a.M32 > s && 
                a.M33 > s;
        }

        public static bool operator >(long s, M44l a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23  && 
                s > a.M30  && 
                s > a.M31  && 
                s > a.M32  && 
                s > a.M33 ;
        }

        public static bool operator ==(M44l a, M44l b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23 && 
                a.M30 == b.M30 && 
                a.M31 == b.M31 && 
                a.M32 == b.M32 && 
                a.M33 == b.M33;
        }

        public static bool operator ==(M44l a, long s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s && 
                a.M30 == s && 
                a.M31 == s && 
                a.M32 == s && 
                a.M33 == s;
        }

        public static bool operator ==(long s, M44l a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23  && 
                s == a.M30  && 
                s == a.M31  && 
                s == a.M32  && 
                s == a.M33 ;
        }

        public static bool operator <=(M44l a, M44l b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23 && 
                a.M30 <= b.M30 && 
                a.M31 <= b.M31 && 
                a.M32 <= b.M32 && 
                a.M33 <= b.M33;
        }

        public static bool operator <=(M44l a, long s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s && 
                a.M30 <= s && 
                a.M31 <= s && 
                a.M32 <= s && 
                a.M33 <= s;
        }

        public static bool operator <=(long s, M44l a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23  && 
                s <= a.M30  && 
                s <= a.M31  && 
                s <= a.M32  && 
                s <= a.M33 ;
        }

        public static bool operator >=(M44l a, M44l b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23 && 
                a.M30 >= b.M30 && 
                a.M31 >= b.M31 && 
                a.M32 >= b.M32 && 
                a.M33 >= b.M33;
        }

        public static bool operator >=(M44l a, long s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s && 
                a.M30 >= s && 
                a.M31 >= s && 
                a.M32 >= s && 
                a.M33 >= s;
        }

        public static bool operator >=(long s, M44l a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23  && 
                s >= a.M30  && 
                s >= a.M31  && 
                s >= a.M32  && 
                s >= a.M33 ;
        }

        public static bool operator !=(M44l a, M44l b)
        {
            return !(a == b);
        }

        public static bool operator !=(M44l m, long s)
        {
            return !(m == s);
        }

        public static bool operator !=(long s, M44l m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), M03.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), M13.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode(), M23.GetHashCode(), 
                M30.GetHashCode(), M31.GetHashCode(), M32.GetHashCode(), M33.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M44l) ? (this == (M44l)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R3.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M44l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M44l.FromRows(
                V4l.Parse(x[0]), 
                V4l.Parse(x[1]), 
                V4l.Parse(x[2]), 
                V4l.Parse(x[3])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M44l Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                M44l result = new M44l();
                for (int row = 0; row < 4; row++)
                {
                    for (int col = 0; col < 4; col++)
                    {
                        if (((col + row) % 2) == 0)
                            result[col, row] = this.Minor(row, col).Determinant;
                        else
                            result[col, row] = -this.Minor(row, col).Determinant;
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public long Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 + M22 + M33 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public long Determinant
        {
            get
            {
                // using bottom row because elements M30, M31, and M32
                // are zero most of the time.
                long d = 0;
                if (M30 != 0.0f) d -= M30 * (
                M01 * M12 * M23 + M02 * M13 * M21 + M03 * M11 * M22
                - M21 * M12 * M03 - M22 * M13 * M01 - M23 * M11 * M02
                );
                if (M31 != 0.0f) d += M31 * (
                M00 * M12 * M23 + M02 * M13 * M20 + M03 * M10 * M22
                - M20 * M12 * M03 - M22 * M13 * M00 - M23 * M10 * M02
                );
                if (M32 != 0.0f) d -= M32 * (
                M00 * M11 * M23 + M01 * M13 * M20 + M03 * M10 * M21
                - M20 * M11 * M03 - M21 * M13 * M00 - M23 * M10 * M01
                );
                if (M33 != 0.0f) d += M33 * (
                M00 * M11 * M22 + M01 * M12 * M20 + M02 * M10 * M21
                - M20 * M11 * M02 - M21 * M12 * M00 - M22 * M10 * M01
                );
                return d;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M44l Transposed
        {
            get
            {
                return new M44l {
                    
                    M00 = M00, 
                    M01 = M10, 
                    M02 = M20, 
                    M03 = M30, 
                    
                    M10 = M01, 
                    M11 = M11, 
                    M12 = M21, 
                    M13 = M31, 
                    
                    M20 = M02, 
                    M21 = M12, 
                    M22 = M22, 
                    M23 = M32, 
                    
                    M30 = M03, 
                    M31 = M13, 
                    M32 = M23, 
                    M33 = M33
                };
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M44l operator *(M44l a, M44l b)
        {
            return new M44l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33, 
                a.M30 * b.M00 + a.M31 * b.M10 + a.M32 * b.M20 + a.M33 * b.M30, 
                a.M30 * b.M01 + a.M31 * b.M11 + a.M32 * b.M21 + a.M33 * b.M31, 
                a.M30 * b.M02 + a.M31 * b.M12 + a.M32 * b.M22 + a.M33 * b.M32, 
                a.M30 * b.M03 + a.M31 * b.M13 + a.M32 * b.M23 + a.M33 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (long)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (long)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (long)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (long)value;
        }

        #endregion
    }

    public class M44lEqualityComparer : IEqualityComparer<M44l>
    {
        public static readonly M44lEqualityComparer Default
            = new M44lEqualityComparer();

        #region IEqualityComparer<M44l> Members

        public bool Equals(M44l v0, M44l v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M44l v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Norm1(M44l m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M44l m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMax(M44l m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMin(M44l m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M44l m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M03).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M13).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p) + 
                Fun.Abs(m.M23).Pow(p) + 
                Fun.Abs(m.M30).Pow(p) + 
                Fun.Abs(m.M31).Pow(p) + 
                Fun.Abs(m.M32).Pow(p) + 
                Fun.Abs(m.M33).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static long Distance1(this M44l a, M44l b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23) + 
                Fun.Abs(b.M30 - a.M30) + 
                Fun.Abs(b.M31 - a.M31) + 
                Fun.Abs(b.M32 - a.M32) + 
                Fun.Abs(b.M33 - a.M33);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M44l a, M44l b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23) + 
                        Fun.Square(b.M30 - a.M30) + 
                        Fun.Square(b.M31 - a.M31) + 
                        Fun.Square(b.M32 - a.M32) + 
                        Fun.Square(b.M33 - a.M33));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M44l a, M44l b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p) + 
                Fun.Abs(b.M30 - a.M30).Pow(p) + 
                Fun.Abs(b.M31 - a.M31).Pow(p) + 
                Fun.Abs(b.M32 - a.M32).Pow(p) + 
                Fun.Abs(b.M33 - a.M33).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMax(this M44l a, M44l b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Max(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMin(this M44l a, M44l b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Min(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l Transform(this M44l m, V4l v)
            => m * v;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l TransposedTransform(this M44l m, V4l v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by matrix m.
        /// </summary>
        public static V3l TransformDir(this M44l m, V3l v)
        {
            return new V3l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3l TransformPos(this M44l m, V3l p)
        {
            return new V3l(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Transforms point p (p.W is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3l TransformPosProj(this M44l m, V3l p)
        {
            long s = m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z + m.M33;
            return TransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (p.W is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V4l TransformPosProjFull(this M44l m, V3l p)
        {
            return new V4l(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23, 
                m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z + m.M33
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V3l TransposedTransformDir(this M44l m, V3l v)
        {
            return new V3l(
                m.M00 * v.X + m.M10 * v.Y + m.M20 * v.Z, 
                m.M01 * v.X + m.M11 * v.Y + m.M21 * v.Z, 
                m.M02 * v.X + m.M12 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3l TransposedTransformPos(this M44l m, V3l p)
        {
            return new V3l(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3l TransposedTransformProj(this M44l m, V3l p)
        {
            var s = m.M03 * p.X + m.M13 * p.Y + m.M23 * p.Z + m.M33;
            return TransposedTransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V4l TransposedTransformProjFull(this M44l m, V3l p)
        {
            return new V4l(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32, 
                m.M03 * p.X + m.M13 * p.Y + m.M23 * p.Z + m.M33
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M44l"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static M33l Minor(this M44l m, int row, int column)
        {
            M33l rs = new M33l();

            for (int k = 0; k < 9; k++)
            {
                var i = k / 9;
                var j = k % 9;

                if (i != row && j != column)
                {
                    rs[k] = m[k];
                }
            }

            return rs;
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l Row(this M44l m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                case 2: return m.R2;
                case 3: return m.R3;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l Column(this M44l m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                case 2: return m.C2;
                case 3: return m.C3;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Determinant(M44l m)
            => m.Determinant;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        public static void Transpose(this ref M44l m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
            Fun.Swap(ref m.M20, ref m.M02);
            Fun.Swap(ref m.M21, ref m.M12);
            Fun.Swap(ref m.M30, ref m.M03);
            Fun.Swap(ref m.M31, ref m.M13);
            Fun.Swap(ref m.M32, ref m.M23);
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M44l a, M44l b, long epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M44f

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M44f : IValidity, IMatrix<double>
    {
        [DataMember]
        public float M00, M01, M02, M03;
        [DataMember]
        public float M10, M11, M12, M13;
        [DataMember]
        public float M20, M21, M22, M23;
        [DataMember]
        public float M30, M31, M32, M33;

        #region Constructors

        public M44f(float value)
        {
            M00 = value; M01 = value; M02 = value; M03 = value; 
            M10 = value; M11 = value; M12 = value; M13 = value; 
            M20 = value; M21 = value; M22 = value; M23 = value; 
            M30 = value; M31 = value; M32 = value; M33 = value; 
        }

        public M44f(
                float m00, float m01, float m02, float m03, 
                float m10, float m11, float m12, float m13, 
                float m20, float m21, float m22, float m23, 
                float m30, float m31, float m32, float m33)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
            M30 = m30; M31 = m31; M32 = m32; M33 = m33; 
        }

        public M44f(float[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
            M30 = a[12];
            M31 = a[13];
            M32 = a[14];
            M33 = a[15];
        }

        public M44f(float[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
            M30 = a[start + 12];
            M31 = a[start + 13];
            M32 = a[start + 14];
            M33 = a[start + 15];
        }

        public M44f(M22i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44f(M23i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44f(M33i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44f(M34i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44f(M44i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
            M30 = (float)m.M30; M31 = (float)m.M31; M32 = (float)m.M32; M33 = (float)m.M33; 
        }

        public M44f(M22l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44f(M23l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44f(M33l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44f(M34l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44f(M44l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
            M30 = (float)m.M30; M31 = (float)m.M31; M32 = (float)m.M32; M33 = (float)m.M33; 
        }

        public M44f(M22f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44f(M23f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44f(M33f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44f(M34f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = m.M03; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = m.M13; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44f(M22d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44f(M23d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44f(M33d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44f(M34d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44f(M44d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
            M30 = (float)m.M30; M31 = (float)m.M31; M32 = (float)m.M32; M33 = (float)m.M33; 
        }

        #endregion

        #region Conversions

        public static explicit operator M44f(M22i m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M23i m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M33i m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M34i m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M44i m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
                M30 = (float)m.M30, M31 = (float)m.M31, M32 = (float)m.M32, M33 = (float)m.M33, 
            };
        }

        public static explicit operator M44f(M22l m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M23l m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M33l m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M34l m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M44l m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
                M30 = (float)m.M30, M31 = (float)m.M31, M32 = (float)m.M32, M33 = (float)m.M33, 
            };
        }

        public static explicit operator M44f(M22f m)
        {
            return new M44f {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M23f m)
        {
            return new M44f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M33f m)
        {
            return new M44f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M34f m)
        {
            return new M44f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M22d m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M23d m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M33d m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M34d m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M44d m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
                M30 = (float)m.M30, M31 = (float)m.M31, M32 = (float)m.M32, M33 = (float)m.M33, 
            };
        }

        public static explicit operator M44f(int[] a)
        {
            return new M44f(
                (float)a[0], (float)a[1], (float)a[2], (float)a[3], 
                (float)a[4], (float)a[5], (float)a[6], (float)a[7], 
                (float)a[8], (float)a[9], (float)a[10], (float)a[11], 
                (float)a[12], (float)a[13], (float)a[14], (float)a[15]);
        }

        public static explicit operator M44f(int[,] a)
        {
            return new M44f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], (float)a[0, 3], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], (float)a[1, 3], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2], (float)a[2, 3], 
                (float)a[3, 0], (float)a[3, 1], (float)a[3, 2], (float)a[3, 3]);
        }

        public static explicit operator int[](M44f m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03, 
                (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13, 
                (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23, 
                (int)m.M30, (int)m.M31, (int)m.M32, (int)m.M33
            };
        }

        public static explicit operator int[,](M44f m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23 }, 
                { (int)m.M30, (int)m.M31, (int)m.M32, (int)m.M33 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M03;
            array[index + 4] = (int)M10;
            array[index + 5] = (int)M11;
            array[index + 6] = (int)M12;
            array[index + 7] = (int)M13;
            array[index + 8] = (int)M20;
            array[index + 9] = (int)M21;
            array[index + 10] = (int)M22;
            array[index + 11] = (int)M23;
            array[index + 12] = (int)M30;
            array[index + 13] = (int)M31;
            array[index + 14] = (int)M32;
            array[index + 15] = (int)M33;
        }

        public static explicit operator M44f(long[] a)
        {
            return new M44f(
                (float)a[0], (float)a[1], (float)a[2], (float)a[3], 
                (float)a[4], (float)a[5], (float)a[6], (float)a[7], 
                (float)a[8], (float)a[9], (float)a[10], (float)a[11], 
                (float)a[12], (float)a[13], (float)a[14], (float)a[15]);
        }

        public static explicit operator M44f(long[,] a)
        {
            return new M44f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], (float)a[0, 3], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], (float)a[1, 3], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2], (float)a[2, 3], 
                (float)a[3, 0], (float)a[3, 1], (float)a[3, 2], (float)a[3, 3]);
        }

        public static explicit operator long[](M44f m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03, 
                (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13, 
                (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23, 
                (long)m.M30, (long)m.M31, (long)m.M32, (long)m.M33
            };
        }

        public static explicit operator long[,](M44f m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23 }, 
                { (long)m.M30, (long)m.M31, (long)m.M32, (long)m.M33 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M03;
            array[index + 4] = (long)M10;
            array[index + 5] = (long)M11;
            array[index + 6] = (long)M12;
            array[index + 7] = (long)M13;
            array[index + 8] = (long)M20;
            array[index + 9] = (long)M21;
            array[index + 10] = (long)M22;
            array[index + 11] = (long)M23;
            array[index + 12] = (long)M30;
            array[index + 13] = (long)M31;
            array[index + 14] = (long)M32;
            array[index + 15] = (long)M33;
        }

        public static explicit operator M44f(float[] a)
        {
            return new M44f(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11], 
                a[12], a[13], a[14], a[15]);
        }

        public static explicit operator M44f(float[,] a)
        {
            return new M44f(
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3], 
                a[3, 0], a[3, 1], a[3, 2], a[3, 3]);
        }

        public static explicit operator float[](M44f m)
        {
            return new float[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23, 
                m.M30, m.M31, m.M32, m.M33
            };
        }

        public static explicit operator float[,](M44f m)
        {
            return new float[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }, 
                { m.M30, m.M31, m.M32, m.M33 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
            array[index + 12] = M30;
            array[index + 13] = M31;
            array[index + 14] = M32;
            array[index + 15] = M33;
        }

        public static explicit operator M44f(double[] a)
        {
            return new M44f(
                (float)a[0], (float)a[1], (float)a[2], (float)a[3], 
                (float)a[4], (float)a[5], (float)a[6], (float)a[7], 
                (float)a[8], (float)a[9], (float)a[10], (float)a[11], 
                (float)a[12], (float)a[13], (float)a[14], (float)a[15]);
        }

        public static explicit operator M44f(double[,] a)
        {
            return new M44f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], (float)a[0, 3], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], (float)a[1, 3], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2], (float)a[2, 3], 
                (float)a[3, 0], (float)a[3, 1], (float)a[3, 2], (float)a[3, 3]);
        }

        public static explicit operator double[](M44f m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03, 
                (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13, 
                (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23, 
                (double)m.M30, (double)m.M31, (double)m.M32, (double)m.M33
            };
        }

        public static explicit operator double[,](M44f m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23 }, 
                { (double)m.M30, (double)m.M31, (double)m.M32, (double)m.M33 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M03;
            array[index + 4] = (double)M10;
            array[index + 5] = (double)M11;
            array[index + 6] = (double)M12;
            array[index + 7] = (double)M13;
            array[index + 8] = (double)M20;
            array[index + 9] = (double)M21;
            array[index + 10] = (double)M22;
            array[index + 11] = (double)M23;
            array[index + 12] = (double)M30;
            array[index + 13] = (double)M31;
            array[index + 14] = (double)M32;
            array[index + 15] = (double)M33;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<float, int> element_fun)
        {
            return new M44i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<float, int, int, int> element_index0_index1_fun)
        {
            return new M44i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<float, long> element_fun)
        {
            return new M44l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<float, int, int, long> element_index0_index1_fun)
        {
            return new M44l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<float, float> element_fun)
        {
            return new M44f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<float, int, int, float> element_index0_index1_fun)
        {
            return new M44f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<float, double> element_fun)
        {
            return new M44d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<float, int, int, double> element_index0_index1_fun)
        {
            return new M44d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M33f UpperLeftM33()
        {
            return (M33f)this;
        }

        public float[] ToArray()
        {
            var array = new float[16];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            array[12] = M30;
            array[13] = M31;
            array[14] = M32;
            array[15] = M33;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f FromCols(V4f col0, V4f col1, V4f col2, V4f col3)
        {
            return new M44f(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z, 
                col0.W, col1.W, col2.W, col3.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f FromRows(V4f row0, V4f row1, V4f row2, V4f row3)
        {
            return new M44f(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W, 
                row3.X, row3.Y, row3.Z, row3.W);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M44f"/> using 4 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Scale(float tX, float tY, float tZ, float tW)
        {
            return new M44f(
                tX, 0, 0, 0, 
                0, tY, 0, 0, 
                0, 0, tZ, 0, 
                0, 0, 0, tW);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44f"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Scale(float tX, float tY, float tZ)
        {
            return new M44f(
                tX, 0, 0, 0, 
                0, tY, 0, 0, 
                0, 0, tZ, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44f"/> using a <see cref="V4f"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Scale(V4f s)
        {
            return new M44f(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, s.W);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44f"/> using a <see cref="V3f"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Scale(V3f s)
        {
            return new M44f(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a scaling transformation <see cref="M44f"/> from a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Scale(Scale3f s)
        {
            return new M44f(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, 0);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M44f"/> with the translational component given by 3 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Translation(float tX, float tY, float tZ)
        {
            return new M44f(
                1, 0, 0, tX, 
                0, 1, 0, tY, 
                0, 0, 1, tZ, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44f"/> with the translational component given by a <see cref="V3f"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Translation(V3f t)
        {
            return new M44f(
                1, 0, 0, t.X, 
                0, 1, 0, t.Y, 
                0, 0, 1, t.Z, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44f"/> from a <see cref="Shift3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Translation(Shift3f s)
        {
            return new M44f(
                1, 0, 0, s.X, 
                0, 1, 0, s.Y, 
                0, 0, 1, s.Z, 
                0, 0, 0, 1);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 3D rotation matrix from a <see cref="Rot3f"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Rotation(Rot3f r)
            => (M44f)r;

        /// <summary>
        /// Creates a 3D rotation matrix from an axis vector and an angle in radians.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Rotation(V3f normalizedAxis, float angleInRadians)
        {
            Debug.Assert(normalizedAxis.LengthSquared.ApproximateEquals(1));
            return (M44f)(Rot3f.Rotation(normalizedAxis, angleInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z). 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f RotationEuler(float rollInRadians, float pitchInRadians, float yawInRadians)
        {
            return (M44f)(Rot3f.RotationEuler(rollInRadians, pitchInRadians, yawInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) Vector.
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f RotationEuler(V3f roll_pitch_yaw_inRadians)
        {
            return (M44f)(Rot3f.RotationEuler(
                roll_pitch_yaw_inRadians.X,
                roll_pitch_yaw_inRadians.Y,
                roll_pitch_yaw_inRadians.Z));
        }

        /// <summary>
        /// Creates a 3D rotation matrix which rotates one vector into another.
        /// The input vectors have to be normalized.
        /// </summary>
        public static M44f RotateInto(V3f from, V3f into)
        {
            Debug.Assert(from.LengthSquared.ApproximateEquals(1));
            Debug.Assert(into.LengthSquared.ApproximateEquals(1));
            return (M44f)(Rot3f.RotateInto(from, into));
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the X-Axis.
        /// </summary>
        public static M44f RotationX(float angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M44f(
                 1,  0,  0,  0, 
                 0,  a, -b,  0, 
                 0,  b,  a,  0, 
                 0,  0,  0,  1);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the Y-Axis.
        /// </summary>
        public static M44f RotationY(float angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M44f(
                 a,  0,  b,  0, 
                 0,  1,  0,  0, 
                -b,  0,  a,  0, 
                 0,  0,  0,  1);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the Z-Axis.
        /// </summary>
        public static M44f RotationZ(float angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M44f(
                 a, -b,  0,  0, 
                 b,  a,  0,  0, 
                 0,  0,  1,  0, 
                 0,  0,  0,  1);
        }

        #endregion

        #region Shearing

        public static M44f ShearXY(float factorX, float factorY)
        {
            return new M44f(
                1, 0, factorX, 0, 
                0, 1, factorY, 0, 
                0, 0, 1, 0, 
                0, 0, 0, 1);
        }

        public static M44f ShearXZ(float factorX, float factorZ)
        {
            return new M44f(
                1, factorX, 0, 0, 
                0, 1, 0, 0, 
                0, factorZ, 1, 0, 
                0, 0, 0, 1);
        }

        public static M44f ShearYZ(float factorY, float factorZ)
        {
            return new M44f(
                1, 0, 0, 0, 
                factorY, 1, 0, 0, 
                factorZ, 0, 1, 0, 
                0, 0, 0, 1);
        }

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<float> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M03;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M13;
                yield return M20;
                yield return M21;
                yield return M22;
                yield return M23;
                yield return M30;
                yield return M31;
                yield return M32;
                yield return M33;
            }
        }

        public IEnumerable<V4f> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
                yield return R3;
            }
        }

        public IEnumerable<V4f> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        public V4f R0
        {
            get { return new V4f( M00,  M01,  M02,  M03); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        public V4f R1
        {
            get { return new V4f( M10,  M11,  M12,  M13); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        public V4f R2
        {
            get { return new V4f( M20,  M21,  M22,  M23); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        public V4f R3
        {
            get { return new V4f( M30,  M31,  M32,  M33); }
            set
            {
                M30 = value.X;
                M31 = value.Y;
                M32 = value.Z;
                M33 = value.W;
            }
        }

        public V4f C0
        {
            get { return new V4f( M00,  M10,  M20,  M30); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
                M30 = value.W;
            }
        }

        public V4f C1
        {
            get { return new V4f( M01,  M11,  M21,  M31); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
                M31 = value.W;
            }
        }

        public V4f C2
        {
            get { return new V4f( M02,  M12,  M22,  M32); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
                M32 = value.W;
            }
        }

        public V4f C3
        {
            get { return new V4f( M03,  M13,  M23,  M33); }
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
                M33 = value.W;
            }
        }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M03;
                    case 4: return M10;
                    case 5: return M11;
                    case 6: return M12;
                    case 7: return M13;
                    case 8: return M20;
                    case 9: return M21;
                    case 10: return M22;
                    case 11: return M23;
                    case 12: return M30;
                    case 13: return M31;
                    case 14: return M32;
                    case 15: return M33;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M03 = value; return;
                    case 4: M10 = value; return;
                    case 5: M11 = value; return;
                    case 6: M12 = value; return;
                    case 7: M13 = value; return;
                    case 8: M20 = value; return;
                    case 9: M21 = value; return;
                    case 10: M22 = value; return;
                    case 11: M23 = value; return;
                    case 12: M30 = value; return;
                    case 13: M31 = value; return;
                    case 14: M32 = value; return;
                    case 15: M33 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public float this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            case 2: return M02;
                            case 3: return M03;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            case 2: return M12;
                            case 3: return M13;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: return M20;
                            case 1: return M21;
                            case 2: return M22;
                            case 3: return M23;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 3: switch (column)
                        {
                            case 0: return M30;
                            case 1: return M31;
                            case 2: return M32;
                            case 3: return M33;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            case 2: M02 = value; return;
                            case 3: M03 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            case 2: M12 = value; return;
                            case 3: M13 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: M20 = value; return;
                            case 1: M21 = value; return;
                            case 2: M22 = value; return;
                            case 3: M23 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 3: switch (column)
                        {
                            case 0: M30 = value; return;
                            case 1: M31 = value; return;
                            case 2: M32 = value; return;
                            case 3: M33 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 4;
        public const int ColumnCount = 4;
        public const int ElementCount = 4 * 4;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(4, 4);
        }

        public static M44f Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M44f(0);
        }

        public static M44f Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M44f(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public float Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23) + 
                    Fun.Abs(M30) + Fun.Abs(M31) + Fun.Abs(M32) + Fun.Abs(M33);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public float Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23 + 
                    M30 * M30 + M31 * M31 + M32 * M32 + M33 * M33);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public float NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Max(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public float NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Min(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M44f operator -(M44f m)
        {
            return new M44f(
                -m.M00, -m.M01, -m.M02, -m.M03, 
                -m.M10, -m.M11, -m.M12, -m.M13, 
                -m.M20, -m.M21, -m.M22, -m.M23, 
                -m.M30, -m.M31, -m.M32, -m.M33);
        }

        public static M44f operator  + (M44f a, M44f b)
        {
            return new M44f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44f operator  + (M44f m, float s)
        {
            return new M44f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        public static M44f operator  + (float s, M44f m)
        {
            return new M44f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44d operator  + (M44f a, M44d b)
        {
            return new M44d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44d operator  + (M44f m, double s)
        {
            return new M44d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        public static M44d operator  + (double s, M44f m)
        {
            return new M44d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44f operator  - (M44f a, M44f b)
        {
            return new M44f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44f operator  - (M44f m, float s)
        {
            return new M44f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        public static M44f operator  - (float s, M44f m)
        {
            return new M44f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44d operator  - (M44f a, M44d b)
        {
            return new M44d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44d operator  - (M44f m, double s)
        {
            return new M44d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        public static M44d operator  - (double s, M44f m)
        {
            return new M44d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44f operator  % (M44f a, M44f b)
        {
            return new M44f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44f operator  % (M44f m, float s)
        {
            return new M44f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        public static M44f operator  % (float s, M44f m)
        {
            return new M44f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44d operator  % (M44f a, M44d b)
        {
            return new M44d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44d operator  % (M44f m, double s)
        {
            return new M44d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        public static M44d operator  % (double s, M44f m)
        {
            return new M44d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44f operator  / (M44f a, M44f b)
        {
            return new M44f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44f operator  / (M44f m, float s)
        {
            return new M44f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        public static M44f operator  / (float s, M44f m)
        {
            return new M44f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44d operator  / (M44f a, M44d b)
        {
            return new M44d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44d operator  / (M44f m, double s)
        {
            return new M44d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        public static M44d operator  / (double s, M44f m)
        {
            return new M44d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44f operator  * (M44f m, float s)
        {
            return new M44f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        public static M44f operator  * (float s, M44f m)
        {
            return new M44f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44d operator  * (M44f m, double s)
        {
            return new M44d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        public static M44d operator  * (double s, M44f m)
        {
            return new M44d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M44f matrix with a V4f column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f operator *(M44f m, V4f v)
        {
            return new V4f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W, 
                m.M30 * v.X + m.M31 * v.Y + m.M32 * v.Z + m.M33 * v.W);
        }

        /// <summary>
        /// Multiplies a V4f row vector with a M44f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f operator *(V4f v, M44f m)
        {
            return new V4f(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20 + v.W * m.M30, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21 + v.W * m.M31, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22 + v.W * m.M32, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23 + v.W * m.M33);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M44f a, M44f b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23 && 
                a.M30 < b.M30 && 
                a.M31 < b.M31 && 
                a.M32 < b.M32 && 
                a.M33 < b.M33;
        }

        public static bool operator <(M44f a, float s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s && 
                a.M30 < s && 
                a.M31 < s && 
                a.M32 < s && 
                a.M33 < s;
        }

        public static bool operator <(float s, M44f a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23  && 
                s < a.M30  && 
                s < a.M31  && 
                s < a.M32  && 
                s < a.M33 ;
        }

        public static bool operator >(M44f a, M44f b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23 && 
                a.M30 > b.M30 && 
                a.M31 > b.M31 && 
                a.M32 > b.M32 && 
                a.M33 > b.M33;
        }

        public static bool operator >(M44f a, float s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s && 
                a.M30 > s && 
                a.M31 > s && 
                a.M32 > s && 
                a.M33 > s;
        }

        public static bool operator >(float s, M44f a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23  && 
                s > a.M30  && 
                s > a.M31  && 
                s > a.M32  && 
                s > a.M33 ;
        }

        public static bool operator ==(M44f a, M44f b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23 && 
                a.M30 == b.M30 && 
                a.M31 == b.M31 && 
                a.M32 == b.M32 && 
                a.M33 == b.M33;
        }

        public static bool operator ==(M44f a, float s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s && 
                a.M30 == s && 
                a.M31 == s && 
                a.M32 == s && 
                a.M33 == s;
        }

        public static bool operator ==(float s, M44f a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23  && 
                s == a.M30  && 
                s == a.M31  && 
                s == a.M32  && 
                s == a.M33 ;
        }

        public static bool operator <=(M44f a, M44f b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23 && 
                a.M30 <= b.M30 && 
                a.M31 <= b.M31 && 
                a.M32 <= b.M32 && 
                a.M33 <= b.M33;
        }

        public static bool operator <=(M44f a, float s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s && 
                a.M30 <= s && 
                a.M31 <= s && 
                a.M32 <= s && 
                a.M33 <= s;
        }

        public static bool operator <=(float s, M44f a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23  && 
                s <= a.M30  && 
                s <= a.M31  && 
                s <= a.M32  && 
                s <= a.M33 ;
        }

        public static bool operator >=(M44f a, M44f b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23 && 
                a.M30 >= b.M30 && 
                a.M31 >= b.M31 && 
                a.M32 >= b.M32 && 
                a.M33 >= b.M33;
        }

        public static bool operator >=(M44f a, float s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s && 
                a.M30 >= s && 
                a.M31 >= s && 
                a.M32 >= s && 
                a.M33 >= s;
        }

        public static bool operator >=(float s, M44f a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23  && 
                s >= a.M30  && 
                s >= a.M31  && 
                s >= a.M32  && 
                s >= a.M33 ;
        }

        public static bool operator !=(M44f a, M44f b)
        {
            return !(a == b);
        }

        public static bool operator !=(M44f m, float s)
        {
            return !(m == s);
        }

        public static bool operator !=(float s, M44f m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), M03.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), M13.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode(), M23.GetHashCode(), 
                M30.GetHashCode(), M31.GetHashCode(), M32.GetHashCode(), M33.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M44f) ? (this == (M44f)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R3.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M44f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M44f.FromRows(
                V4f.Parse(x[0]), 
                V4f.Parse(x[1]), 
                V4f.Parse(x[2]), 
                V4f.Parse(x[3])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M44f Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                M44f result = new M44f();
                for (int row = 0; row < 4; row++)
                {
                    for (int col = 0; col < 4; col++)
                    {
                        if (((col + row) % 2) == 0)
                            result[col, row] = this.Minor(row, col).Determinant;
                        else
                            result[col, row] = -this.Minor(row, col).Determinant;
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public float Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 + M22 + M33 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public float Determinant
        {
            get
            {
                // using bottom row because elements M30, M31, and M32
                // are zero most of the time.
                float d = 0;
                if (M30 != 0.0f) d -= M30 * (
                M01 * M12 * M23 + M02 * M13 * M21 + M03 * M11 * M22
                - M21 * M12 * M03 - M22 * M13 * M01 - M23 * M11 * M02
                );
                if (M31 != 0.0f) d += M31 * (
                M00 * M12 * M23 + M02 * M13 * M20 + M03 * M10 * M22
                - M20 * M12 * M03 - M22 * M13 * M00 - M23 * M10 * M02
                );
                if (M32 != 0.0f) d -= M32 * (
                M00 * M11 * M23 + M01 * M13 * M20 + M03 * M10 * M21
                - M20 * M11 * M03 - M21 * M13 * M00 - M23 * M10 * M01
                );
                if (M33 != 0.0f) d += M33 * (
                M00 * M11 * M22 + M01 * M12 * M20 + M02 * M10 * M21
                - M20 * M11 * M02 - M21 * M12 * M00 - M22 * M10 * M01
                );
                return d;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M44f Transposed
        {
            get
            {
                return new M44f {
                    
                    M00 = M00, 
                    M01 = M10, 
                    M02 = M20, 
                    M03 = M30, 
                    
                    M10 = M01, 
                    M11 = M11, 
                    M12 = M21, 
                    M13 = M31, 
                    
                    M20 = M02, 
                    M21 = M12, 
                    M22 = M22, 
                    M23 = M32, 
                    
                    M30 = M03, 
                    M31 = M13, 
                    M32 = M23, 
                    M33 = M33
                };
            }
        }

        private static V2l s_luSize = new V2l(4, 4);
        private static V2l s_luDelta = new V2l(1, 4);

        /// <summary>
        /// Inverts the given matrix using lu factorization in place. Returns true
        /// if the matrix was invertible, otherwise the matrix remains unchanged.
        /// </summary>
        public bool LuInvert()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return false;
            this = (M44f)(lu.LuInverse(p).Data);
            return true;
        }

        /// <summary>
        /// Returns the inverse of the matrix using lu factorization.
        /// If the matrix is not invertible, M44f.Zero is returned.
        /// </summary>
        public M44f LuInverse()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return M44f.Zero;
            return (M44f)(lu.LuInverse(p).Data);
        }

        /// <summary>
        /// Returns the inverse of this matrix. If the matrix is not invertible
        /// M44f.Zero is returned.
        /// </summary>
        public M44f Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => LuInverse();
        }

        #endregion

        #region Matrix Multiplication

        public static M44f operator *(M44f a, M44f b)
        {
            return new M44f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33, 
                a.M30 * b.M00 + a.M31 * b.M10 + a.M32 * b.M20 + a.M33 * b.M30, 
                a.M30 * b.M01 + a.M31 * b.M11 + a.M32 * b.M21 + a.M33 * b.M31, 
                a.M30 * b.M02 + a.M31 * b.M12 + a.M32 * b.M22 + a.M33 * b.M32, 
                a.M30 * b.M03 + a.M31 * b.M13 + a.M32 * b.M23 + a.M33 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (float)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (float)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (float)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (float)value;
        }

        #endregion
    }

    public class M44fEqualityComparer : IEqualityComparer<M44f>
    {
        public static readonly M44fEqualityComparer Default
            = new M44fEqualityComparer();

        #region IEqualityComparer<M44f> Members

        public bool Equals(M44f v0, M44f v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M44f v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm1(M44f m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm2(M44f m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMax(M44f m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMin(M44f m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm(this M44f m, float p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M03).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M13).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p) + 
                Fun.Abs(m.M23).Pow(p) + 
                Fun.Abs(m.M30).Pow(p) + 
                Fun.Abs(m.M31).Pow(p) + 
                Fun.Abs(m.M32).Pow(p) + 
                Fun.Abs(m.M33).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static float Distance1(this M44f a, M44f b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23) + 
                Fun.Abs(b.M30 - a.M30) + 
                Fun.Abs(b.M31 - a.M31) + 
                Fun.Abs(b.M32 - a.M32) + 
                Fun.Abs(b.M33 - a.M33);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static float Distance2(this M44f a, M44f b)
        {
            return (float)Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23) + 
                        Fun.Square(b.M30 - a.M30) + 
                        Fun.Square(b.M31 - a.M31) + 
                        Fun.Square(b.M32 - a.M32) + 
                        Fun.Square(b.M33 - a.M33));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static float Distance(this M44f a, M44f b, float p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p) + 
                Fun.Abs(b.M30 - a.M30).Pow(p) + 
                Fun.Abs(b.M31 - a.M31).Pow(p) + 
                Fun.Abs(b.M32 - a.M32).Pow(p) + 
                Fun.Abs(b.M33 - a.M33).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMax(this M44f a, M44f b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Max(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMin(this M44f a, M44f b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Min(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f Transform(this M44f m, V4f v)
            => m * v;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f TransposedTransform(this M44f m, V4f v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by matrix m.
        /// </summary>
        public static V3f TransformDir(this M44f m, V3f v)
        {
            return new V3f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3f TransformPos(this M44f m, V3f p)
        {
            return new V3f(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Transforms point p (p.W is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3f TransformPosProj(this M44f m, V3f p)
        {
            float s = m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z + m.M33;
            return TransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (p.W is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V4f TransformPosProjFull(this M44f m, V3f p)
        {
            return new V4f(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23, 
                m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z + m.M33
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V3f TransposedTransformDir(this M44f m, V3f v)
        {
            return new V3f(
                m.M00 * v.X + m.M10 * v.Y + m.M20 * v.Z, 
                m.M01 * v.X + m.M11 * v.Y + m.M21 * v.Z, 
                m.M02 * v.X + m.M12 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3f TransposedTransformPos(this M44f m, V3f p)
        {
            return new V3f(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3f TransposedTransformProj(this M44f m, V3f p)
        {
            var s = m.M03 * p.X + m.M13 * p.Y + m.M23 * p.Z + m.M33;
            return TransposedTransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V4f TransposedTransformProjFull(this M44f m, V3f p)
        {
            return new V4f(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32, 
                m.M03 * p.X + m.M13 * p.Y + m.M23 * p.Z + m.M33
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M44f"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static M33f Minor(this M44f m, int row, int column)
        {
            M33f rs = new M33f();

            for (int k = 0; k < 9; k++)
            {
                var i = k / 9;
                var j = k % 9;

                if (i != row && j != column)
                {
                    rs[k] = m[k];
                }
            }

            return rs;
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f Row(this M44f m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                case 2: return m.R2;
                case 3: return m.R3;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f Column(this M44f m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                case 2: return m.C2;
                case 3: return m.C3;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Determinant(M44f m)
            => m.Determinant;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        public static void Transpose(this ref M44f m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
            Fun.Swap(ref m.M20, ref m.M02);
            Fun.Swap(ref m.M21, ref m.M12);
            Fun.Swap(ref m.M30, ref m.M03);
            Fun.Swap(ref m.M31, ref m.M13);
            Fun.Swap(ref m.M32, ref m.M23);
        }

        /// <summary>
        /// Inverts the given matrix in place. Returns true if the matrix was invertible,
        /// otherwise the matrix remains unchanged.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Invert(this ref M44f m) { return m.LuInvert(); }

        /// <summary>
        /// Returns if the given matrix is the identity matrix I.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsIdentity(this M44f m, float epsilon)
        {
            return Fun.ApproximateEquals(m, M44f.Identity, epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthonormal(this M44f m, float epsilon)
        {
            var i = m * m.Transposed;
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthogonal(this M44f m, float epsilon)
        {
            var i = m * m.Transposed;
            for (int j = 0; j < 4; j++)
                i[j, j] = 1; //inefficient implementation: just leave out the comparisons at the diagonal entries.
            return i.IsIdentity(epsilon);
        }
        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M44f a, M44f b, float epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

    #region M44d

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M44d : IValidity, IMatrix<double>
    {
        [DataMember]
        public double M00, M01, M02, M03;
        [DataMember]
        public double M10, M11, M12, M13;
        [DataMember]
        public double M20, M21, M22, M23;
        [DataMember]
        public double M30, M31, M32, M33;

        #region Constructors

        public M44d(double value)
        {
            M00 = value; M01 = value; M02 = value; M03 = value; 
            M10 = value; M11 = value; M12 = value; M13 = value; 
            M20 = value; M21 = value; M22 = value; M23 = value; 
            M30 = value; M31 = value; M32 = value; M33 = value; 
        }

        public M44d(
                double m00, double m01, double m02, double m03, 
                double m10, double m11, double m12, double m13, 
                double m20, double m21, double m22, double m23, 
                double m30, double m31, double m32, double m33)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
            M30 = m30; M31 = m31; M32 = m32; M33 = m33; 
        }

        public M44d(double[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
            M30 = a[12];
            M31 = a[13];
            M32 = a[14];
            M33 = a[15];
        }

        public M44d(double[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
            M30 = a[start + 12];
            M31 = a[start + 13];
            M32 = a[start + 14];
            M33 = a[start + 15];
        }

        public M44d(M22i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44d(M23i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44d(M33i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44d(M34i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44d(M44i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
            M30 = (double)m.M30; M31 = (double)m.M31; M32 = (double)m.M32; M33 = (double)m.M33; 
        }

        public M44d(M22l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44d(M23l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44d(M33l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44d(M34l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44d(M44l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
            M30 = (double)m.M30; M31 = (double)m.M31; M32 = (double)m.M32; M33 = (double)m.M33; 
        }

        public M44d(M22f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44d(M23f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44d(M33f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44d(M34f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44d(M44f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
            M30 = (double)m.M30; M31 = (double)m.M31; M32 = (double)m.M32; M33 = (double)m.M33; 
        }

        public M44d(M22d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44d(M23d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44d(M33d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        public M44d(M34d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = m.M03; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = m.M13; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        #endregion

        #region Conversions

        public static explicit operator M44d(M22i m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M23i m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M33i m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M34i m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M44i m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
                M30 = (double)m.M30, M31 = (double)m.M31, M32 = (double)m.M32, M33 = (double)m.M33, 
            };
        }

        public static explicit operator M44d(M22l m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M23l m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M33l m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M34l m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M44l m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
                M30 = (double)m.M30, M31 = (double)m.M31, M32 = (double)m.M32, M33 = (double)m.M33, 
            };
        }

        public static explicit operator M44d(M22f m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M23f m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M33f m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M34f m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M44f m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
                M30 = (double)m.M30, M31 = (double)m.M31, M32 = (double)m.M32, M33 = (double)m.M33, 
            };
        }

        public static explicit operator M44d(M22d m)
        {
            return new M44d {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M23d m)
        {
            return new M44d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M33d m)
        {
            return new M44d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M34d m)
        {
            return new M44d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(int[] a)
        {
            return new M44d(
                (double)a[0], (double)a[1], (double)a[2], (double)a[3], 
                (double)a[4], (double)a[5], (double)a[6], (double)a[7], 
                (double)a[8], (double)a[9], (double)a[10], (double)a[11], 
                (double)a[12], (double)a[13], (double)a[14], (double)a[15]);
        }

        public static explicit operator M44d(int[,] a)
        {
            return new M44d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], (double)a[0, 3], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], (double)a[1, 3], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2], (double)a[2, 3], 
                (double)a[3, 0], (double)a[3, 1], (double)a[3, 2], (double)a[3, 3]);
        }

        public static explicit operator int[](M44d m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03, 
                (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13, 
                (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23, 
                (int)m.M30, (int)m.M31, (int)m.M32, (int)m.M33
            };
        }

        public static explicit operator int[,](M44d m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23 }, 
                { (int)m.M30, (int)m.M31, (int)m.M32, (int)m.M33 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M03;
            array[index + 4] = (int)M10;
            array[index + 5] = (int)M11;
            array[index + 6] = (int)M12;
            array[index + 7] = (int)M13;
            array[index + 8] = (int)M20;
            array[index + 9] = (int)M21;
            array[index + 10] = (int)M22;
            array[index + 11] = (int)M23;
            array[index + 12] = (int)M30;
            array[index + 13] = (int)M31;
            array[index + 14] = (int)M32;
            array[index + 15] = (int)M33;
        }

        public static explicit operator M44d(long[] a)
        {
            return new M44d(
                (double)a[0], (double)a[1], (double)a[2], (double)a[3], 
                (double)a[4], (double)a[5], (double)a[6], (double)a[7], 
                (double)a[8], (double)a[9], (double)a[10], (double)a[11], 
                (double)a[12], (double)a[13], (double)a[14], (double)a[15]);
        }

        public static explicit operator M44d(long[,] a)
        {
            return new M44d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], (double)a[0, 3], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], (double)a[1, 3], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2], (double)a[2, 3], 
                (double)a[3, 0], (double)a[3, 1], (double)a[3, 2], (double)a[3, 3]);
        }

        public static explicit operator long[](M44d m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03, 
                (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13, 
                (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23, 
                (long)m.M30, (long)m.M31, (long)m.M32, (long)m.M33
            };
        }

        public static explicit operator long[,](M44d m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23 }, 
                { (long)m.M30, (long)m.M31, (long)m.M32, (long)m.M33 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M03;
            array[index + 4] = (long)M10;
            array[index + 5] = (long)M11;
            array[index + 6] = (long)M12;
            array[index + 7] = (long)M13;
            array[index + 8] = (long)M20;
            array[index + 9] = (long)M21;
            array[index + 10] = (long)M22;
            array[index + 11] = (long)M23;
            array[index + 12] = (long)M30;
            array[index + 13] = (long)M31;
            array[index + 14] = (long)M32;
            array[index + 15] = (long)M33;
        }

        public static explicit operator M44d(float[] a)
        {
            return new M44d(
                (double)a[0], (double)a[1], (double)a[2], (double)a[3], 
                (double)a[4], (double)a[5], (double)a[6], (double)a[7], 
                (double)a[8], (double)a[9], (double)a[10], (double)a[11], 
                (double)a[12], (double)a[13], (double)a[14], (double)a[15]);
        }

        public static explicit operator M44d(float[,] a)
        {
            return new M44d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], (double)a[0, 3], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], (double)a[1, 3], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2], (double)a[2, 3], 
                (double)a[3, 0], (double)a[3, 1], (double)a[3, 2], (double)a[3, 3]);
        }

        public static explicit operator float[](M44d m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03, 
                (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13, 
                (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23, 
                (float)m.M30, (float)m.M31, (float)m.M32, (float)m.M33
            };
        }

        public static explicit operator float[,](M44d m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23 }, 
                { (float)m.M30, (float)m.M31, (float)m.M32, (float)m.M33 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M03;
            array[index + 4] = (float)M10;
            array[index + 5] = (float)M11;
            array[index + 6] = (float)M12;
            array[index + 7] = (float)M13;
            array[index + 8] = (float)M20;
            array[index + 9] = (float)M21;
            array[index + 10] = (float)M22;
            array[index + 11] = (float)M23;
            array[index + 12] = (float)M30;
            array[index + 13] = (float)M31;
            array[index + 14] = (float)M32;
            array[index + 15] = (float)M33;
        }

        public static explicit operator M44d(double[] a)
        {
            return new M44d(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11], 
                a[12], a[13], a[14], a[15]);
        }

        public static explicit operator M44d(double[,] a)
        {
            return new M44d(
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3], 
                a[3, 0], a[3, 1], a[3, 2], a[3, 3]);
        }

        public static explicit operator double[](M44d m)
        {
            return new double[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23, 
                m.M30, m.M31, m.M32, m.M33
            };
        }

        public static explicit operator double[,](M44d m)
        {
            return new double[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }, 
                { m.M30, m.M31, m.M32, m.M33 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
            array[index + 12] = M30;
            array[index + 13] = M31;
            array[index + 14] = M32;
            array[index + 15] = M33;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<double, int> element_fun)
        {
            return new M44i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<double, int, int, int> element_index0_index1_fun)
        {
            return new M44i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<double, long> element_fun)
        {
            return new M44l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<double, int, int, long> element_index0_index1_fun)
        {
            return new M44l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<double, float> element_fun)
        {
            return new M44f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<double, int, int, float> element_index0_index1_fun)
        {
            return new M44f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<double, double> element_fun)
        {
            return new M44d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<double, int, int, double> element_index0_index1_fun)
        {
            return new M44d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M33d UpperLeftM33()
        {
            return (M33d)this;
        }

        public double[] ToArray()
        {
            var array = new double[16];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            array[12] = M30;
            array[13] = M31;
            array[14] = M32;
            array[15] = M33;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d FromCols(V4d col0, V4d col1, V4d col2, V4d col3)
        {
            return new M44d(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z, 
                col0.W, col1.W, col2.W, col3.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d FromRows(V4d row0, V4d row1, V4d row2, V4d row3)
        {
            return new M44d(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W, 
                row3.X, row3.Y, row3.Z, row3.W);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M44d"/> using 4 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Scale(double tX, double tY, double tZ, double tW)
        {
            return new M44d(
                tX, 0, 0, 0, 
                0, tY, 0, 0, 
                0, 0, tZ, 0, 
                0, 0, 0, tW);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44d"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Scale(double tX, double tY, double tZ)
        {
            return new M44d(
                tX, 0, 0, 0, 
                0, tY, 0, 0, 
                0, 0, tZ, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44d"/> using a <see cref="V4d"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Scale(V4d s)
        {
            return new M44d(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, s.W);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44d"/> using a <see cref="V3d"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Scale(V3d s)
        {
            return new M44d(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a scaling transformation <see cref="M44d"/> from a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Scale(Scale3d s)
        {
            return new M44d(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, 0);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M44d"/> with the translational component given by 3 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Translation(double tX, double tY, double tZ)
        {
            return new M44d(
                1, 0, 0, tX, 
                0, 1, 0, tY, 
                0, 0, 1, tZ, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44d"/> with the translational component given by a <see cref="V3d"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Translation(V3d t)
        {
            return new M44d(
                1, 0, 0, t.X, 
                0, 1, 0, t.Y, 
                0, 0, 1, t.Z, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44d"/> from a <see cref="Shift3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Translation(Shift3d s)
        {
            return new M44d(
                1, 0, 0, s.X, 
                0, 1, 0, s.Y, 
                0, 0, 1, s.Z, 
                0, 0, 0, 1);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 3D rotation matrix from a <see cref="Rot3d"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Rotation(Rot3d r)
            => (M44d)r;

        /// <summary>
        /// Creates a 3D rotation matrix from an axis vector and an angle in radians.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Rotation(V3d normalizedAxis, double angleInRadians)
        {
            Debug.Assert(normalizedAxis.LengthSquared.ApproximateEquals(1));
            return (M44d)(Rot3d.Rotation(normalizedAxis, angleInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z). 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d RotationEuler(double rollInRadians, double pitchInRadians, double yawInRadians)
        {
            return (M44d)(Rot3d.RotationEuler(rollInRadians, pitchInRadians, yawInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) Vector.
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d RotationEuler(V3d roll_pitch_yaw_inRadians)
        {
            return (M44d)(Rot3d.RotationEuler(
                roll_pitch_yaw_inRadians.X,
                roll_pitch_yaw_inRadians.Y,
                roll_pitch_yaw_inRadians.Z));
        }

        /// <summary>
        /// Creates a 3D rotation matrix which rotates one vector into another.
        /// The input vectors have to be normalized.
        /// </summary>
        public static M44d RotateInto(V3d from, V3d into)
        {
            Debug.Assert(from.LengthSquared.ApproximateEquals(1));
            Debug.Assert(into.LengthSquared.ApproximateEquals(1));
            return (M44d)(Rot3d.RotateInto(from, into));
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the X-Axis.
        /// </summary>
        public static M44d RotationX(double angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M44d(
                 1,  0,  0,  0, 
                 0,  a, -b,  0, 
                 0,  b,  a,  0, 
                 0,  0,  0,  1);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the Y-Axis.
        /// </summary>
        public static M44d RotationY(double angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M44d(
                 a,  0,  b,  0, 
                 0,  1,  0,  0, 
                -b,  0,  a,  0, 
                 0,  0,  0,  1);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the Z-Axis.
        /// </summary>
        public static M44d RotationZ(double angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M44d(
                 a, -b,  0,  0, 
                 b,  a,  0,  0, 
                 0,  0,  1,  0, 
                 0,  0,  0,  1);
        }

        #endregion

        #region Shearing

        public static M44d ShearXY(double factorX, double factorY)
        {
            return new M44d(
                1, 0, factorX, 0, 
                0, 1, factorY, 0, 
                0, 0, 1, 0, 
                0, 0, 0, 1);
        }

        public static M44d ShearXZ(double factorX, double factorZ)
        {
            return new M44d(
                1, factorX, 0, 0, 
                0, 1, 0, 0, 
                0, factorZ, 1, 0, 
                0, 0, 0, 1);
        }

        public static M44d ShearYZ(double factorY, double factorZ)
        {
            return new M44d(
                1, 0, 0, 0, 
                factorY, 1, 0, 0, 
                factorZ, 0, 1, 0, 
                0, 0, 0, 1);
        }

        #endregion

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<double> Elements
        {
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M03;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M13;
                yield return M20;
                yield return M21;
                yield return M22;
                yield return M23;
                yield return M30;
                yield return M31;
                yield return M32;
                yield return M33;
            }
        }

        public IEnumerable<V4d> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
                yield return R3;
            }
        }

        public IEnumerable<V4d> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        public V4d R0
        {
            get { return new V4d( M00,  M01,  M02,  M03); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        public V4d R1
        {
            get { return new V4d( M10,  M11,  M12,  M13); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        public V4d R2
        {
            get { return new V4d( M20,  M21,  M22,  M23); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        public V4d R3
        {
            get { return new V4d( M30,  M31,  M32,  M33); }
            set
            {
                M30 = value.X;
                M31 = value.Y;
                M32 = value.Z;
                M33 = value.W;
            }
        }

        public V4d C0
        {
            get { return new V4d( M00,  M10,  M20,  M30); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
                M30 = value.W;
            }
        }

        public V4d C1
        {
            get { return new V4d( M01,  M11,  M21,  M31); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
                M31 = value.W;
            }
        }

        public V4d C2
        {
            get { return new V4d( M02,  M12,  M22,  M32); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
                M32 = value.W;
            }
        }

        public V4d C3
        {
            get { return new V4d( M03,  M13,  M23,  M33); }
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
                M33 = value.W;
            }
        }

        public double this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M03;
                    case 4: return M10;
                    case 5: return M11;
                    case 6: return M12;
                    case 7: return M13;
                    case 8: return M20;
                    case 9: return M21;
                    case 10: return M22;
                    case 11: return M23;
                    case 12: return M30;
                    case 13: return M31;
                    case 14: return M32;
                    case 15: return M33;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M03 = value; return;
                    case 4: M10 = value; return;
                    case 5: M11 = value; return;
                    case 6: M12 = value; return;
                    case 7: M13 = value; return;
                    case 8: M20 = value; return;
                    case 9: M21 = value; return;
                    case 10: M22 = value; return;
                    case 11: M23 = value; return;
                    case 12: M30 = value; return;
                    case 13: M31 = value; return;
                    case 14: M32 = value; return;
                    case 15: M33 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public double this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: return M00;
                            case 1: return M01;
                            case 2: return M02;
                            case 3: return M03;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: return M10;
                            case 1: return M11;
                            case 2: return M12;
                            case 3: return M13;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: return M20;
                            case 1: return M21;
                            case 2: return M22;
                            case 3: return M23;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 3: switch (column)
                        {
                            case 0: return M30;
                            case 1: return M31;
                            case 2: return M32;
                            case 3: return M33;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                        {
                            case 0: M00 = value; return;
                            case 1: M01 = value; return;
                            case 2: M02 = value; return;
                            case 3: M03 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 1: switch (column)
                        {
                            case 0: M10 = value; return;
                            case 1: M11 = value; return;
                            case 2: M12 = value; return;
                            case 3: M13 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 2: switch (column)
                        {
                            case 0: M20 = value; return;
                            case 1: M21 = value; return;
                            case 2: M22 = value; return;
                            case 3: M23 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    case 3: switch (column)
                        {
                            case 0: M30 = value; return;
                            case 1: M31 = value; return;
                            case 2: M32 = value; return;
                            case 3: M33 = value; return;
                            default: throw new IndexOutOfRangeException();
                        }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 4;
        public const int ColumnCount = 4;
        public const int ElementCount = 4 * 4;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(4, 4);
        }

        public static M44d Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M44d(0);
        }

        public static M44d Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M44d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public double Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23) + 
                    Fun.Abs(M30) + Fun.Abs(M31) + Fun.Abs(M32) + Fun.Abs(M33);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23 + 
                    M30 * M30 + M31 * M31 + M32 * M32 + M33 * M33);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public double NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Max(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public double NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Min(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        #endregion

        #region Mathematical Operators

        public static M44d operator -(M44d m)
        {
            return new M44d(
                -m.M00, -m.M01, -m.M02, -m.M03, 
                -m.M10, -m.M11, -m.M12, -m.M13, 
                -m.M20, -m.M21, -m.M22, -m.M23, 
                -m.M30, -m.M31, -m.M32, -m.M33);
        }

        public static M44d operator  + (M44d a, M44d b)
        {
            return new M44d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44d operator  + (M44d m, double s)
        {
            return new M44d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        public static M44d operator  + (double s, M44d m)
        {
            return new M44d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44d operator  - (M44d a, M44d b)
        {
            return new M44d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44d operator  - (M44d m, double s)
        {
            return new M44d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        public static M44d operator  - (double s, M44d m)
        {
            return new M44d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44d operator  % (M44d a, M44d b)
        {
            return new M44d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44d operator  % (M44d m, double s)
        {
            return new M44d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        public static M44d operator  % (double s, M44d m)
        {
            return new M44d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44d operator  / (M44d a, M44d b)
        {
            return new M44d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44d operator  / (M44d m, double s)
        {
            return new M44d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        public static M44d operator  / (double s, M44d m)
        {
            return new M44d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44d operator  * (M44d m, double s)
        {
            return new M44d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        public static M44d operator  * (double s, M44d m)
        {
            return new M44d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M44d matrix with a V4d column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d operator *(M44d m, V4d v)
        {
            return new V4d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W, 
                m.M30 * v.X + m.M31 * v.Y + m.M32 * v.Z + m.M33 * v.W);
        }

        /// <summary>
        /// Multiplies a V4d row vector with a M44d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d operator *(V4d v, M44d m)
        {
            return new V4d(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20 + v.W * m.M30, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21 + v.W * m.M31, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22 + v.W * m.M32, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23 + v.W * m.M33);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M44d a, M44d b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23 && 
                a.M30 < b.M30 && 
                a.M31 < b.M31 && 
                a.M32 < b.M32 && 
                a.M33 < b.M33;
        }

        public static bool operator <(M44d a, double s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s && 
                a.M30 < s && 
                a.M31 < s && 
                a.M32 < s && 
                a.M33 < s;
        }

        public static bool operator <(double s, M44d a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23  && 
                s < a.M30  && 
                s < a.M31  && 
                s < a.M32  && 
                s < a.M33 ;
        }

        public static bool operator >(M44d a, M44d b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23 && 
                a.M30 > b.M30 && 
                a.M31 > b.M31 && 
                a.M32 > b.M32 && 
                a.M33 > b.M33;
        }

        public static bool operator >(M44d a, double s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s && 
                a.M30 > s && 
                a.M31 > s && 
                a.M32 > s && 
                a.M33 > s;
        }

        public static bool operator >(double s, M44d a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23  && 
                s > a.M30  && 
                s > a.M31  && 
                s > a.M32  && 
                s > a.M33 ;
        }

        public static bool operator ==(M44d a, M44d b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23 && 
                a.M30 == b.M30 && 
                a.M31 == b.M31 && 
                a.M32 == b.M32 && 
                a.M33 == b.M33;
        }

        public static bool operator ==(M44d a, double s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s && 
                a.M30 == s && 
                a.M31 == s && 
                a.M32 == s && 
                a.M33 == s;
        }

        public static bool operator ==(double s, M44d a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23  && 
                s == a.M30  && 
                s == a.M31  && 
                s == a.M32  && 
                s == a.M33 ;
        }

        public static bool operator <=(M44d a, M44d b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23 && 
                a.M30 <= b.M30 && 
                a.M31 <= b.M31 && 
                a.M32 <= b.M32 && 
                a.M33 <= b.M33;
        }

        public static bool operator <=(M44d a, double s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s && 
                a.M30 <= s && 
                a.M31 <= s && 
                a.M32 <= s && 
                a.M33 <= s;
        }

        public static bool operator <=(double s, M44d a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23  && 
                s <= a.M30  && 
                s <= a.M31  && 
                s <= a.M32  && 
                s <= a.M33 ;
        }

        public static bool operator >=(M44d a, M44d b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23 && 
                a.M30 >= b.M30 && 
                a.M31 >= b.M31 && 
                a.M32 >= b.M32 && 
                a.M33 >= b.M33;
        }

        public static bool operator >=(M44d a, double s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s && 
                a.M30 >= s && 
                a.M31 >= s && 
                a.M32 >= s && 
                a.M33 >= s;
        }

        public static bool operator >=(double s, M44d a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23  && 
                s >= a.M30  && 
                s >= a.M31  && 
                s >= a.M32  && 
                s >= a.M33 ;
        }

        public static bool operator !=(M44d a, M44d b)
        {
            return !(a == b);
        }

        public static bool operator !=(M44d m, double s)
        {
            return !(m == s);
        }

        public static bool operator !=(double s, M44d m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), M03.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), M13.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode(), M23.GetHashCode(), 
                M30.GetHashCode(), M31.GetHashCode(), M32.GetHashCode(), M33.GetHashCode());
        }

        public override bool Equals(object other)
        {
            return (other is M44d) ? (this == (M44d)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R3.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M44d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M44d.FromRows(
                V4d.Parse(x[0]), 
                V4d.Parse(x[1]), 
                V4d.Parse(x[2]), 
                V4d.Parse(x[3])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M44d Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                M44d result = new M44d();
                for (int row = 0; row < 4; row++)
                {
                    for (int col = 0; col < 4; col++)
                    {
                        if (((col + row) % 2) == 0)
                            result[col, row] = this.Minor(row, col).Determinant;
                        else
                            result[col, row] = -this.Minor(row, col).Determinant;
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public double Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 + M22 + M33 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public double Determinant
        {
            get
            {
                // using bottom row because elements M30, M31, and M32
                // are zero most of the time.
                double d = 0;
                if (M30 != 0.0f) d -= M30 * (
                M01 * M12 * M23 + M02 * M13 * M21 + M03 * M11 * M22
                - M21 * M12 * M03 - M22 * M13 * M01 - M23 * M11 * M02
                );
                if (M31 != 0.0f) d += M31 * (
                M00 * M12 * M23 + M02 * M13 * M20 + M03 * M10 * M22
                - M20 * M12 * M03 - M22 * M13 * M00 - M23 * M10 * M02
                );
                if (M32 != 0.0f) d -= M32 * (
                M00 * M11 * M23 + M01 * M13 * M20 + M03 * M10 * M21
                - M20 * M11 * M03 - M21 * M13 * M00 - M23 * M10 * M01
                );
                if (M33 != 0.0f) d += M33 * (
                M00 * M11 * M22 + M01 * M12 * M20 + M02 * M10 * M21
                - M20 * M11 * M02 - M21 * M12 * M00 - M22 * M10 * M01
                );
                return d;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M44d Transposed
        {
            get
            {
                return new M44d {
                    
                    M00 = M00, 
                    M01 = M10, 
                    M02 = M20, 
                    M03 = M30, 
                    
                    M10 = M01, 
                    M11 = M11, 
                    M12 = M21, 
                    M13 = M31, 
                    
                    M20 = M02, 
                    M21 = M12, 
                    M22 = M22, 
                    M23 = M32, 
                    
                    M30 = M03, 
                    M31 = M13, 
                    M32 = M23, 
                    M33 = M33
                };
            }
        }

        private static V2l s_luSize = new V2l(4, 4);
        private static V2l s_luDelta = new V2l(1, 4);

        /// <summary>
        /// Inverts the given matrix using lu factorization in place. Returns true
        /// if the matrix was invertible, otherwise the matrix remains unchanged.
        /// </summary>
        public bool LuInvert()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return false;
            this = (M44d)(lu.LuInverse(p).Data);
            return true;
        }

        /// <summary>
        /// Returns the inverse of the matrix using lu factorization.
        /// If the matrix is not invertible, M44d.Zero is returned.
        /// </summary>
        public M44d LuInverse()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return M44d.Zero;
            return (M44d)(lu.LuInverse(p).Data);
        }

        /// <summary>
        /// Returns the inverse of this matrix. If the matrix is not invertible
        /// M44d.Zero is returned.
        /// </summary>
        public M44d Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => LuInverse();
        }

        #endregion

        #region Matrix Multiplication

        public static M44d operator *(M44d a, M44d b)
        {
            return new M44d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33, 
                a.M30 * b.M00 + a.M31 * b.M10 + a.M32 * b.M20 + a.M33 * b.M30, 
                a.M30 * b.M01 + a.M31 * b.M11 + a.M32 * b.M21 + a.M33 * b.M31, 
                a.M30 * b.M02 + a.M31 * b.M12 + a.M32 * b.M22 + a.M33 * b.M32, 
                a.M30 * b.M03 + a.M31 * b.M13 + a.M32 * b.M23 + a.M33 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (double)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (double)value;
        }

        #endregion
    }

    public class M44dEqualityComparer : IEqualityComparer<M44d>
    {
        public static readonly M44dEqualityComparer Default
            = new M44dEqualityComparer();

        #region IEqualityComparer<M44d> Members

        public bool Equals(M44d v0, M44d v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M44d v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm1(M44d m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M44d m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMax(M44d m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMin(M44d m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M44d m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M03).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M13).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p) + 
                Fun.Abs(m.M23).Pow(p) + 
                Fun.Abs(m.M30).Pow(p) + 
                Fun.Abs(m.M31).Pow(p) + 
                Fun.Abs(m.M32).Pow(p) + 
                Fun.Abs(m.M33).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static double Distance1(this M44d a, M44d b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23) + 
                Fun.Abs(b.M30 - a.M30) + 
                Fun.Abs(b.M31 - a.M31) + 
                Fun.Abs(b.M32 - a.M32) + 
                Fun.Abs(b.M33 - a.M33);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M44d a, M44d b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23) + 
                        Fun.Square(b.M30 - a.M30) + 
                        Fun.Square(b.M31 - a.M31) + 
                        Fun.Square(b.M32 - a.M32) + 
                        Fun.Square(b.M33 - a.M33));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M44d a, M44d b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p) + 
                Fun.Abs(b.M30 - a.M30).Pow(p) + 
                Fun.Abs(b.M31 - a.M31).Pow(p) + 
                Fun.Abs(b.M32 - a.M32).Pow(p) + 
                Fun.Abs(b.M33 - a.M33).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMax(this M44d a, M44d b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Max(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMin(this M44d a, M44d b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Min(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d Transform(this M44d m, V4d v)
            => m * v;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d TransposedTransform(this M44d m, V4d v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by matrix m.
        /// </summary>
        public static V3d TransformDir(this M44d m, V3d v)
        {
            return new V3d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3d TransformPos(this M44d m, V3d p)
        {
            return new V3d(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Transforms point p (p.W is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3d TransformPosProj(this M44d m, V3d p)
        {
            double s = m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z + m.M33;
            return TransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (p.W is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V4d TransformPosProjFull(this M44d m, V3d p)
        {
            return new V4d(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23, 
                m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z + m.M33
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V3d TransposedTransformDir(this M44d m, V3d v)
        {
            return new V3d(
                m.M00 * v.X + m.M10 * v.Y + m.M20 * v.Z, 
                m.M01 * v.X + m.M11 * v.Y + m.M21 * v.Z, 
                m.M02 * v.X + m.M12 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3d TransposedTransformPos(this M44d m, V3d p)
        {
            return new V3d(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3d TransposedTransformProj(this M44d m, V3d p)
        {
            var s = m.M03 * p.X + m.M13 * p.Y + m.M23 * p.Z + m.M33;
            return TransposedTransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V4d TransposedTransformProjFull(this M44d m, V3d p)
        {
            return new V4d(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32, 
                m.M03 * p.X + m.M13 * p.Y + m.M23 * p.Z + m.M33
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M44d"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static M33d Minor(this M44d m, int row, int column)
        {
            M33d rs = new M33d();

            for (int k = 0; k < 9; k++)
            {
                var i = k / 9;
                var j = k % 9;

                if (i != row && j != column)
                {
                    rs[k] = m[k];
                }
            }

            return rs;
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d Row(this M44d m, int index)
        {
            switch (index)
            {
                case 0: return m.R0;
                case 1: return m.R1;
                case 2: return m.R2;
                case 3: return m.R3;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d Column(this M44d m, int index)
        {
            switch (index)
            {
                case 0: return m.C0;
                case 1: return m.C1;
                case 2: return m.C2;
                case 3: return m.C3;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Determinant(M44d m)
            => m.Determinant;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        public static void Transpose(this ref M44d m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
            Fun.Swap(ref m.M20, ref m.M02);
            Fun.Swap(ref m.M21, ref m.M12);
            Fun.Swap(ref m.M30, ref m.M03);
            Fun.Swap(ref m.M31, ref m.M13);
            Fun.Swap(ref m.M32, ref m.M23);
        }

        /// <summary>
        /// Inverts the given matrix in place. Returns true if the matrix was invertible,
        /// otherwise the matrix remains unchanged.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Invert(this ref M44d m) { return m.LuInvert(); }

        /// <summary>
        /// Returns if the given matrix is the identity matrix I.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsIdentity(this M44d m, double epsilon)
        {
            return Fun.ApproximateEquals(m, M44d.Identity, epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthonormal(this M44d m, double epsilon)
        {
            var i = m * m.Transposed;
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthogonal(this M44d m, double epsilon)
        {
            var i = m * m.Transposed;
            for (int j = 0; j < 4; j++)
                i[j, j] = 1; //inefficient implementation: just leave out the comparisons at the diagonal entries.
            return i.IsIdentity(epsilon);
        }
        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximateEquals(M44d a, M44d b, double epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion
    }

    #endregion

}
