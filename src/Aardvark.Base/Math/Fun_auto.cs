using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Text;

namespace Aardvark.Base
{
    // AUTOGENERATED CODE - DO NOT CHANGE!

    public static partial class Fun
    {
        #region Min and Max

        [Pure]
        public static byte Min(byte a, byte b) { return a < b ? a : b; }
        
        [Pure]
        public static byte Max(byte a, byte b) { return a > b ? a : b; }

        [Pure]
        public static byte Min(byte a, byte b, byte c)
        {
            return a < b ? (a < c ? a : c) : (b < c ? b : c);
        }

        [Pure]
        public static byte Max(byte a, byte b, byte c)
        {
            return a > b ? (a > c ? a : c) : (b > c ? b : c);
        }

        [Pure]
        public static byte Min(byte a, byte b, byte c, byte d)
        {
            return Min(Min(a, b), Min(c, d));
        }

        [Pure]
        public static byte Max(byte a, byte b, byte c, byte d)
        {
            return Max(Max(a, b), Max(c, d));
        }

        [Pure]
        public static sbyte Min(sbyte a, sbyte b) { return a < b ? a : b; }
        
        [Pure]
        public static sbyte Max(sbyte a, sbyte b) { return a > b ? a : b; }

        [Pure]
        public static sbyte Min(sbyte a, sbyte b, sbyte c)
        {
            return a < b ? (a < c ? a : c) : (b < c ? b : c);
        }

        [Pure]
        public static sbyte Max(sbyte a, sbyte b, sbyte c)
        {
            return a > b ? (a > c ? a : c) : (b > c ? b : c);
        }

        [Pure]
        public static sbyte Min(sbyte a, sbyte b, sbyte c, sbyte d)
        {
            return Min(Min(a, b), Min(c, d));
        }

        [Pure]
        public static sbyte Max(sbyte a, sbyte b, sbyte c, sbyte d)
        {
            return Max(Max(a, b), Max(c, d));
        }

        [Pure]
        public static short Min(short a, short b) { return a < b ? a : b; }
        
        [Pure]
        public static short Max(short a, short b) { return a > b ? a : b; }

        [Pure]
        public static short Min(short a, short b, short c)
        {
            return a < b ? (a < c ? a : c) : (b < c ? b : c);
        }

        [Pure]
        public static short Max(short a, short b, short c)
        {
            return a > b ? (a > c ? a : c) : (b > c ? b : c);
        }

        [Pure]
        public static short Min(short a, short b, short c, short d)
        {
            return Min(Min(a, b), Min(c, d));
        }

        [Pure]
        public static short Max(short a, short b, short c, short d)
        {
            return Max(Max(a, b), Max(c, d));
        }

        [Pure]
        public static ushort Min(ushort a, ushort b) { return a < b ? a : b; }
        
        [Pure]
        public static ushort Max(ushort a, ushort b) { return a > b ? a : b; }

        [Pure]
        public static ushort Min(ushort a, ushort b, ushort c)
        {
            return a < b ? (a < c ? a : c) : (b < c ? b : c);
        }

        [Pure]
        public static ushort Max(ushort a, ushort b, ushort c)
        {
            return a > b ? (a > c ? a : c) : (b > c ? b : c);
        }

        [Pure]
        public static ushort Min(ushort a, ushort b, ushort c, ushort d)
        {
            return Min(Min(a, b), Min(c, d));
        }

        [Pure]
        public static ushort Max(ushort a, ushort b, ushort c, ushort d)
        {
            return Max(Max(a, b), Max(c, d));
        }

        [Pure]
        public static int Min(int a, int b) { return a < b ? a : b; }
        
        [Pure]
        public static int Max(int a, int b) { return a > b ? a : b; }

        [Pure]
        public static int Min(int a, int b, int c)
        {
            return a < b ? (a < c ? a : c) : (b < c ? b : c);
        }

        [Pure]
        public static int Max(int a, int b, int c)
        {
            return a > b ? (a > c ? a : c) : (b > c ? b : c);
        }

        [Pure]
        public static int Min(int a, int b, int c, int d)
        {
            return Min(Min(a, b), Min(c, d));
        }

        [Pure]
        public static int Max(int a, int b, int c, int d)
        {
            return Max(Max(a, b), Max(c, d));
        }

        [Pure]
        public static uint Min(uint a, uint b) { return a < b ? a : b; }
        
        [Pure]
        public static uint Max(uint a, uint b) { return a > b ? a : b; }

        [Pure]
        public static uint Min(uint a, uint b, uint c)
        {
            return a < b ? (a < c ? a : c) : (b < c ? b : c);
        }

        [Pure]
        public static uint Max(uint a, uint b, uint c)
        {
            return a > b ? (a > c ? a : c) : (b > c ? b : c);
        }

        [Pure]
        public static uint Min(uint a, uint b, uint c, uint d)
        {
            return Min(Min(a, b), Min(c, d));
        }

        [Pure]
        public static uint Max(uint a, uint b, uint c, uint d)
        {
            return Max(Max(a, b), Max(c, d));
        }

        [Pure]
        public static long Min(long a, long b) { return a < b ? a : b; }
        
        [Pure]
        public static long Max(long a, long b) { return a > b ? a : b; }

        [Pure]
        public static long Min(long a, long b, long c)
        {
            return a < b ? (a < c ? a : c) : (b < c ? b : c);
        }

        [Pure]
        public static long Max(long a, long b, long c)
        {
            return a > b ? (a > c ? a : c) : (b > c ? b : c);
        }

        [Pure]
        public static long Min(long a, long b, long c, long d)
        {
            return Min(Min(a, b), Min(c, d));
        }

        [Pure]
        public static long Max(long a, long b, long c, long d)
        {
            return Max(Max(a, b), Max(c, d));
        }

        [Pure]
        public static ulong Min(ulong a, ulong b) { return a < b ? a : b; }
        
        [Pure]
        public static ulong Max(ulong a, ulong b) { return a > b ? a : b; }

        [Pure]
        public static ulong Min(ulong a, ulong b, ulong c)
        {
            return a < b ? (a < c ? a : c) : (b < c ? b : c);
        }

        [Pure]
        public static ulong Max(ulong a, ulong b, ulong c)
        {
            return a > b ? (a > c ? a : c) : (b > c ? b : c);
        }

        [Pure]
        public static ulong Min(ulong a, ulong b, ulong c, ulong d)
        {
            return Min(Min(a, b), Min(c, d));
        }

        [Pure]
        public static ulong Max(ulong a, ulong b, ulong c, ulong d)
        {
            return Max(Max(a, b), Max(c, d));
        }

        [Pure]
        public static float Min(float a, float b) { return a < b ? a : b; }
        
        [Pure]
        public static float Max(float a, float b) { return a > b ? a : b; }

        [Pure]
        public static float Min(float a, float b, float c)
        {
            return a < b ? (a < c ? a : c) : (b < c ? b : c);
        }

        [Pure]
        public static float Max(float a, float b, float c)
        {
            return a > b ? (a > c ? a : c) : (b > c ? b : c);
        }

        [Pure]
        public static float Min(float a, float b, float c, float d)
        {
            return Min(Min(a, b), Min(c, d));
        }

        [Pure]
        public static float Max(float a, float b, float c, float d)
        {
            return Max(Max(a, b), Max(c, d));
        }

        [Pure]
        public static double Min(double a, double b) { return a < b ? a : b; }
        
        [Pure]
        public static double Max(double a, double b) { return a > b ? a : b; }

        [Pure]
        public static double Min(double a, double b, double c)
        {
            return a < b ? (a < c ? a : c) : (b < c ? b : c);
        }

        [Pure]
        public static double Max(double a, double b, double c)
        {
            return a > b ? (a > c ? a : c) : (b > c ? b : c);
        }

        [Pure]
        public static double Min(double a, double b, double c, double d)
        {
            return Min(Min(a, b), Min(c, d));
        }

        [Pure]
        public static double Max(double a, double b, double c, double d)
        {
            return Max(Max(a, b), Max(c, d));
        }

        [Pure]
        public static Fraction Min(Fraction a, Fraction b) { return a < b ? a : b; }
        
        [Pure]
        public static Fraction Max(Fraction a, Fraction b) { return a > b ? a : b; }

        [Pure]
        public static Fraction Min(Fraction a, Fraction b, Fraction c)
        {
            return a < b ? (a < c ? a : c) : (b < c ? b : c);
        }

        [Pure]
        public static Fraction Max(Fraction a, Fraction b, Fraction c)
        {
            return a > b ? (a > c ? a : c) : (b > c ? b : c);
        }

        [Pure]
        public static Fraction Min(Fraction a, Fraction b, Fraction c, Fraction d)
        {
            return Min(Min(a, b), Min(c, d));
        }

        [Pure]
        public static Fraction Max(Fraction a, Fraction b, Fraction c, Fraction d)
        {
            return Max(Max(a, b), Max(c, d));
        }

        [Pure]
        public static DateTime Min(DateTime a, DateTime b) { return a < b ? a : b; }
        
        [Pure]
        public static DateTime Max(DateTime a, DateTime b) { return a > b ? a : b; }

        [Pure]
        public static DateTime Min(DateTime a, DateTime b, DateTime c)
        {
            return a < b ? (a < c ? a : c) : (b < c ? b : c);
        }

        [Pure]
        public static DateTime Max(DateTime a, DateTime b, DateTime c)
        {
            return a > b ? (a > c ? a : c) : (b > c ? b : c);
        }

        [Pure]
        public static DateTime Min(DateTime a, DateTime b, DateTime c, DateTime d)
        {
            return Min(Min(a, b), Min(c, d));
        }

        [Pure]
        public static DateTime Max(DateTime a, DateTime b, DateTime c, DateTime d)
        {
            return Max(Max(a, b), Max(c, d));
        }

        [Pure]
        public static TimeSpan Min(TimeSpan a, TimeSpan b) { return a < b ? a : b; }
        
        [Pure]
        public static TimeSpan Max(TimeSpan a, TimeSpan b) { return a > b ? a : b; }

        [Pure]
        public static TimeSpan Min(TimeSpan a, TimeSpan b, TimeSpan c)
        {
            return a < b ? (a < c ? a : c) : (b < c ? b : c);
        }

        [Pure]
        public static TimeSpan Max(TimeSpan a, TimeSpan b, TimeSpan c)
        {
            return a > b ? (a > c ? a : c) : (b > c ? b : c);
        }

        [Pure]
        public static TimeSpan Min(TimeSpan a, TimeSpan b, TimeSpan c, TimeSpan d)
        {
            return Min(Min(a, b), Min(c, d));
        }

        [Pure]
        public static TimeSpan Max(TimeSpan a, TimeSpan b, TimeSpan c, TimeSpan d)
        {
            return Max(Max(a, b), Max(c, d));
        }

        #endregion

        #region Abs

        /// <summary>
        /// Returns the absolute value of the specified number.
        /// </summary>
        [Pure]
        public static sbyte Abs(this sbyte x)
        {
            return System.Math.Abs(x);
        }

        /// <summary>
        /// Returns the absolute value of the specified number.
        /// </summary>
        [Pure]
        public static short Abs(this short x)
        {
            return System.Math.Abs(x);
        }

        /// <summary>
        /// Returns the absolute value of the specified number.
        /// </summary>
        [Pure]
        public static int Abs(this int x)
        {
            return System.Math.Abs(x);
        }

        /// <summary>
        /// Returns the absolute value of the specified number.
        /// </summary>
        [Pure]
        public static long Abs(this long x)
        {
            return System.Math.Abs(x);
        }

        /// <summary>
        /// Returns the absolute value of the specified number.
        /// </summary>
        [Pure]
        public static float Abs(this float x)
        {
            return System.Math.Abs(x);
        }

        /// <summary>
        /// Returns the absolute value of the specified number.
        /// </summary>
        [Pure]
        public static double Abs(this double x)
        {
            return System.Math.Abs(x);
        }

        /// <summary>
        /// Returns the absolute value of the specified number.
        /// </summary>
        [Pure]
        public static decimal Abs(this decimal x)
        {
            return System.Math.Abs(x);
        }

        #endregion

        #region ApproximateEquals

        /// <summary>
        /// Returns whether the distance between x and y is not more than epsilon.
        /// </summary>
        [Pure]
        public static bool ApproximateEquals(this sbyte x, sbyte y, sbyte epsilon)
        {
            return Abs(x - y) <= epsilon;
        }

        /// <summary>
        /// Returns whether the distance between x and y is not more than epsilon.
        /// </summary>
        [Pure]
        public static bool ApproximateEquals(this short x, short y, short epsilon)
        {
            return Abs(x - y) <= epsilon;
        }

        /// <summary>
        /// Returns whether the distance between x and y is not more than epsilon.
        /// </summary>
        [Pure]
        public static bool ApproximateEquals(this int x, int y, int epsilon)
        {
            return Abs(x - y) <= epsilon;
        }

        /// <summary>
        /// Returns whether the distance between x and y is not more than epsilon.
        /// </summary>
        [Pure]
        public static bool ApproximateEquals(this long x, long y, long epsilon)
        {
            return Abs(x - y) <= epsilon;
        }

        /// <summary>
        /// Returns whether the distance between x and y is not more than epsilon.
        /// </summary>
        [Pure]
        public static bool ApproximateEquals(this float x, float y, float epsilon)
        {
            return Abs(x - y) <= epsilon;
        }

        /// <summary>
        /// Returns whether the distance between x and y is not more than epsilon.
        /// </summary>
        [Pure]
        public static bool ApproximateEquals(this double x, double y, double epsilon)
        {
            return Abs(x - y) <= epsilon;
        }

        /// <summary>
        /// Returns whether the distance between x and y is not more than epsilon.
        /// </summary>
        [Pure]
        public static bool ApproximateEquals(this decimal x, decimal y, decimal epsilon)
        {
            return Abs(x - y) <= epsilon;
        }

        #endregion

        #region Floor

        /// <summary>
        /// Returns the largest integer less than or equal to the specified number.
        /// </summary>
        [Pure]
        public static float Floor(this float x)
        {
            return (float)System.Math.Floor(x);
        }

        /// <summary>
        /// Returns the largest integer less than or equal to the specified number.
        /// </summary>
        [Pure]
        public static double Floor(this double x)
        {
            return System.Math.Floor(x);
        }

        #endregion

        #region Ceiling

        /// <summary>
        /// Returns the smallest integer greater than or equal to the specified number.
        /// </summary>
        [Pure]
        public static float Ceiling(this float x)
        {
            return (float)System.Math.Ceiling(x);
        }

        /// <summary>
        /// Returns the smallest integer greater than or equal to the specified number.
        /// </summary>
        [Pure]
        public static double Ceiling(this double x)
        {
            return System.Math.Ceiling(x);
        }

        #endregion

        #region Round

        /// <summary>
        /// Rounds a float-point value to the nearest integral value.
        /// </summary>
        [Pure]
        public static float Round(this float x)
        {
            return (float)System.Math.Round(x);
        }

        /// <summary>
        /// Rounds a float-point value to the nearest integral value.
        /// </summary>
        [Pure]
        public static double Round(this double x)
        {
            return System.Math.Round(x);
        }

        #endregion

        #region Clamp

        /// <summary>
        /// Clamps value to interval [a,b].
        /// </summary>
        [Pure]
        public static byte Clamp(this byte x, byte a, byte b)
        {
            if (x < a) return a;
            if (x > b) return b;
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b].
        /// </summary>
        [Pure]
        public static sbyte Clamp(this sbyte x, sbyte a, sbyte b)
        {
            if (x < a) return a;
            if (x > b) return b;
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b].
        /// </summary>
        [Pure]
        public static short Clamp(this short x, short a, short b)
        {
            if (x < a) return a;
            if (x > b) return b;
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b].
        /// </summary>
        [Pure]
        public static ushort Clamp(this ushort x, ushort a, ushort b)
        {
            if (x < a) return a;
            if (x > b) return b;
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b].
        /// </summary>
        [Pure]
        public static int Clamp(this int x, int a, int b)
        {
            if (x < a) return a;
            if (x > b) return b;
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b].
        /// </summary>
        [Pure]
        public static uint Clamp(this uint x, uint a, uint b)
        {
            if (x < a) return a;
            if (x > b) return b;
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b].
        /// </summary>
        [Pure]
        public static long Clamp(this long x, long a, long b)
        {
            if (x < a) return a;
            if (x > b) return b;
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b].
        /// </summary>
        [Pure]
        public static ulong Clamp(this ulong x, ulong a, ulong b)
        {
            if (x < a) return a;
            if (x > b) return b;
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b].
        /// </summary>
        [Pure]
        public static float Clamp(this float x, float a, float b)
        {
            if (x < a) return a;
            if (x > b) return b;
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b].
        /// </summary>
        [Pure]
        public static double Clamp(this double x, double a, double b)
        {
            if (x < a) return a;
            if (x > b) return b;
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b].
        /// </summary>
        [Pure]
        public static decimal Clamp(this decimal x, decimal a, decimal b)
        {
            if (x < a) return a;
            if (x > b) return b;
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b].
        /// </summary>
        [Pure]
        public static int Clamp(this int x, Range1i range)
        {
            if (x < range.Min) return range.Min;
            if (x > range.Max) return range.Max;
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b].
        /// </summary>
        [Pure]
        public static long Clamp(this long x, Range1l range)
        {
            if (x < range.Min) return range.Min;
            if (x > range.Max) return range.Max;
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b].
        /// </summary>
        [Pure]
        public static float Clamp(this float x, Range1f range)
        {
            if (x < range.Min) return range.Min;
            if (x > range.Max) return range.Max;
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b].
        /// </summary>
        [Pure]
        public static double Clamp(this double x, Range1d range)
        {
            if (x < range.Min) return range.Min;
            if (x > range.Max) return range.Max;
            return x;
        }

        #endregion

        #region ClampExcl

        /// <summary>
        /// Clamps value to interval [a,b[.
        /// </summary>
        [Pure]
        public static byte ClampExcl(this byte x, byte a, byte b)
        {
            if (x < a) return a;
            if (x >= b) return (byte)(b - 1);
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b[.
        /// </summary>
        [Pure]
        public static sbyte ClampExcl(this sbyte x, sbyte a, sbyte b)
        {
            if (x < a) return a;
            if (x >= b) return (sbyte)(b - 1);
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b[.
        /// </summary>
        [Pure]
        public static short ClampExcl(this short x, short a, short b)
        {
            if (x < a) return a;
            if (x >= b) return (short)(b - 1);
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b[.
        /// </summary>
        [Pure]
        public static ushort ClampExcl(this ushort x, ushort a, ushort b)
        {
            if (x < a) return a;
            if (x >= b) return (ushort)(b - 1);
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b[.
        /// </summary>
        [Pure]
        public static int ClampExcl(this int x, int a, int b)
        {
            if (x < a) return a;
            if (x >= b) return (int)(b - 1);
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b[.
        /// </summary>
        [Pure]
        public static uint ClampExcl(this uint x, uint a, uint b)
        {
            if (x < a) return a;
            if (x >= b) return (uint)(b - 1);
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b[.
        /// </summary>
        [Pure]
        public static long ClampExcl(this long x, long a, long b)
        {
            if (x < a) return a;
            if (x >= b) return (long)(b - 1);
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b[.
        /// </summary>
        [Pure]
        public static ulong ClampExcl(this ulong x, ulong a, ulong b)
        {
            if (x < a) return a;
            if (x >= b) return (ulong)(b - 1);
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b[.
        /// </summary>
        [Pure]
        public static decimal ClampExcl(this decimal x, decimal a, decimal b)
        {
            if (x < a) return a;
            if (x >= b) return (decimal)(b - 1);
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b[.
        /// </summary>
        [Pure]
        public static int ClampExcl(this int x, Range1i range)
        {
            if (x < range.Min) return range.Min;
            if (x >= range.Max) return (int)(range.Max - 1);
            return x;
        }

        /// <summary>
        /// Clamps value to interval [a,b[.
        /// </summary>
        [Pure]
        public static long ClampExcl(this long x, Range1l range)
        {
            if (x < range.Min) return range.Min;
            if (x >= range.Max) return (long)(range.Max - 1);
            return x;
        }

        #endregion

        #region ClampWrap

        /// <summary>
        /// Clamps value to interval [a,b[ and cyclically wraps around values outside this interval.
        /// </summary>
        [Pure]
        public static byte ClampWrap(this byte x, byte a, byte b)
        {
            return (byte)(ModP(x - a, b - a) + a);
        }

        /// <summary>
        /// Clamps value to interval [a,b[ and cyclically wraps around values outside this interval.
        /// </summary>
        [Pure]
        public static sbyte ClampWrap(this sbyte x, sbyte a, sbyte b)
        {
            return (sbyte)(ModP(x - a, b - a) + a);
        }

        /// <summary>
        /// Clamps value to interval [a,b[ and cyclically wraps around values outside this interval.
        /// </summary>
        [Pure]
        public static short ClampWrap(this short x, short a, short b)
        {
            return (short)(ModP(x - a, b - a) + a);
        }

        /// <summary>
        /// Clamps value to interval [a,b[ and cyclically wraps around values outside this interval.
        /// </summary>
        [Pure]
        public static ushort ClampWrap(this ushort x, ushort a, ushort b)
        {
            return (ushort)(ModP(x - a, b - a) + a);
        }

        /// <summary>
        /// Clamps value to interval [a,b[ and cyclically wraps around values outside this interval.
        /// </summary>
        [Pure]
        public static int ClampWrap(this int x, int a, int b)
        {
            return (int)(ModP(x - a, b - a) + a);
        }

        /// <summary>
        /// Clamps value to interval [a,b[ and cyclically wraps around values outside this interval.
        /// </summary>
        [Pure]
        public static uint ClampWrap(this uint x, uint a, uint b)
        {
            return (uint)(ModP(x - a, b - a) + a);
        }

        /// <summary>
        /// Clamps value to interval [a,b[ and cyclically wraps around values outside this interval.
        /// </summary>
        [Pure]
        public static long ClampWrap(this long x, long a, long b)
        {
            return (long)(ModP(x - a, b - a) + a);
        }

        /// <summary>
        /// Clamps value to interval [a,b[ and cyclically wraps around values outside this interval.
        /// </summary>
        [Pure]
        public static float ClampWrap(this float x, float a, float b)
        {
            return (float)(ModP(x - a, b - a) + a);
        }

        /// <summary>
        /// Clamps value to interval [a,b[ and cyclically wraps around values outside this interval.
        /// </summary>
        [Pure]
        public static double ClampWrap(this double x, double a, double b)
        {
            return (double)(ModP(x - a, b - a) + a);
        }

        /// <summary>
        /// Clamps value to interval [a,b[ and cyclically wraps around values outside this interval.
        /// </summary>
        [Pure]
        public static decimal ClampWrap(this decimal x, decimal a, decimal b)
        {
            return (decimal)(ModP(x - a, b - a) + a);
        }

        /// <summary>
        /// Clamps value to interval [a,b[ and cyclically wraps around values outside this interval.
        /// </summary>
        [Pure]
        public static int ClampWrap(this int x, Range1i range)
        {
            return (int)(ModP(x - range.Min, range.Max - range.Min) + range.Min);
        }

        /// <summary>
        /// Clamps value to interval [a,b[ and cyclically wraps around values outside this interval.
        /// </summary>
        [Pure]
        public static long ClampWrap(this long x, Range1l range)
        {
            return (long)(ModP(x - range.Min, range.Max - range.Min) + range.Min);
        }

        /// <summary>
        /// Clamps value to interval [a,b[ and cyclically wraps around values outside this interval.
        /// </summary>
        [Pure]
        public static float ClampWrap(this float x, Range1f range)
        {
            return (float)(ModP(x - range.Min, range.Max - range.Min) + range.Min);
        }

        /// <summary>
        /// Clamps value to interval [a,b[ and cyclically wraps around values outside this interval.
        /// </summary>
        [Pure]
        public static double ClampWrap(this double x, Range1d range)
        {
            return (double)(ModP(x - range.Min, range.Max - range.Min) + range.Min);
        }

        #endregion

        #region MapToUnitInterval

        /// <summary>
        /// Maps value from interval [0, tMax] to interval [0, 1].
        /// Values outside [0, tMax] are clamped - if t is greater than tMax
        /// then 1 is returned, if t is less than 0 then 0 is returned.
        /// If 'repeat' is true, then every interval [i * tMax, (i+1) * tMax]
        /// (for i from integers) is mapped to [0, 1].
        /// If 'mirror' is true, then every second interval is flipped, such
        /// that [0, tMax) [tMax, 2*tMax) [2*tMax, 3*tMax] ... is mapped to
        /// [0,1)[1,0)[0,1)...
        /// </summary>
        [Pure]
        public static double MapToUnitInterval(
            this double t, double tMax,
            bool repeat, bool mirror
            )
        {
            t = t / tMax;
            if (!repeat)
            {
                if (t >= 1) return 1;
                if (t <= 0) return 0;
            }
            if (mirror)
            {
                t = t - System.Math.Floor(t * 0.5) * 2;
                return t < 1 ? t : 2 - t;
            }
            else
            {
                return t - System.Math.Floor(t);
            }
        }

        /// <summary>
        /// Maps value from interval [0, tMax] to interval [0, 1].
        /// If 'repeat' is true, then every interval [i * tMax, (i+1) * tMax]
        /// (for i from integers) is mapped to [0, 1].
        /// </summary>
        [Pure]
        public static double MapToUnitInterval(this double t, double tMax, bool repeat)
        {
            t = t / tMax;
            if (!repeat)
            {
                if (t >= 1) return 1;
                if (t <= 0) return 0;
            }
            return t - System.Math.Floor(t);
        }

        /// <summary>
        /// Maps value from interval [0, tMax] to interval [0, 1].
        /// </summary>
        [Pure]
        public static double MapToUnitInterval(this double t, double tMax)
        {
            t = t / tMax;
            if (t > 1) return 1;
            if (t < 0) return 0;
            return t;
        }

        /// <summary>
        /// Maps value from interval [tMin, tMax] to interval [0, 1].
        /// </summary>
        [Pure]
        public static double MapToUnitInterval(this double t, double tMin, double tMax)
        {
            t = (t - tMin) / (tMax - tMin);
            if (t > 1) return 1;
            if (t < 0) return 0;
            return t;
        }

        #endregion

        #region Sign

        /// <summary>
        /// Returns either -1, 0, or +1, indicating the sign of the specified value .
        /// </summary>
        [Pure]
        public static int Sign(this sbyte x)
        {
            return System.Math.Sign(x);
        }

        /// <summary>
        /// Returns either -1, 0, or +1, indicating the sign of the specified value .
        /// </summary>
        [Pure]
        public static int Sign(this short x)
        {
            return System.Math.Sign(x);
        }

        /// <summary>
        /// Returns either -1, 0, or +1, indicating the sign of the specified value .
        /// </summary>
        [Pure]
        public static int Sign(this int x)
        {
            return System.Math.Sign(x);
        }

        /// <summary>
        /// Returns either -1, 0, or +1, indicating the sign of the specified value .
        /// </summary>
        [Pure]
        public static int Sign(this long x)
        {
            return System.Math.Sign(x);
        }

        /// <summary>
        /// Returns either -1, 0, or +1, indicating the sign of the specified value .
        /// </summary>
        [Pure]
        public static int Sign(this float x)
        {
            return System.Math.Sign(x);
        }

        /// <summary>
        /// Returns either -1, 0, or +1, indicating the sign of the specified value .
        /// </summary>
        [Pure]
        public static int Sign(this double x)
        {
            return System.Math.Sign(x);
        }

        /// <summary>
        /// Returns either -1, 0, or +1, indicating the sign of the specified value .
        /// </summary>
        [Pure]
        public static int Sign(this decimal x)
        {
            return System.Math.Sign(x);
        }

        #endregion

        #region Comparisons

        /// <summary>
        /// Returns true if the absolulte value of the supplied float is
        /// smaller than 4 times the machine epsilon.
        /// </summary>
        [Pure]
        public static bool IsTiny(this float x)
        {
            return x.Abs() < Constant<float>.PositiveTinyValue;
        }

        /// <summary>
        /// Returns true if the absolulte value of the supplied float is
        /// greater than or equal to 4 times the machine epsilon.
        /// </summary>
        [Pure]
        public static bool IsNotTiny(this float x)
        {
            return x.Abs() >= Constant<float>.PositiveTinyValue;
        }

        /// <summary>
        /// Returns true if the absolulte value of the supplied float <paramref name="x"/> is
        /// smaller than the supplied <paramref name="epsilon"/> .
        /// </summary>
        [Pure]
        public static bool IsTiny(this float x, float epsilon)
        {
            return x.Abs() < epsilon;
        }

        /// <summary>
        /// Returns true if the absolulte value of the supplied float <paramref name="x"/> is
        /// greater than or equal to the supplied <paramref name="epsilon"/> .
        /// </summary>
        [Pure]
        public static bool IsNotTiny(this float x, float epsilon)
        {
            return x.Abs() >= epsilon;
        }

        /// <summary>
        /// Returns true if the absolulte value of the supplied float is
        /// smaller than 4 times the machine epsilon.
        /// </summary>
        [Pure]
        public static bool IsTiny(this double x)
        {
            return x.Abs() < Constant<double>.PositiveTinyValue;
        }

        /// <summary>
        /// Returns true if the absolulte value of the supplied float is
        /// greater than or equal to 4 times the machine epsilon.
        /// </summary>
        [Pure]
        public static bool IsNotTiny(this double x)
        {
            return x.Abs() >= Constant<double>.PositiveTinyValue;
        }

        /// <summary>
        /// Returns true if the absolulte value of the supplied float <paramref name="x"/> is
        /// smaller than the supplied <paramref name="epsilon"/> .
        /// </summary>
        [Pure]
        public static bool IsTiny(this double x, double epsilon)
        {
            return x.Abs() < epsilon;
        }

        /// <summary>
        /// Returns true if the absolulte value of the supplied float <paramref name="x"/> is
        /// greater than or equal to the supplied <paramref name="epsilon"/> .
        /// </summary>
        [Pure]
        public static bool IsNotTiny(this double x, double epsilon)
        {
            return x.Abs() >= epsilon;
        }

        #endregion

        #region AbsSum

        /// <summary>
        /// Returns the sum of the absolute values of the given numbers.
        /// </summary>
        [Pure]
        public static int AbsSum(this IEnumerable<sbyte> array)
        {
            int sum = 0;
            foreach (var i in array) sum += i.Abs();
            return sum;
        }

        /// <summary>
        /// Returns the sum of the absolute values of the given numbers.
        /// </summary>
        [Pure]
        public static long AbsSum(this IEnumerable<short> array)
        {
            long sum = 0;
            foreach (var i in array) sum += i.Abs();
            return sum;
        }

        /// <summary>
        /// Returns the sum of the absolute values of the given numbers.
        /// </summary>
        [Pure]
        public static long AbsSum(this IEnumerable<int> array)
        {
            long sum = 0;
            foreach (var i in array) sum += i.Abs();
            return sum;
        }

        /// <summary>
        /// Returns the sum of the absolute values of the given numbers.
        /// </summary>
        [Pure]
        public static long AbsSum(this IEnumerable<long> array)
        {
            long sum = 0;
            foreach (var i in array) sum += i.Abs();
            return sum;
        }

        /// <summary>
        /// Returns the sum of the absolute values of the given numbers.
        /// </summary>
        [Pure]
        public static double AbsSum(this IEnumerable<float> array)
        {
            double sum = 0;
            foreach (var i in array) sum += i.Abs();
            return sum;
        }

        /// <summary>
        /// Returns the sum of the absolute values of the given numbers.
        /// </summary>
        [Pure]
        public static double AbsSum(this IEnumerable<double> array)
        {
            double sum = 0;
            foreach (var i in array) sum += i.Abs();
            return sum;
        }

        /// <summary>
        /// Returns the sum of the absolute values of the given numbers.
        /// </summary>
        [Pure]
        public static decimal AbsSum(this IEnumerable<decimal> array)
        {
            decimal sum = 0;
            foreach (var i in array) sum += i.Abs();
            return sum;
        }

        #endregion 

        #region Cbrt

        [Pure]
        public static double Cbrt(this float x)
        {
            return x < 0 ? -(float)System.Math.Pow(-x, Constant.OneThird)
                         : (float)System.Math.Pow(x, Constant.OneThird);
        }

        [Pure]
        public static double Cbrt(this double x)
        {
            return x < 0 ? -System.Math.Pow(-x, Constant.OneThird)
                         : System.Math.Pow(x, Constant.OneThird);
        }

        #endregion

        #region Square

        /// <summary>
        /// Returns the square of the specified number.
        /// </summary>
        [Pure]
        public static int Square(this byte x)
        {
            return x * x;
        }

        /// <summary>
        /// Returns the square of the specified number.
        /// </summary>
        [Pure]
        public static int Square(this sbyte x)
        {
            return x * x;
        }

        /// <summary>
        /// Returns the square of the specified number.
        /// </summary>
        [Pure]
        public static long Square(this short x)
        {
            return x * x;
        }

        /// <summary>
        /// Returns the square of the specified number.
        /// </summary>
        [Pure]
        public static long Square(this ushort x)
        {
            return x * x;
        }

        /// <summary>
        /// Returns the square of the specified number.
        /// </summary>
        [Pure]
        public static long Square(this int x)
        {
            return x * x;
        }

        /// <summary>
        /// Returns the square of the specified number.
        /// </summary>
        [Pure]
        public static long Square(this uint x)
        {
            return x * x;
        }

        /// <summary>
        /// Returns the square of the specified number.
        /// </summary>
        [Pure]
        public static long Square(this long x)
        {
            return x * x;
        }

        /// <summary>
        /// Returns the square of the specified number.
        /// </summary>
        [Pure]
        public static ulong Square(this ulong x)
        {
            return x * x;
        }

        /// <summary>
        /// Returns the square of the specified number.
        /// </summary>
        [Pure]
        public static double Square(this float x)
        {
            return x * x;
        }

        /// <summary>
        /// Returns the square of the specified number.
        /// </summary>
        [Pure]
        public static double Square(this double x)
        {
            return x * x;
        }

        /// <summary>
        /// Returns the square of the specified number.
        /// </summary>
        [Pure]
        public static decimal Square(this decimal x)
        {
            return x * x;
        }

        #endregion 

        #region Sqrt

        /// <summary>
        /// Returns the square root of the specified number.
        /// </summary>
        [Pure]
        public static double Sqrt(this byte x)
        {
            return System.Math.Sqrt(x);
        }

        /// <summary>
        /// Returns the square root of the specified number.
        /// </summary>
        [Pure]
        public static double Sqrt(this sbyte x)
        {
            return System.Math.Sqrt(x);
        }

        /// <summary>
        /// Returns the square root of the specified number.
        /// </summary>
        [Pure]
        public static double Sqrt(this short x)
        {
            return System.Math.Sqrt(x);
        }

        /// <summary>
        /// Returns the square root of the specified number.
        /// </summary>
        [Pure]
        public static double Sqrt(this ushort x)
        {
            return System.Math.Sqrt(x);
        }

        /// <summary>
        /// Returns the square root of the specified number.
        /// </summary>
        [Pure]
        public static double Sqrt(this int x)
        {
            return System.Math.Sqrt(x);
        }

        /// <summary>
        /// Returns the square root of the specified number.
        /// </summary>
        [Pure]
        public static double Sqrt(this uint x)
        {
            return System.Math.Sqrt(x);
        }

        /// <summary>
        /// Returns the square root of the specified number.
        /// </summary>
        [Pure]
        public static double Sqrt(this long x)
        {
            return System.Math.Sqrt(x);
        }

        /// <summary>
        /// Returns the square root of the specified number.
        /// </summary>
        [Pure]
        public static double Sqrt(this ulong x)
        {
            return System.Math.Sqrt(x);
        }

        /// <summary>
        /// Returns the square root of the specified number.
        /// </summary>
        [Pure]
        public static double Sqrt(this double x)
        {
            return System.Math.Sqrt(x);
        }

        /// <summary>
        /// Returns the square root of the specified number.
        /// </summary>
        [Pure]
        public static float Sqrt(this float x)
        {
            return (float)System.Math.Sqrt(x);
        }

        #endregion 

        #region Pow

        /// <summary>
        /// Returns the number raised to the specified power.
        /// </summary>
        [Pure]
        public static double Pow(this int x, double y)
        {
            return System.Math.Pow(x, y);
        }

        /// <summary>
        /// Returns the number raised to the specified power.
        /// </summary>
        [Pure]
        public static double Pow(this long x, double y)
        {
            return System.Math.Pow(x, y);
        }

        /// <summary>
        /// Returns the number raised to the specified power.
        /// </summary>
        [Pure]
        public static float Pow(this float x, float y)
        {
            return (float)System.Math.Pow(x, y);
        }

        /// <summary>
        /// Returns the number raised to the specified power.
        /// </summary>
        [Pure]
        public static double Pow(this double x, double y)
        {
            return System.Math.Pow(x, y);
        }

        #endregion
        
        #region Exp

        /// <summary>
        /// Returns e raised to the specified number.
        /// </summary>
        [Pure]
        public static float Exp(this float x)
        {
            return (float)System.Math.Exp(x);
        }

        /// <summary>
        /// Returns e raised to the specified number.
        /// </summary>
        [Pure]
        public static double Exp(this double x)
        {
            return System.Math.Exp(x);
        }


        #endregion

        #region Log, Log10, Log2

        /// <summary>
        /// Returns the natural (base e) logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log(this byte x)
        {
            return System.Math.Log(x);
        }

        /// <summary>
        /// Returns the base 10 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log10(this byte x)
        {
            return System.Math.Log10(x);
        }

        /// <summary>
        /// Returns the base 2 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log2(this byte x)
        {
            return x.Log() * Constant.Ln2Inv;
        }

        /// <summary>
        /// Returns the values logarithm of the specified basis.
        /// </summary>
        [Pure]
        public static double Log(this byte x, double basis)
        {
            return x.Log() / basis.Log();
        }

        /// <summary>
        /// Returns the natural (base e) logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log(this sbyte x)
        {
            return System.Math.Log(x);
        }

        /// <summary>
        /// Returns the base 10 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log10(this sbyte x)
        {
            return System.Math.Log10(x);
        }

        /// <summary>
        /// Returns the base 2 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log2(this sbyte x)
        {
            return x.Log() * Constant.Ln2Inv;
        }

        /// <summary>
        /// Returns the values logarithm of the specified basis.
        /// </summary>
        [Pure]
        public static double Log(this sbyte x, double basis)
        {
            return x.Log() / basis.Log();
        }

        /// <summary>
        /// Returns the natural (base e) logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log(this short x)
        {
            return System.Math.Log(x);
        }

        /// <summary>
        /// Returns the base 10 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log10(this short x)
        {
            return System.Math.Log10(x);
        }

        /// <summary>
        /// Returns the base 2 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log2(this short x)
        {
            return x.Log() * Constant.Ln2Inv;
        }

        /// <summary>
        /// Returns the values logarithm of the specified basis.
        /// </summary>
        [Pure]
        public static double Log(this short x, double basis)
        {
            return x.Log() / basis.Log();
        }

        /// <summary>
        /// Returns the natural (base e) logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log(this ushort x)
        {
            return System.Math.Log(x);
        }

        /// <summary>
        /// Returns the base 10 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log10(this ushort x)
        {
            return System.Math.Log10(x);
        }

        /// <summary>
        /// Returns the base 2 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log2(this ushort x)
        {
            return x.Log() * Constant.Ln2Inv;
        }

        /// <summary>
        /// Returns the values logarithm of the specified basis.
        /// </summary>
        [Pure]
        public static double Log(this ushort x, double basis)
        {
            return x.Log() / basis.Log();
        }

        /// <summary>
        /// Returns the natural (base e) logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log(this int x)
        {
            return System.Math.Log(x);
        }

        /// <summary>
        /// Returns the base 10 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log10(this int x)
        {
            return System.Math.Log10(x);
        }

        /// <summary>
        /// Returns the base 2 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log2(this int x)
        {
            return x.Log() * Constant.Ln2Inv;
        }

        /// <summary>
        /// Returns the values logarithm of the specified basis.
        /// </summary>
        [Pure]
        public static double Log(this int x, double basis)
        {
            return x.Log() / basis.Log();
        }

        /// <summary>
        /// Returns the natural (base e) logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log(this uint x)
        {
            return System.Math.Log(x);
        }

        /// <summary>
        /// Returns the base 10 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log10(this uint x)
        {
            return System.Math.Log10(x);
        }

        /// <summary>
        /// Returns the base 2 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log2(this uint x)
        {
            return x.Log() * Constant.Ln2Inv;
        }

        /// <summary>
        /// Returns the values logarithm of the specified basis.
        /// </summary>
        [Pure]
        public static double Log(this uint x, double basis)
        {
            return x.Log() / basis.Log();
        }

        /// <summary>
        /// Returns the natural (base e) logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log(this long x)
        {
            return System.Math.Log(x);
        }

        /// <summary>
        /// Returns the base 10 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log10(this long x)
        {
            return System.Math.Log10(x);
        }

        /// <summary>
        /// Returns the base 2 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log2(this long x)
        {
            return x.Log() * Constant.Ln2Inv;
        }

        /// <summary>
        /// Returns the values logarithm of the specified basis.
        /// </summary>
        [Pure]
        public static double Log(this long x, double basis)
        {
            return x.Log() / basis.Log();
        }

        /// <summary>
        /// Returns the natural (base e) logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log(this ulong x)
        {
            return System.Math.Log(x);
        }

        /// <summary>
        /// Returns the base 10 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log10(this ulong x)
        {
            return System.Math.Log10(x);
        }

        /// <summary>
        /// Returns the base 2 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log2(this ulong x)
        {
            return x.Log() * Constant.Ln2Inv;
        }

        /// <summary>
        /// Returns the values logarithm of the specified basis.
        /// </summary>
        [Pure]
        public static double Log(this ulong x, double basis)
        {
            return x.Log() / basis.Log();
        }

        /// <summary>
        /// Returns the natural (base e) logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log(this float x)
        {
            return System.Math.Log(x);
        }

        /// <summary>
        /// Returns the base 10 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log10(this float x)
        {
            return System.Math.Log10(x);
        }

        /// <summary>
        /// Returns the base 2 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log2(this float x)
        {
            return x.Log() * Constant.Ln2Inv;
        }

        /// <summary>
        /// Returns the values logarithm of the specified basis.
        /// </summary>
        [Pure]
        public static double Log(this float x, double basis)
        {
            return x.Log() / basis.Log();
        }

        /// <summary>
        /// Returns the natural (base e) logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log(this double x)
        {
            return System.Math.Log(x);
        }

        /// <summary>
        /// Returns the base 10 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log10(this double x)
        {
            return System.Math.Log10(x);
        }

        /// <summary>
        /// Returns the base 2 logarithm of the specified number.
        /// </summary>
        [Pure]
        public static double Log2(this double x)
        {
            return x.Log() * Constant.Ln2Inv;
        }

        /// <summary>
        /// Returns the values logarithm of the specified basis.
        /// </summary>
        [Pure]
        public static double Log(this double x, double basis)
        {
            return x.Log() / basis.Log();
        }

        #endregion

        #region LinCom

        public static byte LinCom(
                byte p0, byte p1, byte p2, byte p3, ref Tup4<float> w)
        {
            return (byte)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3, (float)byte.MinValue, (float)byte.MaxValue);
        }

        public static float LinComRawF(
                byte p0, byte p1, byte p2, byte p3, ref Tup4<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3;
        }

        public static byte LinCom(
                byte p0, byte p1, byte p2, byte p3, ref Tup4<double> w)
        {
            return (byte)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3, (double)byte.MinValue, (double)byte.MaxValue);
        }

        public static double LinComRawD(
                byte p0, byte p1, byte p2, byte p3, ref Tup4<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3;
        }

        public static byte LinCom(
                byte p0, byte p1, byte p2, byte p3, byte p4, byte p5, ref Tup6<float> w)
        {
            return (byte)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5, (float)byte.MinValue, (float)byte.MaxValue);
        }

        public static float LinComRawF(
                byte p0, byte p1, byte p2, byte p3, byte p4, byte p5, ref Tup6<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5;
        }

        public static byte LinCom(
                byte p0, byte p1, byte p2, byte p3, byte p4, byte p5, ref Tup6<double> w)
        {
            return (byte)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5, (double)byte.MinValue, (double)byte.MaxValue);
        }

        public static double LinComRawD(
                byte p0, byte p1, byte p2, byte p3, byte p4, byte p5, ref Tup6<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5;
        }

        public static sbyte LinCom(
                sbyte p0, sbyte p1, sbyte p2, sbyte p3, ref Tup4<float> w)
        {
            return (sbyte)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3, (float)sbyte.MinValue, (float)sbyte.MaxValue);
        }

        public static float LinComRawF(
                sbyte p0, sbyte p1, sbyte p2, sbyte p3, ref Tup4<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3;
        }

        public static sbyte LinCom(
                sbyte p0, sbyte p1, sbyte p2, sbyte p3, ref Tup4<double> w)
        {
            return (sbyte)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3, (double)sbyte.MinValue, (double)sbyte.MaxValue);
        }

        public static double LinComRawD(
                sbyte p0, sbyte p1, sbyte p2, sbyte p3, ref Tup4<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3;
        }

        public static sbyte LinCom(
                sbyte p0, sbyte p1, sbyte p2, sbyte p3, sbyte p4, sbyte p5, ref Tup6<float> w)
        {
            return (sbyte)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5, (float)sbyte.MinValue, (float)sbyte.MaxValue);
        }

        public static float LinComRawF(
                sbyte p0, sbyte p1, sbyte p2, sbyte p3, sbyte p4, sbyte p5, ref Tup6<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5;
        }

        public static sbyte LinCom(
                sbyte p0, sbyte p1, sbyte p2, sbyte p3, sbyte p4, sbyte p5, ref Tup6<double> w)
        {
            return (sbyte)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5, (double)sbyte.MinValue, (double)sbyte.MaxValue);
        }

        public static double LinComRawD(
                sbyte p0, sbyte p1, sbyte p2, sbyte p3, sbyte p4, sbyte p5, ref Tup6<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5;
        }

        public static short LinCom(
                short p0, short p1, short p2, short p3, ref Tup4<float> w)
        {
            return (short)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3, (float)short.MinValue, (float)short.MaxValue);
        }

        public static float LinComRawF(
                short p0, short p1, short p2, short p3, ref Tup4<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3;
        }

        public static short LinCom(
                short p0, short p1, short p2, short p3, ref Tup4<double> w)
        {
            return (short)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3, (double)short.MinValue, (double)short.MaxValue);
        }

        public static double LinComRawD(
                short p0, short p1, short p2, short p3, ref Tup4<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3;
        }

        public static short LinCom(
                short p0, short p1, short p2, short p3, short p4, short p5, ref Tup6<float> w)
        {
            return (short)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5, (float)short.MinValue, (float)short.MaxValue);
        }

        public static float LinComRawF(
                short p0, short p1, short p2, short p3, short p4, short p5, ref Tup6<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5;
        }

        public static short LinCom(
                short p0, short p1, short p2, short p3, short p4, short p5, ref Tup6<double> w)
        {
            return (short)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5, (double)short.MinValue, (double)short.MaxValue);
        }

        public static double LinComRawD(
                short p0, short p1, short p2, short p3, short p4, short p5, ref Tup6<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5;
        }

        public static ushort LinCom(
                ushort p0, ushort p1, ushort p2, ushort p3, ref Tup4<float> w)
        {
            return (ushort)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3, (float)ushort.MinValue, (float)ushort.MaxValue);
        }

        public static float LinComRawF(
                ushort p0, ushort p1, ushort p2, ushort p3, ref Tup4<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3;
        }

        public static ushort LinCom(
                ushort p0, ushort p1, ushort p2, ushort p3, ref Tup4<double> w)
        {
            return (ushort)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3, (double)ushort.MinValue, (double)ushort.MaxValue);
        }

        public static double LinComRawD(
                ushort p0, ushort p1, ushort p2, ushort p3, ref Tup4<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3;
        }

        public static ushort LinCom(
                ushort p0, ushort p1, ushort p2, ushort p3, ushort p4, ushort p5, ref Tup6<float> w)
        {
            return (ushort)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5, (float)ushort.MinValue, (float)ushort.MaxValue);
        }

        public static float LinComRawF(
                ushort p0, ushort p1, ushort p2, ushort p3, ushort p4, ushort p5, ref Tup6<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5;
        }

        public static ushort LinCom(
                ushort p0, ushort p1, ushort p2, ushort p3, ushort p4, ushort p5, ref Tup6<double> w)
        {
            return (ushort)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5, (double)ushort.MinValue, (double)ushort.MaxValue);
        }

        public static double LinComRawD(
                ushort p0, ushort p1, ushort p2, ushort p3, ushort p4, ushort p5, ref Tup6<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5;
        }

        public static int LinCom(
                int p0, int p1, int p2, int p3, ref Tup4<float> w)
        {
            return (int)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3, (float)int.MinValue, (float)int.MaxValue);
        }

        public static float LinComRawF(
                int p0, int p1, int p2, int p3, ref Tup4<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3;
        }

        public static int LinCom(
                int p0, int p1, int p2, int p3, ref Tup4<double> w)
        {
            return (int)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3, (double)int.MinValue, (double)int.MaxValue);
        }

        public static double LinComRawD(
                int p0, int p1, int p2, int p3, ref Tup4<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3;
        }

        public static int LinCom(
                int p0, int p1, int p2, int p3, int p4, int p5, ref Tup6<float> w)
        {
            return (int)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5, (float)int.MinValue, (float)int.MaxValue);
        }

        public static float LinComRawF(
                int p0, int p1, int p2, int p3, int p4, int p5, ref Tup6<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5;
        }

        public static int LinCom(
                int p0, int p1, int p2, int p3, int p4, int p5, ref Tup6<double> w)
        {
            return (int)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5, (double)int.MinValue, (double)int.MaxValue);
        }

        public static double LinComRawD(
                int p0, int p1, int p2, int p3, int p4, int p5, ref Tup6<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5;
        }

        public static uint LinCom(
                uint p0, uint p1, uint p2, uint p3, ref Tup4<float> w)
        {
            return (uint)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3, (float)uint.MinValue, (float)uint.MaxValue);
        }

        public static float LinComRawF(
                uint p0, uint p1, uint p2, uint p3, ref Tup4<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3;
        }

        public static uint LinCom(
                uint p0, uint p1, uint p2, uint p3, ref Tup4<double> w)
        {
            return (uint)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3, (double)uint.MinValue, (double)uint.MaxValue);
        }

        public static double LinComRawD(
                uint p0, uint p1, uint p2, uint p3, ref Tup4<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3;
        }

        public static uint LinCom(
                uint p0, uint p1, uint p2, uint p3, uint p4, uint p5, ref Tup6<float> w)
        {
            return (uint)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5, (float)uint.MinValue, (float)uint.MaxValue);
        }

        public static float LinComRawF(
                uint p0, uint p1, uint p2, uint p3, uint p4, uint p5, ref Tup6<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5;
        }

        public static uint LinCom(
                uint p0, uint p1, uint p2, uint p3, uint p4, uint p5, ref Tup6<double> w)
        {
            return (uint)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5, (double)uint.MinValue, (double)uint.MaxValue);
        }

        public static double LinComRawD(
                uint p0, uint p1, uint p2, uint p3, uint p4, uint p5, ref Tup6<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5;
        }

        public static long LinCom(
                long p0, long p1, long p2, long p3, ref Tup4<float> w)
        {
            return (long)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3, (float)long.MinValue, (float)long.MaxValue);
        }

        public static float LinComRawF(
                long p0, long p1, long p2, long p3, ref Tup4<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3;
        }

        public static long LinCom(
                long p0, long p1, long p2, long p3, ref Tup4<double> w)
        {
            return (long)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3, (double)long.MinValue, (double)long.MaxValue);
        }

        public static double LinComRawD(
                long p0, long p1, long p2, long p3, ref Tup4<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3;
        }

        public static long LinCom(
                long p0, long p1, long p2, long p3, long p4, long p5, ref Tup6<float> w)
        {
            return (long)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5, (float)long.MinValue, (float)long.MaxValue);
        }

        public static float LinComRawF(
                long p0, long p1, long p2, long p3, long p4, long p5, ref Tup6<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5;
        }

        public static long LinCom(
                long p0, long p1, long p2, long p3, long p4, long p5, ref Tup6<double> w)
        {
            return (long)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5, (double)long.MinValue, (double)long.MaxValue);
        }

        public static double LinComRawD(
                long p0, long p1, long p2, long p3, long p4, long p5, ref Tup6<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5;
        }

        public static ulong LinCom(
                ulong p0, ulong p1, ulong p2, ulong p3, ref Tup4<float> w)
        {
            return (ulong)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3, (float)ulong.MinValue, (float)ulong.MaxValue);
        }

        public static float LinComRawF(
                ulong p0, ulong p1, ulong p2, ulong p3, ref Tup4<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3;
        }

        public static ulong LinCom(
                ulong p0, ulong p1, ulong p2, ulong p3, ref Tup4<double> w)
        {
            return (ulong)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3, (double)ulong.MinValue, (double)ulong.MaxValue);
        }

        public static double LinComRawD(
                ulong p0, ulong p1, ulong p2, ulong p3, ref Tup4<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3;
        }

        public static ulong LinCom(
                ulong p0, ulong p1, ulong p2, ulong p3, ulong p4, ulong p5, ref Tup6<float> w)
        {
            return (ulong)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5, (float)ulong.MinValue, (float)ulong.MaxValue);
        }

        public static float LinComRawF(
                ulong p0, ulong p1, ulong p2, ulong p3, ulong p4, ulong p5, ref Tup6<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5;
        }

        public static ulong LinCom(
                ulong p0, ulong p1, ulong p2, ulong p3, ulong p4, ulong p5, ref Tup6<double> w)
        {
            return (ulong)Fun.Clamp(p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5, (double)ulong.MinValue, (double)ulong.MaxValue);
        }

        public static double LinComRawD(
                ulong p0, ulong p1, ulong p2, ulong p3, ulong p4, ulong p5, ref Tup6<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5;
        }

        public static float LinCom(float p0, float p1, ref Tup2<float> w)
        {
            return p0 * w.E0 + p1 * w.E1;
        }

        public static double LinCom(double p0, double p1, ref Tup2<double> w)
        {
            return p0 * w.E0 + p1 * w.E1;
        }

        public static float LinCom(float p0, float p1, float p2, ref Tup3<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2;
        }

        public static double LinCom(double p0, double p1, double p2, ref Tup3<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2;
        }

        public static float LinCom(float p0, float p1, float p2, float p3, ref Tup4<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3;
        }

        public static double LinCom(double p0, double p1, double p2, double p3, ref Tup4<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3;
        }

        public static float LinCom(float p0, float p1, float p2, float p3, float p4, ref Tup5<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4;
        }

        public static double LinCom(double p0, double p1, double p2, double p3, double p4, ref Tup5<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4;
        }

        public static float LinCom(float p0, float p1, float p2, float p3, float p4, float p5, ref Tup6<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5;
        }

        public static double LinCom(double p0, double p1, double p2, double p3, double p4, double p5, ref Tup6<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5;
        }

        public static float LinCom(float p0, float p1, float p2, float p3, float p4, float p5, float p6, ref Tup7<float> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5 + p6 * w.E6;
        }

        public static double LinCom(double p0, double p1, double p2, double p3, double p4, double p5, double p6, ref Tup7<double> w)
        {
            return p0 * w.E0 + p1 * w.E1 + p2 * w.E2 + p3 * w.E3 + p4 * w.E4 + p5 * w.E5 + p6 * w.E6;
        }

        #endregion

        #region ModP

        /// <summary>
        /// Returns the positive modulo operation a mod b giving values between [0,b[ 
        /// instead of a % b giving values between ]-b,b[.
        /// </summary>
        [Pure]
        public static sbyte ModP(this sbyte a, sbyte b)
        {
            var m = a % b;
            if (m < 0)
                m += b;
            return (sbyte)m;
        }

        /// <summary>
        /// Returns the positive modulo operation a mod b giving values between [0,b[ 
        /// instead of a % b giving values between ]-b,b[.
        /// </summary>
        [Pure]
        public static short ModP(this short a, short b)
        {
            var m = a % b;
            if (m < 0)
                m += b;
            return (short)m;
        }

        /// <summary>
        /// Returns the positive modulo operation a mod b giving values between [0,b[ 
        /// instead of a % b giving values between ]-b,b[.
        /// </summary>
        [Pure]
        public static int ModP(this int a, int b)
        {
            var m = a % b;
            if (m < 0)
                m += b;
            return (int)m;
        }

        /// <summary>
        /// Returns the positive modulo operation a mod b giving values between [0,b[ 
        /// instead of a % b giving values between ]-b,b[.
        /// </summary>
        [Pure]
        public static long ModP(this long a, long b)
        {
            var m = a % b;
            if (m < 0)
                m += b;
            return (long)m;
        }

        /// <summary>
        /// Returns the positive modulo operation a mod b giving values between [0,b[ 
        /// instead of a % b giving values between ]-b,b[.
        /// </summary>
        [Pure]
        public static float ModP(this float a, float b)
        {
            var m = a % b;
            if (m < 0)
                m += b;
            return (float)m;
        }

        /// <summary>
        /// Returns the positive modulo operation a mod b giving values between [0,b[ 
        /// instead of a % b giving values between ]-b,b[.
        /// </summary>
        [Pure]
        public static double ModP(this double a, double b)
        {
            var m = a % b;
            if (m < 0)
                m += b;
            return (double)m;
        }

        /// <summary>
        /// Returns the positive modulo operation a mod b giving values between [0,b[ 
        /// instead of a % b giving values between ]-b,b[.
        /// </summary>
        [Pure]
        public static decimal ModP(this decimal a, decimal b)
        {
            var m = a % b;
            if (m < 0)
                m += b;
            return (decimal)m;
        }

        #endregion

        #region PowerOfTwo

        /// <summary>
        /// Returns true if the supplied number is 0
        /// or a power of two.
        /// </summary>
        [Pure]
        public static bool IsPowerOfTwo(this int x)
        {
            return (x & (x - 1)) == 0;
        }

        /// <summary>
        /// Returns true if the supplied number is 0
        /// or a power of two.
        /// </summary>
        [Pure]
        public static bool IsPowerOfTwo(this long x)
        {
            return (x & (x - 1)) == 0;
        }

        /// <summary>
        /// Returns 2 raised to the power of the value.
        /// </summary>
        [Pure]
        public static long PowerOfTwo(this long x)
        {
            return 1L << (int)x;
        }

        /// <summary>
        /// Returns 2 raised to the power of the value.
        /// </summary>
        [Pure]
        public static float PowerOfTwo(this float x)
        {
            return (float)System.Math.Pow(2, x);
        }

        /// <summary>
        /// Returns 2 raised to the power of the value.
        /// </summary>
        [Pure]
        public static double PowerOfTwo(this double x)
        {
            return System.Math.Pow(2, x);
        }

        /// <summary>
        /// Returns the nearest superior power of two of the value.
        /// E.g. x = 401 -> 512.
        /// E.g. x = 256 -> 256.
        /// </summary>
        [Pure]
        public static int NextPowerOfTwo(this int x)
        {
            --x;
            x |= x >> 1;
            x |= x >> 2;
            x |= x >> 4;
            x |= x >> 8;
            x |= x >> 16;
            return ++x;
        }

        /// <summary>
        /// Returns the nearest inferior power of two of the value.
        /// E.g. x = 401 -> 256.
        /// E.g. x = 512 -> 512.
        /// </summary>
        [Pure]
        public static int PrevPowerOfTwo(this int x)
        {
            if (x <= 0) return 0;
            x >>= 1;
            x |= x >> 1;
            x |= x >> 2;
            x |= x >> 4;
            x |= x >> 8;
            x |= x >> 16;
            return ++x;
        }

        /// <summary>
        /// Returns the nearest superior power of two of the value.
        /// E.g. x = 401 -> 512.
        /// E.g. x = 256 -> 256.
        /// </summary>
        [Pure]
        public static long NextPowerOfTwo(this long x)
        {
            --x;
            x |= x >> 1;
            x |= x >> 2;
            x |= x >> 4;
            x |= x >> 8;
            x |= x >> 16;
            x |= x >> 32;
            return ++x;
        }

        /// <summary>
        /// Returns the nearest inferior power of two of the value.
        /// E.g. x = 401 -> 256.
        /// E.g. x = 512 -> 512.
        /// </summary>
        [Pure]
        public static long PrevPowerOfTwo(this long x)
        {
            if (x <= 0) return 0;
            x >>= 1;
            x |= x >> 1;
            x |= x >> 2;
            x |= x >> 4;
            x |= x >> 8;
            x |= x >> 16;
            x |= x >> 32;
            return ++x;
        }

        #endregion

        #region Trigonometry

        /// <summary>
        /// Returns the cosine of the specified angle in radians.
        /// </summary>
        [Pure]
        public static float Sin(this float x)
        {
            return (float)System.Math.Sin(x);
        }

        /// <summary>
        /// Returns the cosine of the specified angle in radians.
        /// </summary>
        [Pure]
        public static float Cos(this float x)
        {
            return (float)System.Math.Cos(x);
        }

        /// <summary>
        /// Returns the tangent of the specified angle in radians.
        /// </summary>
        [Pure]
        public static float Tan(this float x)
        {
            return (float)System.Math.Tan(x);
        }

        /// <summary>
        /// Returns the angle in radians whose sine is the specified number.
        /// </summary>
        [Pure]
        public static float Asin(this float x)
        {
            return (float)System.Math.Asin(x);
        }

        /// <summary>
        /// Returns the angle in radians whose cosine is the specified number.
        /// </summary>
        [Pure]
        public static float Acos(this float x)
        {
            return (float)System.Math.Acos(x);
        }

        /// <summary>
        /// Returns the angle in radians whose tangent is the specified number.
        /// </summary>
        [Pure]
        public static float Atan(this float x)
        {
            return (float)System.Math.Atan(x);
        }

        /// <summary>
        /// Returns the angle in radians whose tangent is
        /// the quotient of the two specified number.
        /// </summary>
        [Pure]
        public static float Atan2(float y, float x)
        {
            return (float)System.Math.Atan2(y, x);
        }

        /// <summary>
        /// Returns the angle in radians whose tangent is
        /// the quotient of the two specified number using
        /// a faster algorithm than Math.Atan2.
        /// NOTE: Accuracy untested
        /// </summary>
        [Pure]
        public static float FastAtan2(float y, float x)
        {
            float angle;
            double piThreeFourths = Constant.Pi * 3 / 4;
            double yAbs = y.Abs() + Constant<double>.PositiveTinyValue; // prevent 0/0 condition
            if (x >= 0)
            {
                double r = (x - yAbs) / (x + yAbs);
                angle = (float)(Constant.PiQuarter * (1 - r));
            }
            else
            {
                double r = (x + yAbs) / (yAbs - x);
                angle = (float)(piThreeFourths - Constant.PiQuarter * r);
            }

            return y < 0 ? -angle : angle; // negate if in quad III or IV
        }

        /// <summary>
        /// Returns the hyperbolic sine of the specified number.
        /// </summary>
        [Pure]
        public static float Sinh(this float x)
        {
            return (float)System.Math.Sinh(x);
        }

        /// <summary>
        /// Returns the hyperbolic cosine of the specified number.
        /// </summary>
        [Pure]
        public static float Cosh(this float x)
        {
            return (float)System.Math.Cosh(x);
        }

        /// <summary>
        /// Returns the hyperbolic tangent of the specified number.
        /// </summary>
        [Pure]
        public static float Tanh(this float x)
        {
            return (float)System.Math.Tanh(x);
        }

        /// <summary>
        /// Returns the inverse hyperbolic sine of the specified number.
        /// </summary>
        [Pure]
        public static float Asinh(this float x)
        {
            return (float)System.Math.Log(x + System.Math.Sqrt(x * x + 1.0));
        }

        /// <summary>
        /// Returns the inverse hyperbolic cosine of the specified number.
        /// </summary>
        [Pure]
        public static float Acosh(this float x)
        {
            return (float)System.Math.Log(x + System.Math.Sqrt(x * x - 1.0));
        }

        /// <summary>
        /// Returns the inverse hyperbolic tangent of the specified number.
        /// Note that the absolute value of the argument must be smaller than 1.
        /// </summary>
        [Pure]
        public static float Atanh(this float x)
        {
            return (float)(0.5 * System.Math.Log((1.0 + x)/(1.0 - x)));
        }

        /// <summary>
        /// Returns the cosine of the specified angle in radians.
        /// </summary>
        [Pure]
        public static double Sin(this double x)
        {
            return System.Math.Sin(x);
        }

        /// <summary>
        /// Returns the cosine of the specified angle in radians.
        /// </summary>
        [Pure]
        public static double Cos(this double x)
        {
            return System.Math.Cos(x);
        }

        /// <summary>
        /// Returns the tangent of the specified angle in radians.
        /// </summary>
        [Pure]
        public static double Tan(this double x)
        {
            return System.Math.Tan(x);
        }

        /// <summary>
        /// Returns the angle in radians whose sine is the specified number.
        /// </summary>
        [Pure]
        public static double Asin(this double x)
        {
            return System.Math.Asin(x);
        }

        /// <summary>
        /// Returns the angle in radians whose cosine is the specified number.
        /// </summary>
        [Pure]
        public static double Acos(this double x)
        {
            return System.Math.Acos(x);
        }

        /// <summary>
        /// Returns the angle in radians whose tangent is the specified number.
        /// </summary>
        [Pure]
        public static double Atan(this double x)
        {
            return System.Math.Atan(x);
        }

        /// <summary>
        /// Returns the angle in radians whose tangent is
        /// the quotient of the two specified number.
        /// </summary>
        [Pure]
        public static double Atan2(double y, double x)
        {
            return System.Math.Atan2(y, x);
        }

        /// <summary>
        /// Returns the angle in radians whose tangent is
        /// the quotient of the two specified number using
        /// a faster algorithm than Math.Atan2.
        /// NOTE: Accuracy untested
        /// </summary>
        [Pure]
        public static double FastAtan2(double y, double x)
        {
            double angle;
            double piThreeFourths = Constant.Pi * 3 / 4;
            double yAbs = y.Abs() + Constant<double>.PositiveTinyValue; // prevent 0/0 condition
            if (x >= 0)
            {
                double r = (x - yAbs) / (x + yAbs);
                angle = (Constant.PiQuarter * (1 - r));
            }
            else
            {
                double r = (x + yAbs) / (yAbs - x);
                angle = (piThreeFourths - Constant.PiQuarter * r);
            }

            return y < 0 ? -angle : angle; // negate if in quad III or IV
        }

        /// <summary>
        /// Returns the hyperbolic sine of the specified number.
        /// </summary>
        [Pure]
        public static double Sinh(this double x)
        {
            return System.Math.Sinh(x);
        }

        /// <summary>
        /// Returns the hyperbolic cosine of the specified number.
        /// </summary>
        [Pure]
        public static double Cosh(this double x)
        {
            return System.Math.Cosh(x);
        }

        /// <summary>
        /// Returns the hyperbolic tangent of the specified number.
        /// </summary>
        [Pure]
        public static double Tanh(this double x)
        {
            return System.Math.Tanh(x);
        }

        /// <summary>
        /// Returns the inverse hyperbolic sine of the specified number.
        /// </summary>
        [Pure]
        public static double Asinh(this double x)
        {
            return System.Math.Log(x + System.Math.Sqrt(x * x + 1.0));
        }

        /// <summary>
        /// Returns the inverse hyperbolic cosine of the specified number.
        /// </summary>
        [Pure]
        public static double Acosh(this double x)
        {
            return System.Math.Log(x + System.Math.Sqrt(x * x - 1.0));
        }

        /// <summary>
        /// Returns the inverse hyperbolic tangent of the specified number.
        /// Note that the absolute value of the argument must be smaller than 1.
        /// </summary>
        [Pure]
        public static double Atanh(this double x)
        {
            return (0.5 * System.Math.Log((1.0 + x)/(1.0 - x)));
        }

        #endregion

        #region Mean

        /// <summary>
        /// Returns the mean of the given values.
        /// </summary>
        [Pure]
        public static double Mean(this IEnumerable<byte> array)
        {
            int count = 0;
            int sum = 0;
            foreach (var x in array) { sum += x; ++count; }
            return (double)sum / count;
        }

        /// <summary>
        /// Returns the mean of the given values.
        /// </summary>
        [Pure]
        public static double Mean(this IEnumerable<sbyte> array)
        {
            int count = 0;
            int sum = 0;
            foreach (var x in array) { sum += x; ++count; }
            return (double)sum / count;
        }

        /// <summary>
        /// Returns the mean of the given values.
        /// </summary>
        [Pure]
        public static double Mean(this IEnumerable<short> array)
        {
            int count = 0;
            long sum = 0;
            foreach (var x in array) { sum += x; ++count; }
            return (double)sum / count;
        }

        /// <summary>
        /// Returns the mean of the given values.
        /// </summary>
        [Pure]
        public static double Mean(this IEnumerable<ushort> array)
        {
            int count = 0;
            long sum = 0;
            foreach (var x in array) { sum += x; ++count; }
            return (double)sum / count;
        }

        /// <summary>
        /// Returns the mean of the given values.
        /// </summary>
        [Pure]
        public static double Mean(this IEnumerable<int> array)
        {
            int count = 0;
            long sum = 0;
            foreach (var x in array) { sum += x; ++count; }
            return (double)sum / count;
        }

        /// <summary>
        /// Returns the mean of the given values.
        /// </summary>
        [Pure]
        public static double Mean(this IEnumerable<uint> array)
        {
            int count = 0;
            long sum = 0;
            foreach (var x in array) { sum += x; ++count; }
            return (double)sum / count;
        }

        /// <summary>
        /// Returns the mean of the given values.
        /// </summary>
        [Pure]
        public static double Mean(this IEnumerable<long> array)
        {
            int count = 0;
            long sum = 0;
            foreach (var x in array) { sum += x; ++count; }
            return (double)sum / count;
        }

        /// <summary>
        /// Returns the mean of the given values.
        /// </summary>
        [Pure]
        public static double Mean(this IEnumerable<ulong> array)
        {
            int count = 0;
            ulong sum = 0;
            foreach (var x in array) { sum += x; ++count; }
            return (double)sum / count;
        }

        /// <summary>
        /// Returns the mean of the given values.
        /// </summary>
        [Pure]
        public static double Mean(this IEnumerable<float> array)
        {
            int count = 0;
            double sum = 0;
            foreach (var x in array) { sum += x; ++count; }
            return (double)sum / count;
        }

        /// <summary>
        /// Returns the mean of the given values.
        /// </summary>
        [Pure]
        public static double Mean(this IEnumerable<double> array)
        {
            int count = 0;
            double sum = 0;
            foreach (var x in array) { sum += x; ++count; }
            return (double)sum / count;
        }

        [Pure]
        public static decimal Mean(this IEnumerable<decimal> array)
        {
            int count = 0; decimal sum = 0;
            foreach (var x in array) { sum += x; ++count; }
            return (decimal)sum / count;
        }

        /// <summary>
        /// Returns the mean of the given values.
        /// </summary>
        [Pure]
        public static double Mean<T>(
            this IEnumerable<T> array,
            Func<T, double> selector
            )
        {
            int count = 0; double sum = 0;
            foreach (var x in array) { sum += selector(x); ++count; }
            return sum / count;
        }

        #endregion

        #region Variance & Standard Deviation

        /// <summary>
        /// Calculates the variance of given elements.
        /// </summary>
        [Pure]
        public static double Variance(this IEnumerable<int> data)
        {
            int count = 0;
            double sum = 0, mean = data.Mean();

            foreach (var x in data)
            {
                sum += (x - mean).Square();
                count++;
            }

            return sum / count;
        }

        /// <summary>
        /// Calculates the standard deviation of given elements.
        /// </summary>
        [Pure]
        public static double StandardDeviation(this IEnumerable<int> data)
        {
            return data.Variance().Sqrt();
        }

        /// <summary>
        /// Calculates the variance of given elements.
        /// </summary>
        [Pure]
        public static double Variance(this IEnumerable<long> data)
        {
            int count = 0;
            double sum = 0, mean = data.Mean();

            foreach (var x in data)
            {
                sum += (x - mean).Square();
                count++;
            }

            return sum / count;
        }

        /// <summary>
        /// Calculates the standard deviation of given elements.
        /// </summary>
        [Pure]
        public static double StandardDeviation(this IEnumerable<long> data)
        {
            return data.Variance().Sqrt();
        }

        /// <summary>
        /// Calculates the variance of given elements.
        /// </summary>
        [Pure]
        public static double Variance(this IEnumerable<float> data)
        {
            int count = 0;
            double sum = 0, mean = data.Mean();

            foreach (var x in data)
            {
                sum += (x - mean).Square();
                count++;
            }

            return sum / count;
        }

        /// <summary>
        /// Calculates the standard deviation of given elements.
        /// </summary>
        [Pure]
        public static double StandardDeviation(this IEnumerable<float> data)
        {
            return data.Variance().Sqrt();
        }

        /// <summary>
        /// Calculates the variance of given elements.
        /// </summary>
        [Pure]
        public static double Variance(this IEnumerable<double> data)
        {
            int count = 0;
            double sum = 0, mean = data.Mean();

            foreach (var x in data)
            {
                sum += (x - mean).Square();
                count++;
            }

            return sum / count;
        }

        /// <summary>
        /// Calculates the standard deviation of given elements.
        /// </summary>
        [Pure]
        public static double StandardDeviation(this IEnumerable<double> data)
        {
            return data.Variance().Sqrt();
        }

        /// <summary>
        /// Calculates the variance of given elements.
        /// </summary>
        [Pure]
        public static double Variance<T>(
            this IEnumerable<T> data,
            Func<T, double> selector
            )
        {
            int count = 0;
            double sum = 0, mean = data.Mean(selector);

            foreach (var x in data)
            {
                sum += (selector(x) - mean).Square();
                count++;
            }

            return sum / count;
        }

        /// <summary>
        /// Calculates the standard deviation of given elements.
        /// </summary>
        [Pure]
        public static double StandardDeviation<T>(
            this IEnumerable<T> data,
            Func<T, double> selector)
        {
            return data.Variance(selector).Sqrt();
        }

        #endregion

        #region CountPositives

        /// <summary>
        /// Return the number of values greater than 0.
        /// </summary>
        [Pure]
        public static int CountPositives(this IEnumerable<sbyte> array)
        {
            int count = 0;
            foreach (var x in array) if (x > 0) ++count;
            return count;
        }

        /// <summary>
        /// Return the number of values greater than 0.
        /// </summary>
        [Pure]
        public static int CountPositives(this IEnumerable<short> array)
        {
            int count = 0;
            foreach (var x in array) if (x > 0) ++count;
            return count;
        }

        /// <summary>
        /// Return the number of values greater than 0.
        /// </summary>
        [Pure]
        public static int CountPositives(this IEnumerable<int> array)
        {
            int count = 0;
            foreach (var x in array) if (x > 0) ++count;
            return count;
        }

        /// <summary>
        /// Return the number of values greater than 0.
        /// </summary>
        [Pure]
        public static int CountPositives(this IEnumerable<long> array)
        {
            int count = 0;
            foreach (var x in array) if (x > 0) ++count;
            return count;
        }

        /// <summary>
        /// Return the number of values greater than 0.
        /// </summary>
        [Pure]
        public static int CountPositives(this IEnumerable<float> array)
        {
            int count = 0;
            foreach (var x in array) if (x > 0) ++count;
            return count;
        }

        /// <summary>
        /// Return the number of values greater than 0.
        /// </summary>
        [Pure]
        public static int CountPositives(this IEnumerable<double> array)
        {
            int count = 0;
            foreach (var x in array) if (x > 0) ++count;
            return count;
        }

        /// <summary>
        /// Return the number of values greater than 0.
        /// </summary>
        [Pure]
        public static int CountPositives(this IEnumerable<decimal> array)
        {
            int count = 0;
            foreach (var x in array) if (x > 0) ++count;
            return count;
        }


        #endregion 

        #region CountNegatives

        /// <summary>
        /// Return the number of values less than 0.
        /// </summary>
        [Pure]
        public static int CountNegatives(this IEnumerable<sbyte> array)
        {
            int count = 0;
            foreach (var x in array) if (x < 0) ++count;
            return count;
        }

        /// <summary>
        /// Return the number of values less than 0.
        /// </summary>
        [Pure]
        public static int CountNegatives(this IEnumerable<short> array)
        {
            int count = 0;
            foreach (var x in array) if (x < 0) ++count;
            return count;
        }

        /// <summary>
        /// Return the number of values less than 0.
        /// </summary>
        [Pure]
        public static int CountNegatives(this IEnumerable<int> array)
        {
            int count = 0;
            foreach (var x in array) if (x < 0) ++count;
            return count;
        }

        /// <summary>
        /// Return the number of values less than 0.
        /// </summary>
        [Pure]
        public static int CountNegatives(this IEnumerable<long> array)
        {
            int count = 0;
            foreach (var x in array) if (x < 0) ++count;
            return count;
        }

        /// <summary>
        /// Return the number of values less than 0.
        /// </summary>
        [Pure]
        public static int CountNegatives(this IEnumerable<float> array)
        {
            int count = 0;
            foreach (var x in array) if (x < 0) ++count;
            return count;
        }

        /// <summary>
        /// Return the number of values less than 0.
        /// </summary>
        [Pure]
        public static int CountNegatives(this IEnumerable<double> array)
        {
            int count = 0;
            foreach (var x in array) if (x < 0) ++count;
            return count;
        }

        /// <summary>
        /// Return the number of values less than 0.
        /// </summary>
        [Pure]
        public static int CountNegatives(this IEnumerable<decimal> array)
        {
            int count = 0;
            foreach (var x in array) if (x < 0) ++count;
            return count;
        }

        #endregion

        #region Frac

        /// <summary>
        /// Returns fractional part of t. Calculated as t - floor(t).
        /// </summary>
        [Pure]
        public static double Frac(this double t)
        {
            return t - System.Math.Floor(t);
        }

        /// <summary>
        /// Returns fractional part of t. Calculated as t - floor(t).
        /// </summary>
        [Pure]
        public static float Frac(this float t)
        {
            return (float)(t - System.Math.Floor(t));
        }

        /// <summary>
        /// Returns fractional part of t. Calculated as t - floor(t).
        /// </summary>
        [Pure]
        public static decimal Frac(this decimal t)
        {
            return t - System.Math.Floor(t);
        }

        #endregion
        
        #region Primes

        /// <summary>
        /// Checks if the given value is a prime number.
        /// </summary>
        /// <param name="value">The number to check.</param>
        /// <returns><c>True</c> if the number is a prime; otherwise, <c>False</c>.</returns>
        [Pure]
        public static bool IsPrime(this int value)
        {
            int imax = (int)System.Math.Sqrt(value);

            for (int i = 2; i <= imax; i++)
                if (value % i == 0) return false;

            return true;
        }

        /// <summary>
        /// Checks if the given value is a prime number.
        /// </summary>
        /// <param name="value">The number to check.</param>
        /// <returns><c>True</c> if the number is a prime; otherwise, <c>False</c>.</returns>
        [Pure]
        public static bool IsPrime(this long value)
        {
            long imax = (long)System.Math.Sqrt(value);

            for (long i = 2; i <= imax; i++)
                if (value % i == 0) return false;

            return true;
        }

        
        #endregion

        #region Swap

        /// <summary>
        /// Swaps <paramref name="a"/> and <paramref name="b"/>,
        /// so that afterwards a=b and b=a.
        /// </summary>
        public static void Swap<T>(ref T a, ref T b)
        {
            T t = a;
            a = b;
            b = t;
        }

        /// <summary>
        /// Rotates left <paramref name="a"/>, <paramref name="b"/>, and <paramref name="c"/>,
        /// so that afterwards a=b, b=c and c=a.
        /// </summary>
        public static void Rotate<T>(ref T a, ref T b, ref T c)
        {
            T t = a; a = b; b = c; c = t;
        }

        /// <summary>
        /// Rotates left <paramref name="a"/>, <paramref name="b"/>, <paramref name="c"/>, and <paramref name="d"/>,
        /// so that afterwards a=b, b=c, c=b and d=a.
        /// </summary>
        public static void Rotate<T>(ref T a, ref T b, ref T c, ref T d)
        {
            T t = a; a = b; b = c; c = d; d = t;
        }

        /// <summary>
        /// Rotates left <paramref name="a"/>, <paramref name="b"/>, <paramref name="c"/>, <paramref name="d"/>, and <paramref name="e"/>,
        /// so that afterwards a=b, b=c, c=b and d=c and e=a.
        /// </summary>
        public static void Rotate<T>(ref T a, ref T b, ref T c, ref T d, ref T e)
        {
            T t = a; a = b; b = c; c = d; d = e; e = t;
        }

        #endregion

        #region Common Divisor and Multiple

        [Pure]
        public static long GreatestCommonDivisor(long a, long b)
        {
            return b == 0 ? a : GreatestCommonDivisor(b, a % b);
        }

        [Pure]
        public static long LeastCommonMultiple(long a, long b)
        {
            return a * b / GreatestCommonDivisor(a, b);
        }

        #endregion

        #region Conversion

        [Pure]
        public static int ToInt(this float x)
        {
            return (int)x;
        }

        [Pure]
        public static long ToLong(this float x)
        {
            return (long)x;
        }

        [Pure]
        public static int ToInt(this double x)
        {
            return (int)x;
        }

        [Pure]
        public static long ToLong(this double x)
        {
            return (long)x;
        }

        #endregion

        #region Weighted Sum

        [Pure]
        public static double WeightedSum(this double[] items, double[] weights)
        {
            var r = 0.0;
            var count = weights.LongLength;
            for (long i = 0; i < count; i++) r += weights[i] * items[i];
            return r;
        }

        #endregion
    }
}